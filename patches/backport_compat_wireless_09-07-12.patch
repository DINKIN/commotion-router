Index: package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch
===================================================================
--- package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch	(revision 31639)
+++ package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch	(working copy)
@@ -1,40 +1,6 @@
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1445,15 +1445,6 @@ static int ath9k_add_interface(struct ie
- 		}
- 	}
- 
--	if ((ah->opmode == NL80211_IFTYPE_ADHOC) ||
--	    ((vif->type == NL80211_IFTYPE_ADHOC) &&
--	     sc->nvifs > 0)) {
--		ath_err(common, "Cannot create ADHOC interface when other"
--			" interfaces already exist.\n");
--		ret = -EINVAL;
--		goto out;
--	}
--
- 	ath_dbg(common, CONFIG, "Attach a VIF of type: %d\n", vif->type);
- 
- 	sc->nvifs++;
-@@ -1478,15 +1469,6 @@ static int ath9k_change_interface(struct
- 	mutex_lock(&sc->mutex);
- 	ath9k_ps_wakeup(sc);
- 
--	/* See if new interface type is valid. */
--	if ((new_type == NL80211_IFTYPE_ADHOC) &&
--	    (sc->nvifs > 1)) {
--		ath_err(common, "When using ADHOC, it must be the only"
--			" interface.\n");
--		ret = -EINVAL;
--		goto out;
--	}
--
- 	if (ath9k_uses_beacons(new_type) &&
- 	    !ath9k_uses_beacons(vif->type)) {
- 		if (sc->nbcnvifs >= ATH_BCBUF) {
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -655,6 +655,7 @@ static const struct ieee80211_iface_limi
+@@ -667,6 +667,7 @@ static const struct ieee80211_iface_limi
  #ifdef CONFIG_MAC80211_MESH
  				 BIT(NL80211_IFTYPE_MESH_POINT) |
  #endif
Index: package/mac80211/patches/502-ath9k_ahb_init.patch
===================================================================
--- package/mac80211/patches/502-ath9k_ahb_init.patch	(revision 31639)
+++ package/mac80211/patches/502-ath9k_ahb_init.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -904,23 +904,23 @@ static int __init ath9k_init(void)
+@@ -926,23 +926,23 @@ static int __init ath9k_init(void)
  		goto err_out;
  	}
  
Index: package/mac80211/patches/850-brcmsmac-add-support-for-BCM43224.patch
===================================================================
--- package/mac80211/patches/850-brcmsmac-add-support-for-BCM43224.patch	(revision 0)
+++ package/mac80211/patches/850-brcmsmac-add-support-for-BCM43224.patch	(revision 0)
@@ -0,0 +1,29 @@
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.c
+@@ -4135,6 +4135,7 @@ void brcms_c_wme_setparams(struct brcms_
+ 					  M_EDCF_QINFO +
+ 					  wme_ac2fifo[aci] * M_EDCF_QLEN + i,
+ 					  *shm_entry++);
++		printk("dummy\n");
+ 	}
+ 
+ 	if (suspend) {
+@@ -4537,7 +4538,8 @@ static int brcms_b_attach(struct brcms_c
+ 
+ 	/* check device id(srom, nvram etc.) to set bands */
+ 	if (wlc_hw->deviceid == BCM43224_D11N_ID ||
+-	    wlc_hw->deviceid == BCM43224_D11N_ID_VEN1)
++	    wlc_hw->deviceid == BCM43224_D11N_ID_VEN1 ||
++	    wlc_hw->deviceid == BCM43224_CHIP_ID)
+ 		/* Dualband boards */
+ 		wlc_hw->_nbands = 2;
+ 	else
+@@ -5797,7 +5799,7 @@ static bool brcms_c_chipmatch_pci(struct
+ 		return false;
+ 	}
+ 
+-	if (device == BCM43224_D11N_ID_VEN1)
++	if (device == BCM43224_D11N_ID_VEN1 || device == BCM43224_CHIP_ID)
+ 		return true;
+ 	if ((device == BCM43224_D11N_ID) || (device == BCM43225_D11N2G_ID))
+ 		return true;
Index: package/mac80211/patches/521-ath9k_cur_txpower.patch
===================================================================
--- package/mac80211/patches/521-ath9k_cur_txpower.patch	(revision 31639)
+++ package/mac80211/patches/521-ath9k_cur_txpower.patch	(working copy)
@@ -1,19 +1,19 @@
 --- a/drivers/net/wireless/ath/ath9k/main.c
 +++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1675,6 +1675,8 @@ int ath9k_config(struct ieee80211_hw *hw
+@@ -1251,6 +1251,8 @@ int ath9k_config(struct ieee80211_hw *hw
  			return -EINVAL;
  		}
  
-+		conf->cur_power_level = sc->curtxpow / 2;
++		hw->cur_power_level = sc->curtxpow / 2;
 +
  		/*
  		 * The most recent snapshot of channel->noisefloor for the old
  		 * channel is only available after the hardware reset. Copy it to
-@@ -1689,6 +1691,7 @@ int ath9k_config(struct ieee80211_hw *hw
+@@ -1265,6 +1267,7 @@ int ath9k_config(struct ieee80211_hw *hw
  		sc->config.txpowlimit = 2 * conf->power_level;
  		ath9k_cmn_update_txpow(ah, sc->curtxpow,
  				       sc->config.txpowlimit, &sc->curtxpow);
-+		conf->cur_power_level = sc->curtxpow / 2;
++		hw->cur_power_level = sc->curtxpow / 2;
  	}
  
  	mutex_unlock(&sc->mutex);
Index: package/mac80211/patches/300-pending_work.patch
===================================================================
--- package/mac80211/patches/300-pending_work.patch	(revision 31639)
+++ package/mac80211/patches/300-pending_work.patch	(working copy)
@@ -1,566 +1,35 @@
 --- a/drivers/net/wireless/ath/ath5k/base.c
 +++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -2416,6 +2416,22 @@ ath5k_tx_complete_poll_work(struct work_
- * Initialization routines *
- \*************************/
+@@ -325,6 +325,8 @@ ath5k_setup_channels(struct ath5k_hw *ah
+ 		if (!ath5k_is_standard_channel(ch, band))
+ 			continue;
  
-+static const struct ieee80211_iface_limit if_limits[] = {
-+	{ .max = 2048,	.types = BIT(NL80211_IFTYPE_STATION) },
-+	{ .max = 4,	.types =
-+#ifdef CONFIG_MAC80211_MESH
-+				 BIT(NL80211_IFTYPE_MESH_POINT) |
-+#endif
-+				 BIT(NL80211_IFTYPE_AP) },
-+};
++		channels[count].max_power = AR5K_TUNE_MAX_TXPOWER/2;
 +
-+static const struct ieee80211_iface_combination if_comb = {
-+	.limits = if_limits,
-+	.n_limits = ARRAY_SIZE(if_limits),
-+	.max_interfaces = 2048,
-+	.num_different_channels = 1,
-+};
-+
- int __devinit
- ath5k_init_ah(struct ath5k_hw *ah, const struct ath_bus_ops *bus_ops)
- {
-@@ -2437,6 +2453,9 @@ ath5k_init_ah(struct ath5k_hw *ah, const
- 		BIT(NL80211_IFTYPE_ADHOC) |
- 		BIT(NL80211_IFTYPE_MESH_POINT);
- 
-+	hw->wiphy->iface_combinations = &if_comb;
-+	hw->wiphy->n_iface_combinations = 1;
-+
- 	/* SW support for IBSS_RSN is provided by mac80211 */
- 	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
- 
---- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
-@@ -618,19 +618,10 @@ static void ar5008_hw_init_bb(struct ath
- 	u32 synthDelay;
- 
- 	synthDelay = REG_READ(ah, AR_PHY_RX_DELAY) & AR_PHY_RX_DELAY_DELAY;
--	if (IS_CHAN_B(chan))
--		synthDelay = (4 * synthDelay) / 22;
--	else
--		synthDelay /= 10;
--
--	if (IS_CHAN_HALF_RATE(chan))
--		synthDelay *= 2;
--	else if (IS_CHAN_QUARTER_RATE(chan))
--		synthDelay *= 4;
- 
- 	REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
- 
--	udelay(synthDelay + BASE_ACTIVATE_DELAY);
-+	ath9k_hw_synth_delay(ah, chan, synthDelay);
- }
- 
- static void ar5008_hw_init_chain_masks(struct ath_hw *ah)
-@@ -868,7 +859,7 @@ static int ar5008_hw_process_ini(struct 
- 	ar5008_hw_set_channel_regs(ah, chan);
- 	ar5008_hw_init_chain_masks(ah);
- 	ath9k_olc_init(ah);
--	ath9k_hw_apply_txpower(ah, chan);
-+	ath9k_hw_apply_txpower(ah, chan, false);
- 
- 	/* Write analog registers */
- 	if (!ath9k_hw_set_rf_regs(ah, chan, freqIndex)) {
-@@ -948,12 +939,8 @@ static bool ar5008_hw_rfbus_req(struct a
- static void ar5008_hw_rfbus_done(struct ath_hw *ah)
- {
- 	u32 synthDelay = REG_READ(ah, AR_PHY_RX_DELAY) & AR_PHY_RX_DELAY_DELAY;
--	if (IS_CHAN_B(ah->curchan))
--		synthDelay = (4 * synthDelay) / 22;
--	else
--		synthDelay /= 10;
- 
--	udelay(synthDelay + BASE_ACTIVATE_DELAY);
-+	ath9k_hw_synth_delay(ah, ah->curchan, synthDelay);
- 
- 	REG_WRITE(ah, AR_PHY_RFBUS_REQ, 0);
- }
---- a/drivers/net/wireless/ath/ath9k/ar9003_calib.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
-@@ -1000,10 +1000,12 @@ static bool ar9003_hw_init_cal(struct at
- 	if (mci && IS_CHAN_2GHZ(chan) && run_agc_cal)
- 		ar9003_mci_init_cal_req(ah, &is_reusable);
- 
--	txiqcal_done = ar9003_hw_tx_iq_cal_run(ah);
--	REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);
--	udelay(5);
--	REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
-+	if (!(IS_CHAN_HALF_RATE(chan) || IS_CHAN_QUARTER_RATE(chan))) {
-+		txiqcal_done = ar9003_hw_tx_iq_cal_run(ah);
-+		REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_DIS);
-+		udelay(5);
-+		REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
-+	}
- 
- skip_tx_iqcal:
- 	if (run_agc_cal || !(ah->ah_flags & AH_FASTCC)) {
---- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
-@@ -4281,18 +4281,10 @@ static int ar9003_hw_tx_power_regwrite(s
- #undef POW_SM
- }
- 
--static void ar9003_hw_set_target_power_eeprom(struct ath_hw *ah, u16 freq,
--					      u8 *targetPowerValT2)
-+static void ar9003_hw_get_legacy_target_powers(struct ath_hw *ah, u16 freq,
-+					       u8 *targetPowerValT2,
-+					       bool is2GHz)
- {
--	/* XXX: hard code for now, need to get from eeprom struct */
--	u8 ht40PowerIncForPdadc = 0;
--	bool is2GHz = false;
--	unsigned int i = 0;
--	struct ath_common *common = ath9k_hw_common(ah);
--
--	if (freq < 4000)
--		is2GHz = true;
--
- 	targetPowerValT2[ALL_TARGET_LEGACY_6_24] =
- 	    ar9003_hw_eeprom_get_tgt_pwr(ah, LEGACY_TARGET_RATE_6_24, freq,
- 					 is2GHz);
-@@ -4305,6 +4297,11 @@ static void ar9003_hw_set_target_power_e
- 	targetPowerValT2[ALL_TARGET_LEGACY_54] =
- 	    ar9003_hw_eeprom_get_tgt_pwr(ah, LEGACY_TARGET_RATE_54, freq,
- 					 is2GHz);
-+}
-+
-+static void ar9003_hw_get_cck_target_powers(struct ath_hw *ah, u16 freq,
-+					    u8 *targetPowerValT2)
-+{
- 	targetPowerValT2[ALL_TARGET_LEGACY_1L_5L] =
- 	    ar9003_hw_eeprom_get_cck_tgt_pwr(ah, LEGACY_TARGET_RATE_1L_5L,
- 					     freq);
-@@ -4314,6 +4311,11 @@ static void ar9003_hw_set_target_power_e
- 	    ar9003_hw_eeprom_get_cck_tgt_pwr(ah, LEGACY_TARGET_RATE_11L, freq);
- 	targetPowerValT2[ALL_TARGET_LEGACY_11S] =
- 	    ar9003_hw_eeprom_get_cck_tgt_pwr(ah, LEGACY_TARGET_RATE_11S, freq);
-+}
-+
-+static void ar9003_hw_get_ht20_target_powers(struct ath_hw *ah, u16 freq,
-+					     u8 *targetPowerValT2, bool is2GHz)
-+{
- 	targetPowerValT2[ALL_TARGET_HT20_0_8_16] =
- 	    ar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_0_8_16, freq,
- 					      is2GHz);
-@@ -4356,6 +4358,16 @@ static void ar9003_hw_set_target_power_e
- 	targetPowerValT2[ALL_TARGET_HT20_23] =
- 	    ar9003_hw_eeprom_get_ht20_tgt_pwr(ah, HT_TARGET_RATE_23, freq,
- 					      is2GHz);
-+}
-+
-+static void ar9003_hw_get_ht40_target_powers(struct ath_hw *ah,
-+						   u16 freq,
-+						   u8 *targetPowerValT2,
-+						   bool is2GHz)
-+{
-+	/* XXX: hard code for now, need to get from eeprom struct */
-+	u8 ht40PowerIncForPdadc = 0;
-+
- 	targetPowerValT2[ALL_TARGET_HT40_0_8_16] =
- 	    ar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_0_8_16, freq,
- 					      is2GHz) + ht40PowerIncForPdadc;
-@@ -4399,6 +4411,26 @@ static void ar9003_hw_set_target_power_e
- 	targetPowerValT2[ALL_TARGET_HT40_23] =
- 	    ar9003_hw_eeprom_get_ht40_tgt_pwr(ah, HT_TARGET_RATE_23, freq,
- 					      is2GHz) + ht40PowerIncForPdadc;
-+}
-+
-+static void ar9003_hw_get_target_power_eeprom(struct ath_hw *ah,
-+					      struct ath9k_channel *chan,
-+					      u8 *targetPowerValT2)
-+{
-+	bool is2GHz = IS_CHAN_2GHZ(chan);
-+	unsigned int i = 0;
-+	struct ath_common *common = ath9k_hw_common(ah);
-+	u16 freq = chan->channel;
-+
-+	if (is2GHz)
-+		ar9003_hw_get_cck_target_powers(ah, freq, targetPowerValT2);
-+
-+	ar9003_hw_get_legacy_target_powers(ah, freq, targetPowerValT2, is2GHz);
-+	ar9003_hw_get_ht20_target_powers(ah, freq, targetPowerValT2, is2GHz);
-+
-+	if (IS_CHAN_HT40(chan))
-+		ar9003_hw_get_ht40_target_powers(ah, freq, targetPowerValT2,
-+						 is2GHz);
- 
- 	for (i = 0; i < ar9300RateSize; i++) {
- 		ath_dbg(common, EEPROM, "TPC[%02d] 0x%08x\n",
-@@ -4778,9 +4810,6 @@ static void ar9003_hw_set_power_per_rate
- 	scaledPower = ath9k_hw_get_scaled_power(ah, powerLimit,
- 						antenna_reduction);
- 
--	/*
--	 * Get target powers from EEPROM - our baseline for TX Power
--	 */
- 	if (is2ghz) {
- 		/* Setup for CTL modes */
- 		/* CTL_11B, CTL_11G, CTL_2GHT20 */
-@@ -4952,7 +4981,12 @@ static void ath9k_hw_ar9300_set_txpower(
- 	unsigned int i = 0, paprd_scale_factor = 0;
- 	u8 pwr_idx, min_pwridx = 0;
- 
--	ar9003_hw_set_target_power_eeprom(ah, chan->channel, targetPowerValT2);
-+	memset(targetPowerValT2, 0 , sizeof(targetPowerValT2));
-+
-+	/*
-+	 * Get target powers from EEPROM - our baseline for TX Power
-+	 */
-+	ar9003_hw_get_target_power_eeprom(ah, chan, targetPowerValT2);
- 
- 	if (ah->eep_ops->get_eeprom(ah, EEP_PAPRD)) {
- 		if (IS_CHAN_2GHZ(chan))
---- a/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
-@@ -54,7 +54,7 @@ void ar9003_paprd_enable(struct ath_hw *
- 
- 	if (val) {
- 		ah->paprd_table_write_done = true;
--		ath9k_hw_apply_txpower(ah, chan);
-+		ath9k_hw_apply_txpower(ah, chan, false);
+ 		count++;
  	}
  
- 	REG_RMW_FIELD(ah, AR_PHY_PAPRD_CTRL0_B0,
---- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
-@@ -373,7 +373,7 @@ static void ar9003_hw_spur_ofdm_work(str
- 			else
- 				spur_subchannel_sd = 0;
- 
--			spur_freq_sd = (freq_offset << 9) / 11;
-+			spur_freq_sd = ((freq_offset + 10) << 9) / 11;
- 
- 		} else {
- 			if (REG_READ_FIELD(ah, AR_PHY_GEN_CTRL,
-@@ -382,7 +382,7 @@ static void ar9003_hw_spur_ofdm_work(str
- 			else
- 				spur_subchannel_sd = 1;
- 
--			spur_freq_sd = (freq_offset << 9) / 11;
-+			spur_freq_sd = ((freq_offset - 10) << 9) / 11;
- 
- 		}
- 
-@@ -526,22 +526,10 @@ static void ar9003_hw_init_bb(struct ath
- 	 * Value is in 100ns increments.
- 	 */
- 	synthDelay = REG_READ(ah, AR_PHY_RX_DELAY) & AR_PHY_RX_DELAY_DELAY;
--	if (IS_CHAN_B(chan))
--		synthDelay = (4 * synthDelay) / 22;
--	else
--		synthDelay /= 10;
- 
- 	/* Activate the PHY (includes baseband activate + synthesizer on) */
- 	REG_WRITE(ah, AR_PHY_ACTIVE, AR_PHY_ACTIVE_EN);
--
--	/*
--	 * There is an issue if the AP starts the calibration before
--	 * the base band timeout completes.  This could result in the
--	 * rx_clear false triggering.  As a workaround we add delay an
--	 * extra BASE_ACTIVATE_DELAY usecs to ensure this condition
--	 * does not happen.
--	 */
--	udelay(synthDelay + BASE_ACTIVATE_DELAY);
-+	ath9k_hw_synth_delay(ah, chan, synthDelay);
- }
- 
- static void ar9003_hw_set_chain_masks(struct ath_hw *ah, u8 rx, u8 tx)
-@@ -692,7 +680,7 @@ static int ar9003_hw_process_ini(struct 
- 	ar9003_hw_override_ini(ah);
- 	ar9003_hw_set_channel_regs(ah, chan);
- 	ar9003_hw_set_chain_masks(ah, ah->rxchainmask, ah->txchainmask);
--	ath9k_hw_apply_txpower(ah, chan);
-+	ath9k_hw_apply_txpower(ah, chan, false);
- 
- 	if (AR_SREV_9462(ah)) {
- 		if (REG_READ_FIELD(ah, AR_PHY_TX_IQCAL_CONTROL_0,
-@@ -723,6 +711,14 @@ static void ar9003_hw_set_rfmode(struct 
- 
- 	if (IS_CHAN_A_FAST_CLOCK(ah, chan))
- 		rfMode |= (AR_PHY_MODE_DYNAMIC | AR_PHY_MODE_DYN_CCK_DISABLE);
-+	if (IS_CHAN_QUARTER_RATE(chan))
-+		rfMode |= AR_PHY_MODE_QUARTER;
-+	if (IS_CHAN_HALF_RATE(chan))
-+		rfMode |= AR_PHY_MODE_HALF;
-+
-+	if (rfMode & (AR_PHY_MODE_QUARTER | AR_PHY_MODE_HALF))
-+		REG_RMW_FIELD(ah, AR_PHY_FRAME_CTL,
-+			      AR_PHY_FRAME_CTL_CF_OVERLAP_WINDOW, 3);
- 
- 	REG_WRITE(ah, AR_PHY_MODE, rfMode);
- }
-@@ -793,12 +789,8 @@ static bool ar9003_hw_rfbus_req(struct a
- static void ar9003_hw_rfbus_done(struct ath_hw *ah)
- {
- 	u32 synthDelay = REG_READ(ah, AR_PHY_RX_DELAY) & AR_PHY_RX_DELAY_DELAY;
--	if (IS_CHAN_B(ah->curchan))
--		synthDelay = (4 * synthDelay) / 22;
--	else
--		synthDelay /= 10;
- 
--	udelay(synthDelay + BASE_ACTIVATE_DELAY);
-+	ath9k_hw_synth_delay(ah, ah->curchan, synthDelay);
- 
- 	REG_WRITE(ah, AR_PHY_RFBUS_REQ, 0);
- }
---- a/drivers/net/wireless/ath/ath9k/ar9003_phy.h
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.h
-@@ -468,6 +468,9 @@
- #define AR_PHY_ADDAC_PARA_CTL    (AR_SM_BASE + 0x150)
- #define AR_PHY_XPA_CFG           (AR_SM_BASE + 0x158)
- 
-+#define AR_PHY_FRAME_CTL_CF_OVERLAP_WINDOW  3
-+#define AR_PHY_FRAME_CTL_CF_OVERLAP_WINDOW_S    0
-+
- #define AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_IDX_A           0x0001FC00
- #define AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_IDX_A_S         10
- #define AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A                       0x3FF
---- a/drivers/net/wireless/ath/ath9k/eeprom_9287.c
-+++ b/drivers/net/wireless/ath/ath9k/eeprom_9287.c
-@@ -798,6 +798,8 @@ static void ath9k_hw_ar9287_set_txpower(
- 			regulatory->max_power_level = ratesArray[i];
- 	}
- 
-+	ath9k_hw_update_regulatory_maxpower(ah);
-+
- 	if (test)
+@@ -850,7 +852,7 @@ ath5k_txbuf_free_skb(struct ath5k_hw *ah
  		return;
+ 	dma_unmap_single(ah->dev, bf->skbaddr, bf->skb->len,
+ 			DMA_TO_DEVICE);
+-	dev_kfree_skb_any(bf->skb);
++	ieee80211_free_txskb(ah->hw, bf->skb);
+ 	bf->skb = NULL;
+ 	bf->skbaddr = 0;
+ 	bf->desc->ds_data = 0;
+@@ -1577,7 +1579,7 @@ ath5k_tx_queue(struct ieee80211_hw *hw, 
+ 	return;
  
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -191,6 +191,22 @@ bool ath9k_hw_wait(struct ath_hw *ah, u3
+ drop_packet:
+-	dev_kfree_skb_any(skb);
++	ieee80211_free_txskb(hw, skb);
  }
- EXPORT_SYMBOL(ath9k_hw_wait);
  
-+void ath9k_hw_synth_delay(struct ath_hw *ah, struct ath9k_channel *chan,
-+			  int hw_delay)
-+{
-+	if (IS_CHAN_B(chan))
-+		hw_delay = (4 * hw_delay) / 22;
-+	else
-+		hw_delay /= 10;
-+
-+	if (IS_CHAN_HALF_RATE(chan))
-+		hw_delay *= 2;
-+	else if (IS_CHAN_QUARTER_RATE(chan))
-+		hw_delay *= 4;
-+
-+	udelay(hw_delay + BASE_ACTIVATE_DELAY);
-+}
-+
- void ath9k_hw_write_array(struct ath_hw *ah, struct ar5416IniArray *array,
- 			  int column, unsigned int *writecnt)
- {
-@@ -1020,7 +1036,7 @@ void ath9k_hw_init_global_settings(struc
- 	struct ath_common *common = ath9k_hw_common(ah);
- 	struct ieee80211_conf *conf = &common->hw->conf;
- 	const struct ath9k_channel *chan = ah->curchan;
--	int acktimeout, ctstimeout;
-+	int acktimeout, ctstimeout, ack_offset = 0;
- 	int slottime;
- 	int sifstime;
- 	int rx_lat = 0, tx_lat = 0, eifs = 0;
-@@ -1041,6 +1057,11 @@ void ath9k_hw_init_global_settings(struc
- 		rx_lat = 37;
- 	tx_lat = 54;
- 
-+	if (IS_CHAN_5GHZ(chan))
-+		sifstime = 16;
-+	else
-+		sifstime = 10;
-+
- 	if (IS_CHAN_HALF_RATE(chan)) {
- 		eifs = 175;
- 		rx_lat *= 2;
-@@ -1048,8 +1069,9 @@ void ath9k_hw_init_global_settings(struc
- 		if (IS_CHAN_A_FAST_CLOCK(ah, chan))
- 		    tx_lat += 11;
- 
-+		sifstime *= 2;
-+		ack_offset = 16;
- 		slottime = 13;
--		sifstime = 32;
- 	} else if (IS_CHAN_QUARTER_RATE(chan)) {
- 		eifs = 340;
- 		rx_lat = (rx_lat * 4) - 1;
-@@ -1057,8 +1079,9 @@ void ath9k_hw_init_global_settings(struc
- 		if (IS_CHAN_A_FAST_CLOCK(ah, chan))
- 		    tx_lat += 22;
- 
-+		sifstime *= 4;
-+		ack_offset = 32;
- 		slottime = 21;
--		sifstime = 64;
- 	} else {
- 		if (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah)) {
- 			eifs = AR_D_GBL_IFS_EIFS_ASYNC_FIFO;
-@@ -1072,14 +1095,10 @@ void ath9k_hw_init_global_settings(struc
- 		tx_lat = MS(reg, AR_USEC_TX_LAT);
- 
- 		slottime = ah->slottime;
--		if (IS_CHAN_5GHZ(chan))
--			sifstime = 16;
--		else
--			sifstime = 10;
- 	}
- 
- 	/* As defined by IEEE 802.11-2007 17.3.8.6 */
--	acktimeout = slottime + sifstime + 3 * ah->coverage_class;
-+	acktimeout = slottime + sifstime + 3 * ah->coverage_class + ack_offset;
- 	ctstimeout = acktimeout;
- 
- 	/*
-@@ -1089,7 +1108,8 @@ void ath9k_hw_init_global_settings(struc
- 	 * BA frames in some implementations, but it has been found to fix ACK
- 	 * timeout issues in other cases as well.
- 	 */
--	if (conf->channel && conf->channel->band == IEEE80211_BAND_2GHZ) {
-+	if (conf->channel && conf->channel->band == IEEE80211_BAND_2GHZ &&
-+	    !IS_CHAN_HALF_RATE(chan) && !IS_CHAN_QUARTER_RATE(chan)) {
- 		acktimeout += 64 - sifstime - ah->slottime;
- 		ctstimeout += 48 - sifstime - ah->slottime;
- 	}
-@@ -1469,6 +1489,10 @@ static bool ath9k_hw_channel_change(stru
- 						    CHANNEL_5GHZ));
- 	mode_diff = (chan->chanmode != ah->curchan->chanmode);
- 
-+	if ((ah->curchan->channelFlags | chan->channelFlags) &
-+	    (CHANNEL_HALF | CHANNEL_QUARTER))
-+		return false;
-+
- 	for (qnum = 0; qnum < AR_NUM_QCU; qnum++) {
- 		if (ath9k_hw_numtxpending(ah, qnum)) {
- 			ath_dbg(common, QUEUE,
-@@ -1502,7 +1526,7 @@ static bool ath9k_hw_channel_change(stru
- 		return false;
- 	}
- 	ath9k_hw_set_clockrate(ah);
--	ath9k_hw_apply_txpower(ah, chan);
-+	ath9k_hw_apply_txpower(ah, chan, false);
- 	ath9k_hw_rfbus_done(ah);
- 
- 	if (IS_CHAN_OFDM(chan) || IS_CHAN_HT(chan))
-@@ -2773,7 +2797,8 @@ static int get_antenna_gain(struct ath_h
- 	return ah->eep_ops->get_eeprom(ah, gain_param);
- }
- 
--void ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan)
-+void ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan,
-+			    bool test)
- {
- 	struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
- 	struct ieee80211_channel *channel;
-@@ -2794,7 +2819,7 @@ void ath9k_hw_apply_txpower(struct ath_h
- 
- 	ah->eep_ops->set_txpower(ah, chan,
- 				 ath9k_regd_get_ctl(reg, chan),
--				 ant_reduction, new_pwr, false);
-+				 ant_reduction, new_pwr, test);
- }
- 
- void ath9k_hw_set_txpowerlimit(struct ath_hw *ah, u32 limit, bool test)
-@@ -2807,7 +2832,7 @@ void ath9k_hw_set_txpowerlimit(struct at
- 	if (test)
- 		channel->max_power = MAX_RATE_POWER / 2;
- 
--	ath9k_hw_apply_txpower(ah, chan);
-+	ath9k_hw_apply_txpower(ah, chan, test);
- 
- 	if (test)
- 		channel->max_power = DIV_ROUND_UP(reg->max_power_level, 2);
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -923,6 +923,8 @@ void ath9k_hw_set_gpio(struct ath_hw *ah
- void ath9k_hw_setantenna(struct ath_hw *ah, u32 antenna);
- 
- /* General Operation */
-+void ath9k_hw_synth_delay(struct ath_hw *ah, struct ath9k_channel *chan,
-+			  int hw_delay);
- bool ath9k_hw_wait(struct ath_hw *ah, u32 reg, u32 mask, u32 val, u32 timeout);
- void ath9k_hw_write_array(struct ath_hw *ah, struct ar5416IniArray *array,
- 			  int column, unsigned int *writecnt);
-@@ -982,7 +984,8 @@ void ath9k_hw_name(struct ath_hw *ah, ch
- /* PHY */
- void ath9k_hw_get_delta_slope_vals(struct ath_hw *ah, u32 coef_scaled,
- 				   u32 *coef_mantissa, u32 *coef_exponent);
--void ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan);
-+void ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan,
-+			    bool test);
- 
- /*
-  * Code Specific to AR5008, AR9001 or AR9002,
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -647,6 +647,24 @@ void ath9k_reload_chainmask_settings(str
- 		setup_ht_cap(sc, &sc->sbands[IEEE80211_BAND_5GHZ].ht_cap);
- }
- 
-+static const struct ieee80211_iface_limit if_limits[] = {
-+	{ .max = 2048,	.types = BIT(NL80211_IFTYPE_STATION) |
-+				 BIT(NL80211_IFTYPE_P2P_CLIENT) |
-+				 BIT(NL80211_IFTYPE_WDS) },
-+	{ .max = 8,	.types =
-+#ifdef CONFIG_MAC80211_MESH
-+				 BIT(NL80211_IFTYPE_MESH_POINT) |
-+#endif
-+				 BIT(NL80211_IFTYPE_AP) |
-+				 BIT(NL80211_IFTYPE_P2P_GO) },
-+};
-+
-+static const struct ieee80211_iface_combination if_comb = {
-+	.limits = if_limits,
-+	.n_limits = ARRAY_SIZE(if_limits),
-+	.max_interfaces = 2048,
-+	.num_different_channels = 1,
-+};
- 
- void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
- {
-@@ -676,6 +694,9 @@ void ath9k_set_hw_capab(struct ath_softc
- 		BIT(NL80211_IFTYPE_ADHOC) |
- 		BIT(NL80211_IFTYPE_MESH_POINT);
- 
-+	hw->wiphy->iface_combinations = &if_comb;
-+	hw->wiphy->n_iface_combinations = 1;
-+
- 	if (AR_SREV_5416(sc->sc_ah))
- 		hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
- 
---- a/drivers/net/wireless/ath/ath9k/mac.c
-+++ b/drivers/net/wireless/ath/ath9k/mac.c
-@@ -133,8 +133,16 @@ EXPORT_SYMBOL(ath9k_hw_updatetxtriglevel
- 
- void ath9k_hw_abort_tx_dma(struct ath_hw *ah)
- {
-+	int maxdelay = 1000;
- 	int i, q;
- 
-+	if (ah->curchan) {
-+		if (IS_CHAN_HALF_RATE(ah->curchan))
-+			maxdelay *= 2;
-+		else if (IS_CHAN_QUARTER_RATE(ah->curchan))
-+			maxdelay *= 4;
-+	}
-+
- 	REG_WRITE(ah, AR_Q_TXD, AR_Q_TXD_M);
- 
- 	REG_SET_BIT(ah, AR_PCU_MISC, AR_PCU_FORCE_QUIET_COLL | AR_PCU_CLEAR_VMF);
-@@ -142,7 +150,7 @@ void ath9k_hw_abort_tx_dma(struct ath_hw
- 	REG_SET_BIT(ah, AR_D_GBL_IFS_MISC, AR_D_GBL_IFS_MISC_IGNORE_BACKOFF);
- 
- 	for (q = 0; q < AR_NUM_QCU; q++) {
--		for (i = 0; i < 1000; i++) {
-+		for (i = 0; i < maxdelay; i++) {
- 			if (i)
- 				udelay(5);
- 
+ static void
 --- a/net/mac80211/agg-rx.c
 +++ b/net/mac80211/agg-rx.c
-@@ -200,6 +200,8 @@ static void ieee80211_send_addba_resp(st
+@@ -203,6 +203,8 @@ static void ieee80211_send_addba_resp(st
  		memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
  	else if (sdata->vif.type == NL80211_IFTYPE_ADHOC)
  		memcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);
@@ -581,7 +50,7 @@
  		memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
  	else if (sdata->vif.type == NL80211_IFTYPE_STATION)
  		memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
-@@ -484,6 +485,7 @@ int ieee80211_start_tx_ba_session(struct
+@@ -460,6 +461,7 @@ int ieee80211_start_tx_ba_session(struct
  	    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&
  	    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
  	    sdata->vif.type != NL80211_IFTYPE_AP &&
@@ -589,6 +58,15 @@
  	    sdata->vif.type != NL80211_IFTYPE_ADHOC)
  		return -EINVAL;
  
+@@ -869,7 +871,7 @@ void ieee80211_process_addba_resp(struct
+ 
+ 	} else {
+ 		___ieee80211_stop_tx_ba_session(sta, tid, WLAN_BACK_INITIATOR,
+-						true);
++						false);
+ 	}
+ 
+  out:
 --- a/net/mac80211/debugfs_sta.c
 +++ b/net/mac80211/debugfs_sta.c
 @@ -63,11 +63,11 @@ static ssize_t sta_flags_read(struct fil
@@ -607,15 +85,15 @@
  			    TEST(TDLS_PEER_AUTH), TEST(4ADDR_EVENT),
 --- a/net/mac80211/iface.c
 +++ b/net/mac80211/iface.c
-@@ -282,7 +282,6 @@ static int ieee80211_do_open(struct net_
- {
- 	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+@@ -420,7 +420,6 @@ int ieee80211_do_open(struct wireless_de
+ 	struct ieee80211_sub_if_data *sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
+ 	struct net_device *dev = wdev->netdev;
  	struct ieee80211_local *local = sdata->local;
 -	struct sta_info *sta;
  	u32 changed = 0;
  	int res;
  	u32 hw_reconf_flags = 0;
-@@ -428,28 +427,6 @@ static int ieee80211_do_open(struct net_
+@@ -575,30 +574,8 @@ int ieee80211_do_open(struct wireless_de
  
  	set_bit(SDATA_STATE_RUNNING, &sdata->state);
  
@@ -639,12 +117,24 @@
 -		}
 -
 -		rate_control_rate_init(sta);
+-		netif_carrier_on(dev);
+-	} else if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE) {
++	if (sdata->vif.type == NL80211_IFTYPE_P2P_DEVICE)
+ 		rcu_assign_pointer(local->p2p_sdata, sdata);
 -	}
--
+ 
  	/*
  	 * set_multicast_list will be invoked by the networking core
- 	 * which will check whether any increments here were done in
-@@ -846,6 +823,72 @@ static void ieee80211_if_setup(struct ne
+@@ -849,7 +826,7 @@ static void ieee80211_do_stop(struct iee
+ 			struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ 			if (info->control.vif == &sdata->vif) {
+ 				__skb_unlink(skb, &local->pending[i]);
+-				dev_kfree_skb_irq(skb);
++				ieee80211_free_txskb(&local->hw, skb);
+ 			}
+ 		}
+ 	}
+@@ -997,6 +974,72 @@ static void ieee80211_if_setup(struct ne
  	dev->destructor = free_netdev;
  }
  
@@ -717,7 +207,7 @@
  static void ieee80211_iface_work(struct work_struct *work)
  {
  	struct ieee80211_sub_if_data *sdata =
-@@ -950,6 +993,9 @@ static void ieee80211_iface_work(struct 
+@@ -1101,6 +1144,9 @@ static void ieee80211_iface_work(struct 
  				break;
  			ieee80211_mesh_rx_queued_mgmt(sdata, skb);
  			break;
@@ -729,7 +219,7 @@
  			break;
 --- a/net/mac80211/rx.c
 +++ b/net/mac80211/rx.c
-@@ -2283,6 +2283,7 @@ ieee80211_rx_h_action(struct ieee80211_r
+@@ -2279,6 +2279,7 @@ ieee80211_rx_h_action(struct ieee80211_r
  		    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&
  		    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
  		    sdata->vif.type != NL80211_IFTYPE_AP &&
@@ -737,7 +227,7 @@
  		    sdata->vif.type != NL80211_IFTYPE_ADHOC)
  			break;
  
-@@ -2497,14 +2498,15 @@ ieee80211_rx_h_mgmt(struct ieee80211_rx_
+@@ -2496,14 +2497,15 @@ ieee80211_rx_h_mgmt(struct ieee80211_rx_
  
  	if (!ieee80211_vif_is_mesh(&sdata->vif) &&
  	    sdata->vif.type != NL80211_IFTYPE_ADHOC &&
@@ -755,13 +245,13 @@
  		break;
  	case cpu_to_le16(IEEE80211_STYPE_ASSOC_RESP):
  	case cpu_to_le16(IEEE80211_STYPE_REASSOC_RESP):
-@@ -2838,10 +2840,16 @@ static int prepare_for_handlers(struct i
+@@ -2827,10 +2829,16 @@ static int prepare_for_handlers(struct i
  		}
  		break;
  	case NL80211_IFTYPE_WDS:
 -		if (bssid || !ieee80211_is_data(hdr->frame_control))
 -			return 0;
- 		if (compare_ether_addr(sdata->u.wds.remote_addr, hdr->addr2))
+ 		if (!ether_addr_equal(sdata->u.wds.remote_addr, hdr->addr2))
  			return 0;
 +
 +		if (ieee80211_is_data(hdr->frame_control) ||
@@ -772,8 +262,8 @@
 +			return 0;
 +
  		break;
- 	default:
- 		/* should never get here */
+ 	case NL80211_IFTYPE_P2P_DEVICE:
+ 		if (!ieee80211_is_public_action(hdr, skb->len) &&
 --- a/net/mac80211/sta_info.h
 +++ b/net/mac80211/sta_info.h
 @@ -32,7 +32,6 @@
@@ -792,172 +282,754 @@
  	WLAN_STA_CLEAR_PS_FILT,
  	WLAN_STA_MFP,
  	WLAN_STA_BLOCK_BA,
---- a/drivers/net/wireless/iwlwifi/iwl-agn.h
-+++ b/drivers/net/wireless/iwlwifi/iwl-agn.h
-@@ -425,6 +425,7 @@ void iwl_testmode_cleanup(struct iwl_pri
- #ifdef CONFIG_IWLWIFI_DEBUG
- void iwl_print_rx_config_cmd(struct iwl_priv *priv,
- 			     enum iwl_rxon_context_id ctxid);
-+int iwl_alloc_traffic_mem(struct iwl_priv *priv);
- #else
- static inline void iwl_print_rx_config_cmd(struct iwl_priv *priv,
- 					   enum iwl_rxon_context_id ctxid)
-@@ -510,7 +511,6 @@ void iwl_setup_deferred_work(struct iwl_
- int iwl_send_wimax_coex(struct iwl_priv *priv);
- int iwl_send_bt_env(struct iwl_priv *priv, u8 action, u8 type);
- void iwl_debug_config(struct iwl_priv *priv);
--int iwl_alloc_traffic_mem(struct iwl_priv *priv);
- void iwl_set_hw_params(struct iwl_priv *priv);
- void iwl_init_context(struct iwl_priv *priv, u32 ucode_flags);
- int iwl_init_drv(struct iwl_priv *priv);
---- a/drivers/net/wireless/libertas/firmware.c
-+++ b/drivers/net/wireless/libertas/firmware.c
-@@ -5,6 +5,7 @@
- #include <linux/firmware.h>
- #include <linux/firmware.h>
- #include <linux/module.h>
-+#include <linux/sched.h>
+--- a/net/mac80211/status.c
++++ b/net/mac80211/status.c
+@@ -34,7 +34,7 @@ void ieee80211_tx_status_irqsafe(struct 
+ 		skb_queue_len(&local->skb_queue_unreliable);
+ 	while (tmp > IEEE80211_IRQSAFE_QUEUE_LIMIT &&
+ 	       (skb = skb_dequeue(&local->skb_queue_unreliable))) {
+-		dev_kfree_skb_irq(skb);
++		ieee80211_free_txskb(hw, skb);
+ 		tmp--;
+ 		I802_DEBUG_INC(local->tx_status_drop);
+ 	}
+@@ -159,7 +159,7 @@ static void ieee80211_handle_filtered_fr
+ 			   "dropped TX filtered frame, queue_len=%d PS=%d @%lu\n",
+ 			   skb_queue_len(&sta->tx_filtered[ac]),
+ 			   !!test_sta_flag(sta, WLAN_STA_PS_STA), jiffies);
+-	dev_kfree_skb(skb);
++	ieee80211_free_txskb(&local->hw, skb);
+ }
  
- #include "dev.h"
- #include "decl.h"
---- a/drivers/net/wireless/ath/ath9k/recv.c
-+++ b/drivers/net/wireless/ath/ath9k/recv.c
-@@ -812,6 +812,7 @@ static bool ath9k_rx_accept(struct ath_c
- 	is_valid_tkip = rx_stats->rs_keyix != ATH9K_RXKEYIX_INVALID &&
- 		test_bit(rx_stats->rs_keyix, common->tkip_keymap);
- 	strip_mic = is_valid_tkip && ieee80211_is_data(fc) &&
-+		ieee80211_has_protected(fc) &&
- 		!(rx_stats->rs_status &
- 		(ATH9K_RXERR_DECRYPT | ATH9K_RXERR_CRC | ATH9K_RXERR_MIC |
- 		 ATH9K_RXERR_KEYMISS));
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -1005,6 +1005,9 @@ static int ieee80211_change_station(stru
+ static void ieee80211_check_pending_bar(struct sta_info *sta, u8 *addr, u8 tid)
+@@ -324,6 +324,75 @@ static void ieee80211_add_tx_radiotap_he
+ 
+ }
+ 
++static void ieee80211_report_used_skb(struct ieee80211_local *local,
++				      struct sk_buff *skb, bool dropped)
++{
++	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
++	struct ieee80211_hdr *hdr = (void *)skb->data;
++	bool acked = info->flags & IEEE80211_TX_STAT_ACK;
++
++	if (dropped)
++		acked = false;
++
++	if (info->flags & IEEE80211_TX_INTFL_NL80211_FRAME_TX) {
++		struct ieee80211_sub_if_data *sdata = NULL;
++		struct ieee80211_sub_if_data *iter_sdata;
++		u64 cookie = (unsigned long)skb;
++
++		rcu_read_lock();
++
++		if (skb->dev) {
++			list_for_each_entry_rcu(iter_sdata, &local->interfaces,
++						list) {
++				if (!iter_sdata->dev)
++					continue;
++
++				if (skb->dev == iter_sdata->dev) {
++					sdata = iter_sdata;
++					break;
++				}
++			}
++		} else {
++			sdata = rcu_dereference(local->p2p_sdata);
++		}
++
++		if (!sdata)
++			skb->dev = NULL;
++		else if (ieee80211_is_nullfunc(hdr->frame_control) ||
++			 ieee80211_is_qos_nullfunc(hdr->frame_control)) {
++			cfg80211_probe_status(sdata->dev, hdr->addr1,
++					      cookie, acked, GFP_ATOMIC);
++		} else {
++			cfg80211_mgmt_tx_status(&sdata->wdev, cookie, skb->data,
++						skb->len, acked, GFP_ATOMIC);
++		}
++
++		rcu_read_unlock();
++	}
++
++	if (unlikely(info->ack_frame_id)) {
++		struct sk_buff *ack_skb;
++		unsigned long flags;
++
++		spin_lock_irqsave(&local->ack_status_lock, flags);
++		ack_skb = idr_find(&local->ack_status_frames,
++				   info->ack_frame_id);
++		if (ack_skb)
++			idr_remove(&local->ack_status_frames,
++				   info->ack_frame_id);
++		spin_unlock_irqrestore(&local->ack_status_lock, flags);
++
++		if (ack_skb) {
++			if (!dropped) {
++				/* consumes ack_skb */
++				skb_complete_wifi_ack(ack_skb, acked);
++			} else {
++				dev_kfree_skb_any(ack_skb);
++			}
++		}
++	}
++}
++
+ /*
+  * Use a static threshold for now, best value to be determined
+  * by testing ...
+@@ -515,50 +584,7 @@ void ieee80211_tx_status(struct ieee8021
+ 					msecs_to_jiffies(10));
  	}
  
- 	if (params->vlan && params->vlan != sta->sdata->dev) {
-+		bool prev_4addr = false;
-+		bool new_4addr = false;
+-	if (info->flags & IEEE80211_TX_INTFL_NL80211_FRAME_TX) {
+-		u64 cookie = (unsigned long)skb;
+-		acked = info->flags & IEEE80211_TX_STAT_ACK;
+-
+-		if (ieee80211_is_nullfunc(hdr->frame_control) ||
+-		    ieee80211_is_qos_nullfunc(hdr->frame_control)) {
+-			cfg80211_probe_status(skb->dev, hdr->addr1,
+-					      cookie, acked, GFP_ATOMIC);
+-		} else if (skb->dev) {
+-			cfg80211_mgmt_tx_status(
+-				skb->dev->ieee80211_ptr, cookie, skb->data,
+-				skb->len, acked, GFP_ATOMIC);
+-		} else {
+-			struct ieee80211_sub_if_data *p2p_sdata;
+-
+-			rcu_read_lock();
+-
+-			p2p_sdata = rcu_dereference(local->p2p_sdata);
+-			if (p2p_sdata) {
+-				cfg80211_mgmt_tx_status(
+-					&p2p_sdata->wdev, cookie, skb->data,
+-					skb->len, acked, GFP_ATOMIC);
+-			}
+-			rcu_read_unlock();
+-		}
+-	}
+-
+-	if (unlikely(info->ack_frame_id)) {
+-		struct sk_buff *ack_skb;
+-		unsigned long flags;
+-
+-		spin_lock_irqsave(&local->ack_status_lock, flags);
+-		ack_skb = idr_find(&local->ack_status_frames,
+-				   info->ack_frame_id);
+-		if (ack_skb)
+-			idr_remove(&local->ack_status_frames,
+-				   info->ack_frame_id);
+-		spin_unlock_irqrestore(&local->ack_status_lock, flags);
+-
+-		/* consumes ack_skb */
+-		if (ack_skb)
+-			skb_complete_wifi_ack(ack_skb,
+-				info->flags & IEEE80211_TX_STAT_ACK);
+-	}
++	ieee80211_report_used_skb(local, skb, false);
+ 
+ 	/* this was a transmitted frame, but now we want to reuse it */
+ 	skb_orphan(skb);
+@@ -634,25 +660,17 @@ EXPORT_SYMBOL(ieee80211_report_low_ack);
+ void ieee80211_free_txskb(struct ieee80211_hw *hw, struct sk_buff *skb)
+ {
+ 	struct ieee80211_local *local = hw_to_local(hw);
+-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+-
+-	if (unlikely(info->ack_frame_id)) {
+-		struct sk_buff *ack_skb;
+-		unsigned long flags;
+-
+-		spin_lock_irqsave(&local->ack_status_lock, flags);
+-		ack_skb = idr_find(&local->ack_status_frames,
+-				   info->ack_frame_id);
+-		if (ack_skb)
+-			idr_remove(&local->ack_status_frames,
+-				   info->ack_frame_id);
+-		spin_unlock_irqrestore(&local->ack_status_lock, flags);
+-
+-		/* consumes ack_skb */
+-		if (ack_skb)
+-			dev_kfree_skb_any(ack_skb);
+-	}
+ 
++	ieee80211_report_used_skb(local, skb, true);
+ 	dev_kfree_skb_any(skb);
+ }
+ EXPORT_SYMBOL(ieee80211_free_txskb);
 +
- 		vlansdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);
++void ieee80211_purge_tx_queue(struct ieee80211_hw *hw,
++			      struct sk_buff_head *skbs)
++{
++	struct sk_buff *skb;
++
++	while ((skb = __skb_dequeue(skbs)))
++		ieee80211_free_txskb(hw, skb);
++}
+--- a/drivers/net/wireless/p54/main.c
++++ b/drivers/net/wireless/p54/main.c
+@@ -139,6 +139,7 @@ static int p54_beacon_format_ie_tim(stru
+ static int p54_beacon_update(struct p54_common *priv,
+ 			struct ieee80211_vif *vif)
+ {
++	struct ieee80211_tx_control control = { };
+ 	struct sk_buff *beacon;
+ 	int ret;
  
- 		if (vlansdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
-@@ -1020,9 +1023,25 @@ static int ieee80211_change_station(stru
- 			}
+@@ -158,7 +159,7 @@ static int p54_beacon_update(struct p54_
+ 	 * to cancel the old beacon template by hand, instead the firmware
+ 	 * will release the previous one through the feedback mechanism.
+ 	 */
+-	p54_tx_80211(priv->hw, NULL, beacon);
++	p54_tx_80211(priv->hw, &control, beacon);
+ 	priv->tsf_high32 = 0;
+ 	priv->tsf_low32 = 0;
  
- 			rcu_assign_pointer(vlansdata->u.vlan.sta, sta);
-+			new_4addr = true;
-+		}
+--- a/net/wireless/reg.c
++++ b/net/wireless/reg.c
+@@ -352,6 +352,9 @@ static void reg_regdb_search(struct work
+ 	struct reg_regdb_search_request *request;
+ 	const struct ieee80211_regdomain *curdom, *regdom;
+ 	int i, r;
++	bool set_reg = false;
 +
-+		if (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
-+		    sta->sdata->u.vlan.sta) {
-+			rcu_assign_pointer(sta->sdata->u.vlan.sta, NULL);
-+			prev_4addr = true;
++	mutex_lock(&cfg80211_mutex);
+ 
+ 	mutex_lock(&reg_regdb_search_mutex);
+ 	while (!list_empty(&reg_regdb_search_list)) {
+@@ -367,9 +370,7 @@ static void reg_regdb_search(struct work
+ 				r = reg_copy_regd(&regdom, curdom);
+ 				if (r)
+ 					break;
+-				mutex_lock(&cfg80211_mutex);
+-				set_regdom(regdom);
+-				mutex_unlock(&cfg80211_mutex);
++				set_reg = true;
+ 				break;
+ 			}
  		}
+@@ -377,6 +378,11 @@ static void reg_regdb_search(struct work
+ 		kfree(request);
+ 	}
+ 	mutex_unlock(&reg_regdb_search_mutex);
++
++	if (set_reg)
++		set_regdom(regdom);
++
++	mutex_unlock(&cfg80211_mutex);
+ }
  
- 		sta->sdata = vlansdata;
+ static DECLARE_WORK(reg_regdb_work, reg_regdb_search);
+--- a/drivers/net/wireless/ath/ath9k/recv.c
++++ b/drivers/net/wireless/ath/ath9k/recv.c
+@@ -424,8 +424,8 @@ u32 ath_calcrxfilter(struct ath_softc *s
+ 		rfilt |= ATH9K_RX_FILTER_COMP_BAR;
+ 
+ 	if (sc->nvifs > 1 || (sc->rx.rxfilter & FIF_OTHER_BSS)) {
+-		/* The following may also be needed for other older chips */
+-		if (sc->sc_ah->hw_version.macVersion == AR_SREV_VERSION_9160)
++		/* This is needed for older chips */
++		if (sc->sc_ah->hw_version.macVersion <= AR_SREV_VERSION_9160)
+ 			rfilt |= ATH9K_RX_FILTER_PROM;
+ 		rfilt |= ATH9K_RX_FILTER_MCAST_BCAST_ALL;
+ 	}
+--- a/net/mac80211/mlme.c
++++ b/net/mac80211/mlme.c
+@@ -818,23 +818,71 @@ void ieee80211_sta_process_chanswitch(st
+ }
+ 
+ static void ieee80211_handle_pwr_constr(struct ieee80211_sub_if_data *sdata,
+-					u16 capab_info, u8 *pwr_constr_elem,
+-					u8 pwr_constr_elem_len)
++					struct ieee80211_channel *channel,
++					const u8 *country_ie, u8 country_ie_len,
++					const u8 *pwr_constr_elem)
+ {
+-	struct ieee80211_conf *conf = &sdata->local->hw.conf;
++	struct ieee80211_country_ie_triplet *triplet;
++	int chan = ieee80211_frequency_to_channel(channel->center_freq);
++	int i, chan_pwr, chan_increment, new_ap_level;
++	bool have_chan_pwr = false;
+ 
+-	if (!(capab_info & WLAN_CAPABILITY_SPECTRUM_MGMT))
++	/* Invalid IE */
++	if (country_ie_len % 2 || country_ie_len < IEEE80211_COUNTRY_IE_MIN_LEN)
+ 		return;
+ 
+-	/* Power constraint IE length should be 1 octet */
+-	if (pwr_constr_elem_len != 1)
+-		return;
++	triplet = (void *)(country_ie + 3);
++	country_ie_len -= 3;
+ 
+-	if ((*pwr_constr_elem <= conf->channel->max_reg_power) &&
+-	    (*pwr_constr_elem != sdata->local->power_constr_level)) {
+-		sdata->local->power_constr_level = *pwr_constr_elem;
+-		ieee80211_hw_config(sdata->local, 0);
++	switch (channel->band) {
++	default:
++		WARN_ON_ONCE(1);
++		/* fall through */
++	case IEEE80211_BAND_2GHZ:
++	case IEEE80211_BAND_60GHZ:
++		chan_increment = 1;
++		break;
++	case IEEE80211_BAND_5GHZ:
++		chan_increment = 4;
++		break;
+ 	}
 +
-+		if (sta->sta_state == IEEE80211_STA_AUTHORIZED &&
-+		    prev_4addr != new_4addr) {
-+			if (new_4addr)
-+				atomic_dec(&sta->sdata->bss->num_mcast_sta);
-+			else
-+				atomic_inc(&sta->sdata->bss->num_mcast_sta);
++	/* find channel */
++	while (country_ie_len >= 3) {
++		u8 first_channel = triplet->chans.first_channel;
++
++		if (first_channel >= IEEE80211_COUNTRY_EXTENSION_ID)
++			goto next;
++
++		for (i = 0; i < triplet->chans.num_channels; i++) {
++			if (first_channel + i * chan_increment == chan) {
++				have_chan_pwr = true;
++				chan_pwr = triplet->chans.max_power;
++				break;
++			}
 +		}
++		if (have_chan_pwr)
++			break;
 +
- 		ieee80211_send_layer2_update(sta);
++ next:
++		triplet++;
++		country_ie_len -= 3;
++	}
++
++	if (!have_chan_pwr)
++		return;
++
++	new_ap_level = max_t(int, 0, chan_pwr - *pwr_constr_elem);
++
++	if (sdata->local->ap_power_level == new_ap_level)
++		return;
++
++	sdata_info(sdata,
++		   "Limiting TX power to %d (%d - %d) dBm as advertised by %pM\n",
++		   new_ap_level, chan_pwr, *pwr_constr_elem,
++		   sdata->u.mgd.bssid);
++	sdata->local->ap_power_level = new_ap_level;
++	ieee80211_hw_config(sdata->local, 0);
+ }
+ 
+ void ieee80211_enable_dyn_ps(struct ieee80211_vif *vif)
+@@ -1390,7 +1438,7 @@ static void ieee80211_set_disassoc(struc
+ 	sta = sta_info_get(sdata, ifmgd->bssid);
+ 	if (sta) {
+ 		set_sta_flag(sta, WLAN_STA_BLOCK_BA);
+-		ieee80211_sta_tear_down_BA_sessions(sta, tx);
++		ieee80211_sta_tear_down_BA_sessions(sta, false);
  	}
+ 	mutex_unlock(&local->sta_mtx);
  
---- a/net/mac80211/debugfs_netdev.c
-+++ b/net/mac80211/debugfs_netdev.c
-@@ -394,7 +394,7 @@ static ssize_t ieee80211_if_parse_uapsd_
- __IEEE80211_IF_FILE_W(uapsd_max_sp_len);
+@@ -1438,7 +1486,7 @@ static void ieee80211_set_disassoc(struc
+ 	memset(&ifmgd->ht_capa, 0, sizeof(ifmgd->ht_capa));
+ 	memset(&ifmgd->ht_capa_mask, 0, sizeof(ifmgd->ht_capa_mask));
  
- /* AP attributes */
--IEEE80211_IF_FILE(num_sta_authorized, u.ap.num_sta_authorized, ATOMIC);
-+IEEE80211_IF_FILE(num_mcast_sta, u.ap.num_mcast_sta, ATOMIC);
- IEEE80211_IF_FILE(num_sta_ps, u.ap.num_sta_ps, ATOMIC);
- IEEE80211_IF_FILE(dtim_count, u.ap.dtim_count, DEC);
+-	local->power_constr_level = 0;
++	local->ap_power_level = 0;
  
-@@ -540,7 +540,7 @@ static void add_sta_files(struct ieee802
+ 	del_timer_sync(&local->dynamic_ps_timer);
+ 	cancel_work_sync(&local->dynamic_ps_enable_work);
+@@ -2530,15 +2578,13 @@ static void ieee80211_rx_mgmt_beacon(str
+ 						  bssid, true);
+ 	}
  
- static void add_ap_files(struct ieee80211_sub_if_data *sdata)
+-	/* Note: country IE parsing is done for us by cfg80211 */
+-	if (elems.country_elem) {
+-		/* TODO: IBSS also needs this */
+-		if (elems.pwr_constr_elem)
+-			ieee80211_handle_pwr_constr(sdata,
+-				le16_to_cpu(mgmt->u.probe_resp.capab_info),
+-				elems.pwr_constr_elem,
+-				elems.pwr_constr_elem_len);
+-	}
++	if (elems.country_elem && elems.pwr_constr_elem &&
++	    mgmt->u.probe_resp.capab_info &
++				cpu_to_le16(WLAN_CAPABILITY_SPECTRUM_MGMT))
++		ieee80211_handle_pwr_constr(sdata, local->oper_channel,
++					    elems.country_elem,
++					    elems.country_elem_len,
++					    elems.pwr_constr_elem);
+ 
+ 	ieee80211_bss_info_change_notify(sdata, changed);
+ }
+@@ -3526,6 +3572,7 @@ int ieee80211_mgd_deauth(struct ieee8021
  {
--	DEBUGFS_ADD(num_sta_authorized);
-+	DEBUGFS_ADD(num_mcast_sta);
- 	DEBUGFS_ADD(num_sta_ps);
- 	DEBUGFS_ADD(dtim_count);
- 	DEBUGFS_ADD(num_buffered_multicast);
+ 	struct ieee80211_if_managed *ifmgd = &sdata->u.mgd;
+ 	u8 frame_buf[DEAUTH_DISASSOC_LEN];
++	bool tx = !req->local_state_change;
+ 
+ 	mutex_lock(&ifmgd->mtx);
+ 
+@@ -3542,12 +3589,12 @@ int ieee80211_mgd_deauth(struct ieee8021
+ 	if (ifmgd->associated &&
+ 	    ether_addr_equal(ifmgd->associated->bssid, req->bssid)) {
+ 		ieee80211_set_disassoc(sdata, IEEE80211_STYPE_DEAUTH,
+-				       req->reason_code, true, frame_buf);
++				       req->reason_code, tx, frame_buf);
+ 	} else {
+ 		drv_mgd_prepare_tx(sdata->local, sdata);
+ 		ieee80211_send_deauth_disassoc(sdata, req->bssid,
+ 					       IEEE80211_STYPE_DEAUTH,
+-					       req->reason_code, true,
++					       req->reason_code, tx,
+ 					       frame_buf);
+ 	}
+ 
+--- a/net/mac80211/sta_info.c
++++ b/net/mac80211/sta_info.c
+@@ -585,7 +585,7 @@ static bool sta_info_cleanup_expire_buff
+ 		 */
+ 		if (!skb)
+ 			break;
+-		dev_kfree_skb(skb);
++		ieee80211_free_txskb(&local->hw, skb);
+ 	}
+ 
+ 	/*
+@@ -614,7 +614,7 @@ static bool sta_info_cleanup_expire_buff
+ 		local->total_ps_buffered--;
+ 		ps_dbg(sta->sdata, "Buffered frame expired (STA %pM)\n",
+ 		       sta->sta.addr);
+-		dev_kfree_skb(skb);
++		ieee80211_free_txskb(&local->hw, skb);
+ 	}
+ 
+ 	/*
+@@ -674,7 +674,7 @@ int __must_check __sta_info_destroy(stru
+ 	 * will be sufficient.
+ 	 */
+ 	set_sta_flag(sta, WLAN_STA_BLOCK_BA);
+-	ieee80211_sta_tear_down_BA_sessions(sta, true);
++	ieee80211_sta_tear_down_BA_sessions(sta, false);
+ 
+ 	ret = sta_info_hash_del(local, sta);
+ 	if (ret)
+@@ -730,8 +730,8 @@ int __must_check __sta_info_destroy(stru
+ 
+ 	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
+ 		local->total_ps_buffered -= skb_queue_len(&sta->ps_tx_buf[ac]);
+-		__skb_queue_purge(&sta->ps_tx_buf[ac]);
+-		__skb_queue_purge(&sta->tx_filtered[ac]);
++		ieee80211_purge_tx_queue(&local->hw, &sta->ps_tx_buf[ac]);
++		ieee80211_purge_tx_queue(&local->hw, &sta->tx_filtered[ac]);
+ 	}
+ 
+ #ifdef CONFIG_MAC80211_MESH
+@@ -765,7 +765,7 @@ int __must_check __sta_info_destroy(stru
+ 		tid_tx = rcu_dereference_raw(sta->ampdu_mlme.tid_tx[i]);
+ 		if (!tid_tx)
+ 			continue;
+-		__skb_queue_purge(&tid_tx->pending);
++		ieee80211_purge_tx_queue(&local->hw, &tid_tx->pending);
+ 		kfree(tid_tx);
+ 	}
+ 
+--- a/drivers/net/wireless/ath/ath5k/phy.c
++++ b/drivers/net/wireless/ath/ath5k/phy.c
+@@ -1977,11 +1977,13 @@ ath5k_hw_set_spur_mitigation_filter(stru
+ 			spur_delta_phase = (spur_offset << 18) / 25;
+ 			spur_freq_sigma_delta = (spur_delta_phase >> 10);
+ 			symbol_width = AR5K_SPUR_SYMBOL_WIDTH_BASE_100Hz / 2;
++			break;
+ 		case AR5K_BWMODE_5MHZ:
+ 			/* Both sample_freq and chip_freq are 10MHz (?) */
+ 			spur_delta_phase = (spur_offset << 19) / 25;
+ 			spur_freq_sigma_delta = (spur_delta_phase >> 10);
+ 			symbol_width = AR5K_SPUR_SYMBOL_WIDTH_BASE_100Hz / 4;
++			break;
+ 		default:
+ 			if (channel->band == IEEE80211_BAND_5GHZ) {
+ 				/* Both sample_freq and chip_freq are 40MHz */
 --- a/net/mac80211/ieee80211_i.h
 +++ b/net/mac80211/ieee80211_i.h
-@@ -282,7 +282,7 @@ struct ieee80211_if_ap {
- 	u8 tim[sizeof(unsigned long) * BITS_TO_LONGS(IEEE80211_MAX_AID + 1)];
- 	struct sk_buff_head ps_bc_buf;
- 	atomic_t num_sta_ps; /* number of stations in PS mode */
--	atomic_t num_sta_authorized; /* number of authorized stations */
-+	atomic_t num_mcast_sta; /* number of stations receiving multicast */
- 	int dtim_count;
- 	bool dtim_bc_mc;
+@@ -1062,7 +1062,7 @@ struct ieee80211_local {
+ 	bool disable_dynamic_ps;
+ 
+ 	int user_power_level; /* in dBm */
+-	int power_constr_level; /* in dBm */
++	int ap_power_level; /* in dBm */
+ 
+ 	enum ieee80211_smps_mode smps_mode;
+ 
+@@ -1170,7 +1170,6 @@ struct ieee802_11_elems {
+ 	u8 prep_len;
+ 	u8 perr_len;
+ 	u8 country_elem_len;
+-	u8 pwr_constr_elem_len;
+ 	u8 quiet_elem_len;
+ 	u8 num_of_quiet_elem;	/* can be more the one */
+ 	u8 timeout_int_len;
+@@ -1318,6 +1317,8 @@ netdev_tx_t ieee80211_monitor_start_xmit
+ 					 struct net_device *dev);
+ netdev_tx_t ieee80211_subif_start_xmit(struct sk_buff *skb,
+ 				       struct net_device *dev);
++void ieee80211_purge_tx_queue(struct ieee80211_hw *hw,
++			      struct sk_buff_head *skbs);
+ 
+ /* HT */
+ void ieee80211_apply_htcap_overrides(struct ieee80211_sub_if_data *sdata,
+--- a/net/mac80211/util.c
++++ b/net/mac80211/util.c
+@@ -406,7 +406,7 @@ void ieee80211_add_pending_skb(struct ie
+ 	int queue = info->hw_queue;
+ 
+ 	if (WARN_ON(!info->control.vif)) {
+-		kfree_skb(skb);
++		ieee80211_free_txskb(&local->hw, skb);
+ 		return;
+ 	}
+ 
+@@ -431,7 +431,7 @@ void ieee80211_add_pending_skbs_fn(struc
+ 		struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ 
+ 		if (WARN_ON(!info->control.vif)) {
+-			kfree_skb(skb);
++			ieee80211_free_txskb(&local->hw, skb);
+ 			continue;
+ 		}
+ 
+@@ -792,8 +792,11 @@ u32 ieee802_11_parse_elems_crc(u8 *start
+ 			elems->country_elem_len = elen;
+ 			break;
+ 		case WLAN_EID_PWR_CONSTRAINT:
++			if (elen != 1) {
++				elem_parse_failed = true;
++				break;
++			}
+ 			elems->pwr_constr_elem = pos;
+-			elems->pwr_constr_elem_len = elen;
+ 			break;
+ 		case WLAN_EID_TIMEOUT_INTERVAL:
+ 			elems->timeout_int = pos;
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -154,13 +154,11 @@ int ieee80211_hw_config(struct ieee80211
+ 
+ 	if (test_bit(SCAN_SW_SCANNING, &local->scanning) ||
+ 	    test_bit(SCAN_ONCHANNEL_SCANNING, &local->scanning) ||
+-	    test_bit(SCAN_HW_SCANNING, &local->scanning))
++	    test_bit(SCAN_HW_SCANNING, &local->scanning) ||
++	    !local->ap_power_level)
+ 		power = chan->max_power;
+ 	else
+-		power = local->power_constr_level ?
+-			min(chan->max_power,
+-				(chan->max_reg_power  - local->power_constr_level)) :
+-			chan->max_power;
++		power = min(chan->max_power, local->ap_power_level);
+ 
+ 	if (local->user_power_level >= 0)
+ 		power = min(power, local->user_power_level);
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -1218,6 +1218,7 @@ struct cfg80211_deauth_request {
+ 	const u8 *ie;
+ 	size_t ie_len;
+ 	u16 reason_code;
++	bool local_state_change;
  };
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -1417,15 +1417,19 @@ int sta_info_move_state(struct sta_info 
- 		if (sta->sta_state == IEEE80211_STA_AUTH) {
- 			set_bit(WLAN_STA_ASSOC, &sta->_flags);
- 		} else if (sta->sta_state == IEEE80211_STA_AUTHORIZED) {
--			if (sta->sdata->vif.type == NL80211_IFTYPE_AP)
--				atomic_dec(&sta->sdata->u.ap.num_sta_authorized);
-+			if (sta->sdata->vif.type == NL80211_IFTYPE_AP ||
-+			    (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
-+			     !sta->sdata->u.vlan.sta))
-+				atomic_dec(&sta->sdata->bss->num_mcast_sta);
- 			clear_bit(WLAN_STA_AUTHORIZED, &sta->_flags);
- 		}
+ 
+ /**
+--- a/net/wireless/mlme.c
++++ b/net/wireless/mlme.c
+@@ -457,20 +457,14 @@ int __cfg80211_mlme_deauth(struct cfg802
+ 		.reason_code = reason,
+ 		.ie = ie,
+ 		.ie_len = ie_len,
++		.local_state_change = local_state_change,
+ 	};
+ 
+ 	ASSERT_WDEV_LOCK(wdev);
+ 
+-	if (local_state_change) {
+-		if (wdev->current_bss &&
+-		    ether_addr_equal(wdev->current_bss->pub.bssid, bssid)) {
+-			cfg80211_unhold_bss(wdev->current_bss);
+-			cfg80211_put_bss(&wdev->current_bss->pub);
+-			wdev->current_bss = NULL;
+-		}
+-
++	if (local_state_change && (!wdev->current_bss ||
++	    !ether_addr_equal(wdev->current_bss->pub.bssid, bssid)))
+ 		return 0;
+-	}
+ 
+ 	return rdev->ops->deauth(&rdev->wiphy, dev, &req);
+ }
+--- a/drivers/net/wireless/ath/ath9k/xmit.c
++++ b/drivers/net/wireless/ath/ath9k/xmit.c
+@@ -386,7 +386,7 @@ static void ath_tx_complete_aggr(struct 
+ 	u16 seq_st = 0, acked_cnt = 0, txfail_cnt = 0, seq_first;
+ 	u32 ba[WME_BA_BMP_SIZE >> 5];
+ 	int isaggr, txfail, txpending, sendbar = 0, needreset = 0, nbad = 0;
+-	bool rc_update = true;
++	bool rc_update = true, isba;
+ 	struct ieee80211_tx_rate rates[4];
+ 	struct ath_frame_info *fi;
+ 	int nframes;
+@@ -430,13 +430,17 @@ static void ath_tx_complete_aggr(struct 
+ 	tidno = ieee80211_get_qos_ctl(hdr)[0] & IEEE80211_QOS_CTL_TID_MASK;
+ 	tid = ATH_AN_2_TID(an, tidno);
+ 	seq_first = tid->seq_start;
++	isba = ts->ts_flags & ATH9K_TX_BA;
+ 
+ 	/*
+ 	 * The hardware occasionally sends a tx status for the wrong TID.
+ 	 * In this case, the BA status cannot be considered valid and all
+ 	 * subframes need to be retransmitted
++	 *
++	 * Only BlockAcks have a TID and therefore normal Acks cannot be
++	 * checked
+ 	 */
+-	if (tidno != ts->tid)
++	if (isba && tidno != ts->tid)
+ 		txok = false;
+ 
+ 	isaggr = bf_isaggr(bf);
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -2563,6 +2563,9 @@ static void ieee80211_mgmt_frame_registe
+ 		else
+ 			local->probe_req_reg--;
+ 
++		if (!local->open_count)
++			break;
++
+ 		ieee80211_queue_work(&local->hw, &local->reconfig_filter);
  		break;
- 	case IEEE80211_STA_AUTHORIZED:
- 		if (sta->sta_state == IEEE80211_STA_ASSOC) {
--			if (sta->sdata->vif.type == NL80211_IFTYPE_AP)
--				atomic_inc(&sta->sdata->u.ap.num_sta_authorized);
-+			if (sta->sdata->vif.type == NL80211_IFTYPE_AP ||
-+			    (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&
-+			     !sta->sdata->u.vlan.sta))
-+				atomic_inc(&sta->sdata->bss->num_mcast_sta);
- 			set_bit(WLAN_STA_AUTHORIZED, &sta->_flags);
- 		}
- 		break;
+ 	default:
 --- a/net/mac80211/tx.c
 +++ b/net/mac80211/tx.c
-@@ -306,7 +306,7 @@ ieee80211_tx_h_check_assoc(struct ieee80
+@@ -354,7 +354,7 @@ static void purge_old_ps_buffers(struct 
+ 			total += skb_queue_len(&sta->ps_tx_buf[ac]);
+ 			if (skb) {
+ 				purged++;
+-				dev_kfree_skb(skb);
++				ieee80211_free_txskb(&local->hw, skb);
+ 				break;
+ 			}
  		}
- 	} else if (unlikely(tx->sdata->vif.type == NL80211_IFTYPE_AP &&
- 			    ieee80211_is_data(hdr->frame_control) &&
--			    !atomic_read(&tx->sdata->u.ap.num_sta_authorized))) {
-+			    !atomic_read(&tx->sdata->u.ap.num_mcast_sta))) {
- 		/*
- 		 * No associated STAs - no need to send multicast
- 		 * frames.
-@@ -1159,7 +1159,8 @@ ieee80211_tx_prepare(struct ieee80211_su
- 		tx->sta = rcu_dereference(sdata->u.vlan.sta);
- 		if (!tx->sta && sdata->dev->ieee80211_ptr->use_4addr)
- 			return TX_DROP;
--	} else if (info->flags & IEEE80211_TX_CTL_INJECTED) {
-+	} else if (info->flags & IEEE80211_TX_CTL_INJECTED ||
-+		   tx->sdata->control_port_protocol == tx->skb->protocol) {
- 		tx->sta = sta_info_get_bss(sdata, hdr->addr1);
+@@ -466,7 +466,7 @@ ieee80211_tx_h_unicast_ps_buf(struct iee
+ 			ps_dbg(tx->sdata,
+ 			       "STA %pM TX buffer for AC %d full - dropping oldest frame\n",
+ 			       sta->sta.addr, ac);
+-			dev_kfree_skb(old);
++			ieee80211_free_txskb(&local->hw, old);
+ 		} else
+ 			tx->local->total_ps_buffered++;
+ 
+@@ -1103,7 +1103,7 @@ static bool ieee80211_tx_prep_agg(struct
+ 		spin_unlock(&tx->sta->lock);
+ 
+ 		if (purge_skb)
+-			dev_kfree_skb(purge_skb);
++			ieee80211_free_txskb(&tx->local->hw, purge_skb);
  	}
- 	if (!tx->sta)
---- a/net/wireless/scan.c
-+++ b/net/wireless/scan.c
-@@ -378,7 +378,11 @@ static int cmp_bss_core(struct cfg80211_
- 			       b->len_information_elements);
+ 
+ 	/* reset session timer */
+@@ -1214,7 +1214,7 @@ static bool ieee80211_tx_frags(struct ie
+ #ifdef CONFIG_MAC80211_VERBOSE_DEBUG
+ 		if (WARN_ON_ONCE(q >= local->hw.queues)) {
+ 			__skb_unlink(skb, skbs);
+-			dev_kfree_skb(skb);
++			ieee80211_free_txskb(&local->hw, skb);
+ 			continue;
+ 		}
+ #endif
+@@ -1356,9 +1356,9 @@ static int invoke_tx_handlers(struct iee
+ 	if (unlikely(res == TX_DROP)) {
+ 		I802_DEBUG_INC(tx->local->tx_handlers_drop);
+ 		if (tx->skb)
+-			dev_kfree_skb(tx->skb);
++			ieee80211_free_txskb(&tx->local->hw, tx->skb);
+ 		else
+-			__skb_queue_purge(&tx->skbs);
++			ieee80211_purge_tx_queue(&tx->local->hw, &tx->skbs);
+ 		return -1;
+ 	} else if (unlikely(res == TX_QUEUED)) {
+ 		I802_DEBUG_INC(tx->local->tx_handlers_queued);
+@@ -1393,7 +1393,7 @@ static bool ieee80211_tx(struct ieee8021
+ 	res_prepare = ieee80211_tx_prepare(sdata, &tx, skb);
+ 
+ 	if (unlikely(res_prepare == TX_DROP)) {
+-		dev_kfree_skb(skb);
++		ieee80211_free_txskb(&local->hw, skb);
+ 		goto out;
+ 	} else if (unlikely(res_prepare == TX_QUEUED)) {
+ 		goto out;
+@@ -1465,7 +1465,7 @@ void ieee80211_xmit(struct ieee80211_sub
+ 	headroom = max_t(int, 0, headroom);
+ 
+ 	if (ieee80211_skb_resize(sdata, skb, headroom, may_encrypt)) {
+-		dev_kfree_skb(skb);
++		ieee80211_free_txskb(&local->hw, skb);
+ 		rcu_read_unlock();
+ 		return;
  	}
+@@ -2056,8 +2056,10 @@ netdev_tx_t ieee80211_subif_start_xmit(s
+ 		head_need += IEEE80211_ENCRYPT_HEADROOM;
+ 		head_need += local->tx_headroom;
+ 		head_need = max_t(int, 0, head_need);
+-		if (ieee80211_skb_resize(sdata, skb, head_need, true))
+-			goto fail;
++		if (ieee80211_skb_resize(sdata, skb, head_need, true)) {
++			ieee80211_free_txskb(&local->hw, skb);
++			return NETDEV_TX_OK;
++		}
+ 	}
  
--	return compare_ether_addr(a->bssid, b->bssid);
-+	/*
-+	 * we can't use compare_ether_addr here since we need a < > operator.
-+	 * The binary return value of compare_ether_addr isn't enough
-+	 */
-+	return memcmp(a->bssid, b->bssid, sizeof(a->bssid));
+ 	if (encaps_data) {
+@@ -2124,10 +2126,13 @@ netdev_tx_t ieee80211_subif_start_xmit(s
+  */
+ void ieee80211_clear_tx_pending(struct ieee80211_local *local)
+ {
++	struct sk_buff *skb;
+ 	int i;
+ 
+-	for (i = 0; i < local->hw.queues; i++)
+-		skb_queue_purge(&local->pending[i]);
++	for (i = 0; i < local->hw.queues; i++) {
++		while ((skb = skb_dequeue(&local->pending[i])) != NULL)
++			ieee80211_free_txskb(&local->hw, skb);
++	}
  }
  
- static int cmp_bss(struct cfg80211_bss *a,
+ /*
+@@ -2190,7 +2195,7 @@ void ieee80211_tx_pending(unsigned long 
+ 			struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+ 
+ 			if (WARN_ON(!info->control.vif)) {
+-				kfree_skb(skb);
++				ieee80211_free_txskb(&local->hw, skb);
+ 				continue;
+ 			}
+ 
+--- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
++++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
+@@ -65,7 +65,7 @@ ath5k_tx(struct ieee80211_hw *hw, struct
+ 	u16 qnum = skb_get_queue_mapping(skb);
+ 
+ 	if (WARN_ON(qnum >= ah->ah_capabilities.cap_queues.q_tx_num)) {
+-		dev_kfree_skb_any(skb);
++		ieee80211_free_txskb(hw, skb);
+ 		return;
+ 	}
+ 
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -2568,7 +2568,7 @@ int ath9k_hw_fill_cap_info(struct ath_hw
+ 
+ 	if (AR_SREV_9300_20_OR_LATER(ah)) {
+ 		ah->enabled_cals |= TX_IQ_CAL;
+-		if (AR_SREV_9485_OR_LATER(ah))
++		if (AR_SREV_9485_OR_LATER(ah) && !AR_SREV_9340(ah))
+ 			ah->enabled_cals |= TX_IQ_ON_AGC_CAL;
+ 	}
+ 
Index: package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch
===================================================================
--- package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch	(revision 31639)
+++ package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/mwl8k.c
 +++ b/drivers/net/wireless/mwl8k.c
-@@ -5296,6 +5296,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
+@@ -5302,6 +5302,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
  MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
  
  static DEFINE_PCI_DEVICE_TABLE(mwl8k_pci_id_table) = {
Index: package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch
===================================================================
--- package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch	(revision 31639)
+++ package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch	(working copy)
@@ -8,7 +8,7 @@
  #include <asm/unaligned.h>
  
  #include "hw.h"
-@@ -531,8 +532,16 @@ static int ath9k_hw_init_macaddr(struct 
+@@ -523,8 +524,16 @@ static int ath9k_hw_init_macaddr(struct 
  		common->macaddr[2 * i] = eeval >> 8;
  		common->macaddr[2 * i + 1] = eeval & 0xff;
  	}
Index: package/mac80211/patches/540-ath9k_extra_leds.patch
===================================================================
--- package/mac80211/patches/540-ath9k_extra_leds.patch	(revision 31639)
+++ package/mac80211/patches/540-ath9k_extra_leds.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -507,6 +507,9 @@ static inline u16 ath9k_btcoex_aggr_limi
+@@ -538,6 +538,9 @@ struct ath9k_wow_pattern {
  #ifdef CONFIG_MAC80211_LEDS
  void ath_init_leds(struct ath_softc *sc);
  void ath_deinit_leds(struct ath_softc *sc);
@@ -10,7 +10,7 @@
  #else
  static inline void ath_init_leds(struct ath_softc *sc)
  {
-@@ -620,6 +623,13 @@ struct ath9k_vif_iter_data {
+@@ -655,6 +658,13 @@ struct ath9k_vif_iter_data {
  	int nadhocs;   /* number of adhoc vifs */
  };
  
@@ -24,7 +24,7 @@
  struct ath_softc {
  	struct ieee80211_hw *hw;
  	struct device *dev;
-@@ -661,9 +671,8 @@ struct ath_softc {
+@@ -696,9 +706,8 @@ struct ath_softc {
  	struct ieee80211_supported_band sbands[IEEE80211_NUM_BANDS];
  
  #ifdef CONFIG_MAC80211_LEDS
@@ -171,7 +171,7 @@
  
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -781,7 +781,7 @@ int ath9k_init_device(u16 devid, struct 
+@@ -811,7 +811,7 @@ int ath9k_init_device(u16 devid, struct 
  
  #ifdef CONFIG_MAC80211_LEDS
  	/* must be initialized before ieee80211_register_hw */
@@ -244,7 +244,7 @@
  #ifdef CONFIG_ATH9K_MAC_DEBUG
  
  void ath9k_debug_samp_bb_mac(struct ath_softc *sc)
-@@ -1684,6 +1739,11 @@ int ath9k_init_debug(struct ath_hw *ah)
+@@ -1688,6 +1743,11 @@ int ath9k_init_debug(struct ath_hw *ah)
  			    &fops_samps);
  #endif
  
Index: package/mac80211/patches/810-b43_no_pio.patch
===================================================================
--- package/mac80211/patches/810-b43_no_pio.patch	(revision 31639)
+++ package/mac80211/patches/810-b43_no_pio.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/b43/Makefile
 +++ b/drivers/net/wireless/b43/Makefile
-@@ -19,7 +19,7 @@ b43-y				+= xmit.o
+@@ -20,7 +20,7 @@ b43-y				+= xmit.o
  b43-y				+= lo.o
  b43-y				+= wa.o
  b43-y				+= dma.o
Index: package/mac80211/patches/400-ath_move_debug_code.patch
===================================================================
--- package/mac80211/patches/400-ath_move_debug_code.patch	(revision 31639)
+++ package/mac80211/patches/400-ath_move_debug_code.patch	(working copy)
@@ -12,7 +12,7 @@
  ccflags-y += -D__CHECK_ENDIAN__
 --- a/drivers/net/wireless/ath/ath.h
 +++ b/drivers/net/wireless/ath/ath.h
-@@ -277,13 +277,6 @@ void _ath_dbg(struct ath_common *common,
+@@ -280,13 +280,6 @@ void _ath_dbg(struct ath_common *common,
  #endif /* CONFIG_ATH_DEBUG */
  
  /** Returns string describing opmode, or NULL if unknown mode. */
Index: package/mac80211/patches/601-rt2x00-set_pci_mwi.patch
===================================================================
--- package/mac80211/patches/601-rt2x00-set_pci_mwi.patch	(revision 31639)
+++ package/mac80211/patches/601-rt2x00-set_pci_mwi.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/rt2x00/rt2x00pci.c
 +++ b/drivers/net/wireless/rt2x00/rt2x00pci.c
-@@ -272,8 +272,10 @@ int rt2x00pci_probe(struct pci_dev *pci_
+@@ -273,8 +273,10 @@ int rt2x00pci_probe(struct pci_dev *pci_
  
  	pci_set_master(pci_dev);
  
Index: package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch
===================================================================
--- package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch	(revision 31639)
+++ package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch	(working copy)
@@ -164,7 +164,7 @@
  	select RT2X00_LIB_CRYPTO
  	select CRC_CCITT
  	select EEPROM_93CX6
-@@ -204,6 +205,9 @@ config RT2X00_LIB_FIRMWARE
+@@ -212,6 +213,9 @@ config RT2X00_LIB_FIRMWARE
  config RT2X00_LIB_CRYPTO
  	boolean
  
@@ -186,7 +186,7 @@
  obj-$(CONFIG_RT2X00_LIB_PCI)		+= rt2x00pci.o
 --- a/drivers/net/wireless/rt2x00/rt2800pci.c
 +++ b/drivers/net/wireless/rt2x00/rt2800pci.c
-@@ -84,20 +84,10 @@ static void rt2800pci_mcu_status(struct 
+@@ -89,20 +89,10 @@ static void rt2800pci_mcu_status(struct 
  	rt2x00pci_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);
  }
  
@@ -208,7 +208,7 @@
  
  #ifdef CONFIG_PCI
  static void rt2800pci_eepromregister_read(struct eeprom_93cx6 *eeprom)
-@@ -311,6 +301,20 @@ static int rt2800pci_write_firmware(stru
+@@ -322,6 +312,20 @@ static int rt2800pci_write_firmware(stru
  }
  
  /*
@@ -229,7 +229,7 @@
   * Initialization functions.
   */
  static bool rt2800pci_get_entry_state(struct queue_entry *entry)
-@@ -1082,6 +1086,7 @@ static const struct rt2x00lib_ops rt2800
+@@ -1033,6 +1037,7 @@ static const struct rt2x00lib_ops rt2800
  	.get_firmware_name	= rt2800pci_get_firmware_name,
  	.check_firmware		= rt2800_check_firmware,
  	.load_firmware		= rt2800_load_firmware,
@@ -239,10 +239,10 @@
  	.get_entry_state	= rt2800pci_get_entry_state,
 --- a/drivers/net/wireless/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
-@@ -1161,6 +1161,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
- 		    BIT(NL80211_IFTYPE_MESH_POINT) |
- 		    BIT(NL80211_IFTYPE_WDS);
+@@ -1163,6 +1163,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
  
+ 	rt2x00dev->hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
+ 
 +	retval = rt2x00lib_load_eeprom_file(rt2x00dev);
 +	if (retval)
 +		goto exit;
@@ -250,7 +250,7 @@
  	/*
  	 * Initialize work.
  	 */
-@@ -1285,6 +1289,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
+@@ -1287,6 +1291,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
  	 */
  	if (rt2x00dev->drv_data)
  		kfree(rt2x00dev->drv_data);
Index: package/mac80211/patches/512-ath9k_channelbw_debugfs.patch
===================================================================
--- package/mac80211/patches/512-ath9k_channelbw_debugfs.patch	(revision 31639)
+++ package/mac80211/patches/512-ath9k_channelbw_debugfs.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/ath9k.h
 +++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -620,6 +620,7 @@ struct ath_softc {
+@@ -659,6 +659,7 @@ struct ath_softc {
  	struct ieee80211_hw *hw;
  	struct device *dev;
  
@@ -8,8 +8,8 @@
  	struct survey_info *cur_survey;
  	struct survey_info survey[ATH9K_NUM_CHANNELS];
  
-@@ -687,6 +688,7 @@ struct ath_softc {
- 	struct dfs_pattern_detector *dfs_detector;
+@@ -734,6 +735,7 @@ struct ath_softc {
+ #endif
  };
  
 +int ath9k_config(struct ieee80211_hw *hw, u32 changed);
@@ -51,7 +51,7 @@
 +		return -EINVAL;
 +
 +	sc->chan_bw = chan_bw;
-+	if (!(sc->sc_flags & SC_OP_INVALID))
++	if (!test_bit(SC_OP_INVALID, &sc->sc_flags))
 +		ath9k_config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
 +
 +	return count;
@@ -69,7 +69,7 @@
  int ath9k_init_debug(struct ath_hw *ah)
  {
  	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1645,5 +1689,8 @@ int ath9k_init_debug(struct ath_hw *ah)
+@@ -1653,5 +1697,8 @@ int ath9k_init_debug(struct ath_hw *ah)
  	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
  			    &fops_eeprom);
  
@@ -80,8 +80,8 @@
  }
 --- a/drivers/net/wireless/ath/ath9k/main.c
 +++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1550,7 +1550,7 @@ static void ath9k_disable_ps(struct ath_
- 
+@@ -1127,7 +1127,7 @@ static void ath9k_disable_ps(struct ath_
+ 	ath_dbg(common, PS, "PowerSave disabled\n");
  }
  
 -static int ath9k_config(struct ieee80211_hw *hw, u32 changed)
@@ -89,7 +89,7 @@
  {
  	struct ath_softc *sc = hw->priv;
  	struct ath_hw *ah = sc->sc_ah;
-@@ -1601,9 +1601,11 @@ static int ath9k_config(struct ieee80211
+@@ -1181,9 +1181,11 @@ static int ath9k_config(struct ieee80211
  
  	if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) || reset_channel) {
  		struct ieee80211_channel *curchan = hw->conf.channel;
@@ -101,7 +101,7 @@
  
  		if (ah->curchan)
  			old_pos = ah->curchan - &ah->channels[0];
-@@ -1651,7 +1653,23 @@ static int ath9k_config(struct ieee80211
+@@ -1226,7 +1228,23 @@ static int ath9k_config(struct ieee80211
  			memset(&sc->survey[pos], 0, sizeof(struct survey_info));
  		}
  
@@ -125,4 +125,4 @@
 +		if (ath_set_channel(sc, hw, hchan) < 0) {
  			ath_err(common, "Unable to set channel\n");
  			mutex_unlock(&sc->mutex);
- 			return -EINVAL;
+ 			ath9k_ps_restore(sc);
Index: package/mac80211/patches/002-disable_rfkill.patch
===================================================================
--- package/mac80211/patches/002-disable_rfkill.patch	(revision 31639)
+++ package/mac80211/patches/002-disable_rfkill.patch	(working copy)
@@ -1,15 +1,15 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -77,7 +77,7 @@ endif # build check
+@@ -78,7 +78,7 @@ endif # build check
  endif # kernel Makefile check
  
- # These both are needed by compat-wireless || compat-bluetooth so enable them
+ # These both are needed by 802.11 and bluetooth so enable
 - export CONFIG_COMPAT_RFKILL=y
 +# export CONFIG_COMPAT_RFKILL=y
  
  ifeq ($(CONFIG_MAC80211),y)
  $(error "ERROR: you have MAC80211 compiled into the kernel, CONFIG_MAC80211=y, as such you cannot replace its mac80211 driver. You need this set to CONFIG_MAC80211=m. If you are using Fedora upgrade your kernel as later version should this set as modular. For further information on Fedora see https://bugzilla.redhat.com/show_bug.cgi?id=470143. If you are using your own kernel recompile it and make mac80211 modular")
-@@ -668,10 +668,10 @@ endif #CONFIG_COMPAT_KERNEL_2_6_27
+@@ -690,10 +690,10 @@ endif #CONFIG_COMPAT_KERNEL_2_6_27
  # We need the backported rfkill module on kernel < 2.6.31.
  # In more recent kernel versions use the in kernel rfkill module.
  ifdef CONFIG_COMPAT_KERNEL_2_6_31
Index: package/mac80211/patches/565-ath9k_disable_paprd.patch
===================================================================
--- package/mac80211/patches/565-ath9k_disable_paprd.patch	(revision 0)
+++ package/mac80211/patches/565-ath9k_disable_paprd.patch	(revision 0)
@@ -0,0 +1,72 @@
+--- a/drivers/net/wireless/ath/ath9k/debug.c
++++ b/drivers/net/wireless/ath/ath9k/debug.c
+@@ -1767,6 +1767,8 @@ int ath9k_init_debug(struct ath_hw *ah)
+ 			    sc->debug.debugfs_phy, sc, &fops_tx_chainmask);
+ 	debugfs_create_file("disable_ani", S_IRUSR | S_IWUSR,
+ 			    sc->debug.debugfs_phy, sc, &fops_disable_ani);
++	debugfs_create_bool("paprd", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
++			    &sc->sc_ah->config.enable_paprd);
+ 	debugfs_create_file("regidx", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+ 			    sc, &fops_regidx);
+ 	debugfs_create_file("regval", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -2521,10 +2521,6 @@ int ath9k_hw_fill_cap_info(struct ath_hw
+ 		pCap->rx_status_len = sizeof(struct ar9003_rxs);
+ 		pCap->tx_desc_len = sizeof(struct ar9003_txc);
+ 		pCap->txs_len = sizeof(struct ar9003_txs);
+-		if (!ah->config.paprd_disable &&
+-		    ah->eep_ops->get_eeprom(ah, EEP_PAPRD) &&
+-		    !AR_SREV_9462(ah))
+-			pCap->hw_caps |= ATH9K_HW_CAP_PAPRD;
+ 	} else {
+ 		pCap->tx_desc_len = sizeof(struct ath_desc);
+ 		if (AR_SREV_9280_20(ah))
+--- a/drivers/net/wireless/ath/ath9k/hw.h
++++ b/drivers/net/wireless/ath/ath9k/hw.h
+@@ -236,7 +236,6 @@ enum ath9k_hw_caps {
+ 	ATH9K_HW_CAP_LDPC			= BIT(6),
+ 	ATH9K_HW_CAP_FASTCLOCK			= BIT(7),
+ 	ATH9K_HW_CAP_SGI_20			= BIT(8),
+-	ATH9K_HW_CAP_PAPRD			= BIT(9),
+ 	ATH9K_HW_CAP_ANT_DIV_COMB		= BIT(10),
+ 	ATH9K_HW_CAP_2GHZ			= BIT(11),
+ 	ATH9K_HW_CAP_5GHZ			= BIT(12),
+@@ -287,12 +286,12 @@ struct ath9k_ops_config {
+ 	u8 pcie_clock_req;
+ 	u32 pcie_waen;
+ 	u8 analog_shiftreg;
+-	u8 paprd_disable;
+ 	u32 ofdm_trig_low;
+ 	u32 ofdm_trig_high;
+ 	u32 cck_trig_high;
+ 	u32 cck_trig_low;
+ 	u32 enable_ani;
++	u32 enable_paprd;
+ 	int serialize_regmode;
+ 	bool rx_intr_mitigation;
+ 	bool tx_intr_mitigation;
+--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+@@ -2982,6 +2982,10 @@ static u32 ath9k_hw_ar9300_get_eeprom(st
+ 	case EEP_RX_MASK:
+ 		return pBase->txrxMask & 0xf;
+ 	case EEP_PAPRD:
++		if (AR_SREV_9462(ah))
++			return false;
++		if (!ah->config.enable_paprd);
++			return false;
+ 		return !!(pBase->featureEnable & BIT(5));
+ 	case EEP_CHAIN_MASK_REDUCE:
+ 		return (pBase->miscConfiguration >> 0x3) & 0x1;
+--- a/drivers/net/wireless/ath/ath9k/link.c
++++ b/drivers/net/wireless/ath/ath9k/link.c
+@@ -423,7 +423,7 @@ set_timer:
+ 		cal_interval = min(cal_interval, (u32)short_cal_interval);
+ 
+ 	mod_timer(&common->ani.timer, jiffies + msecs_to_jiffies(cal_interval));
+-	if ((sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_PAPRD) && ah->caldata) {
++	if (ah->eep_ops->get_eeprom(ah, EEP_PAPRD) && ah->caldata) {
+ 		if (!ah->caldata->paprd_done)
+ 			ieee80211_queue_work(sc->hw, &sc->paprd_work);
+ 		else if (!ah->paprd_table_write_done)
Index: package/mac80211/patches/513-mac80211_reduce_txqueuelen.patch
===================================================================
--- package/mac80211/patches/513-mac80211_reduce_txqueuelen.patch	(revision 31639)
+++ package/mac80211/patches/513-mac80211_reduce_txqueuelen.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/net/mac80211/iface.c
 +++ b/net/mac80211/iface.c
-@@ -813,6 +813,7 @@ static const struct net_device_ops ieee8
+@@ -964,6 +964,7 @@ static const struct net_device_ops ieee8
  static void ieee80211_if_setup(struct net_device *dev)
  {
  	ether_setup(dev);
Index: package/mac80211/patches/623-rt2x00-rf_vals-rt3352-xtal20.patch
===================================================================
--- package/mac80211/patches/623-rt2x00-rf_vals-rt3352-xtal20.patch	(revision 0)
+++ package/mac80211/patches/623-rt2x00-rf_vals-rt3352-xtal20.patch	(revision 0)
@@ -0,0 +1,121 @@
+Index: compat-wireless-2012-09-07/drivers/net/wireless/rt2x00/rt2800lib.c
+===================================================================
+--- compat-wireless-2012-09-07.orig/drivers/net/wireless/rt2x00/rt2800lib.c
++++ compat-wireless-2012-09-07/drivers/net/wireless/rt2x00/rt2800lib.c
+@@ -5072,6 +5072,27 @@ static const struct rf_channel rf_vals_3
+ 	{173, 0x61, 0, 9},
+ };
+ 
++/*
++ * RF value list for rt3xxx with Xtal20MHz
++ * Supports: 2.4 GHz (all) (RF3322)
++ */
++static const struct rf_channel rf_vals_xtal20mhz_3x[] = {
++	{1,    0xE2,	 2,  0x14},
++	{2,    0xE3,	 2,  0x14},
++	{3,    0xE4,	 2,  0x14},
++	{4,    0xE5,	 2,  0x14},
++	{5,    0xE6,	 2,  0x14},
++	{6,    0xE7,	 2,  0x14},
++	{7,    0xE8,	 2,  0x14},
++	{8,    0xE9,	 2,  0x14},
++	{9,    0xEA,	 2,  0x14},
++	{10,   0xEB,	 2,  0x14},
++	{11,   0xEC,	 2,  0x14},
++	{12,   0xED,	 2,  0x14},
++	{13,   0xEE,	 2,  0x14},
++	{14,   0xF0,	 2,  0x18},
++};
++
+ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
+ {
+ 	struct hw_mode_spec *spec = &rt2x00dev->spec;
+@@ -5149,7 +5170,6 @@ static int rt2800_probe_hw_mode(struct r
+ 		   rt2x00_rf(rt2x00dev, RF3022) ||
+ 		   rt2x00_rf(rt2x00dev, RF3290) ||
+ 		   rt2x00_rf(rt2x00dev, RF3320) ||
+-		   rt2x00_rf(rt2x00dev, RF3322) ||
+ 		   rt2x00_rf(rt2x00dev, RF5360) ||
+ 		   rt2x00_rf(rt2x00dev, RF5370) ||
+ 		   rt2x00_rf(rt2x00dev, RF5372) ||
+@@ -5157,6 +5177,12 @@ static int rt2800_probe_hw_mode(struct r
+ 		   rt2x00_rf(rt2x00dev, RF5392)) {
+ 		spec->num_channels = 14;
+ 		spec->channels = rf_vals_3x;
++	} else if (rt2x00_rf(rt2x00dev, RF3322)) {
++		spec->num_channels = 14;
++		if (spec->clk_is_20mhz)
++			spec->channels = rf_vals_xtal20mhz_3x;
++		else
++			spec->channels = rf_vals_3x;
+ 	} else if (rt2x00_rf(rt2x00dev, RF3052)) {
+ 		spec->supported_bands |= SUPPORT_BAND_5GHZ;
+ 		spec->num_channels = ARRAY_SIZE(rf_vals_3x);
+@@ -5250,6 +5276,19 @@ static int rt2800_probe_hw_mode(struct r
+ 	return 0;
+ }
+ 
++int rt2800_probe_clk(struct rt2x00_dev *rt2x00dev)
++{
++	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
++	struct hw_mode_spec *spec = &rt2x00dev->spec;
++
++	if (!pdata)
++		return -EINVAL;
++
++	spec->clk_is_20mhz = pdata->clk_is_20mhz;
++
++	return 0;
++}
++
+ int rt2800_probe_hw(struct rt2x00_dev *rt2x00dev)
+ {
+ 	int retval;
+@@ -5275,6 +5314,15 @@ int rt2800_probe_hw(struct rt2x00_dev *r
+ 	rt2800_register_write(rt2x00dev, GPIO_CTRL, reg);
+ 
+ 	/*
++	 * Probe SoC clock.
++	 */
++	if (rt2x00_is_soc(rt2x00dev)) {
++		retval = rt2800_probe_clk(rt2x00dev);
++		if (retval)
++			return retval;
++	}
++
++	/*
+ 	 * Initialize hw specifications.
+ 	 */
+ 	retval = rt2800_probe_hw_mode(rt2x00dev);
+Index: compat-wireless-2012-09-07/drivers/net/wireless/rt2x00/rt2x00.h
+===================================================================
+--- compat-wireless-2012-09-07.orig/drivers/net/wireless/rt2x00/rt2x00.h
++++ compat-wireless-2012-09-07/drivers/net/wireless/rt2x00/rt2x00.h
+@@ -421,6 +421,7 @@ static inline struct rt2x00_intf* vif_to
+  * @channels: Device/chipset specific channel values (See &struct rf_channel).
+  * @channels_info: Additional information for channels (See &struct channel_info).
+  * @ht: Driver HT Capabilities (See &ieee80211_sta_ht_cap).
++ * @clk_is_20mhz: External crystal of WiSoC is 20MHz instead of 40MHz
+  */
+ struct hw_mode_spec {
+ 	unsigned int supported_bands;
+@@ -437,6 +438,7 @@ struct hw_mode_spec {
+ 	const struct channel_info *channels_info;
+ 
+ 	struct ieee80211_sta_ht_cap ht;
++	int clk_is_20mhz;
+ };
+ 
+ /*
+Index: compat-wireless-2012-09-07/include/linux/rt2x00_platform.h
+===================================================================
+--- compat-wireless-2012-09-07.orig/include/linux/rt2x00_platform.h
++++ compat-wireless-2012-09-07/include/linux/rt2x00_platform.h
+@@ -18,6 +18,7 @@ struct rt2x00_platform_data {
+ 
+ 	int disable_2ghz;
+ 	int disable_5ghz;
++	int clk_is_20mhz;
+ };
+ 
+ #endif /* _RT2X00_PLATFORM_H */
Index: package/mac80211/patches/013-disable_b43_nphy.patch
===================================================================
--- package/mac80211/patches/013-disable_b43_nphy.patch	(revision 31639)
+++ package/mac80211/patches/013-disable_b43_nphy.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -295,8 +295,8 @@ ifdef CONFIG_MAC80211_LEDS
+@@ -310,8 +310,8 @@ ifdef CONFIG_MAC80211_LEDS
  export CONFIG_B43_LEDS=y
  endif #CONFIG_MAC80211_LEDS
  export CONFIG_B43_PHY_LP=y
Index: package/mac80211/patches/561-ath9k_revert_initval_change.patch
===================================================================
--- package/mac80211/patches/561-ath9k_revert_initval_change.patch	(revision 0)
+++ package/mac80211/patches/561-ath9k_revert_initval_change.patch	(revision 0)
@@ -0,0 +1,19 @@
+--- a/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
+@@ -778,11 +778,11 @@ static const u32 ar9300Common_rx_gain_ta
+ 	{0x0000a074, 0x00000000},
+ 	{0x0000a078, 0x00000000},
+ 	{0x0000a07c, 0x00000000},
+-	{0x0000a080, 0x1a1a1a1a},
+-	{0x0000a084, 0x1a1a1a1a},
+-	{0x0000a088, 0x1a1a1a1a},
+-	{0x0000a08c, 0x1a1a1a1a},
+-	{0x0000a090, 0x171a1a1a},
++	{0x0000a080, 0x22222229},
++	{0x0000a084, 0x1d1d1d1d},
++	{0x0000a088, 0x1d1d1d1d},
++	{0x0000a08c, 0x1d1d1d1d},
++	{0x0000a090, 0x171d1d1d},
+ 	{0x0000a094, 0x11111717},
+ 	{0x0000a098, 0x00030311},
+ 	{0x0000a09c, 0x00000000},
Index: package/mac80211/patches/620-rt2x00-support-rt3352.patch
===================================================================
--- package/mac80211/patches/620-rt2x00-support-rt3352.patch	(revision 0)
+++ package/mac80211/patches/620-rt2x00-support-rt3352.patch	(revision 0)
@@ -0,0 +1,464 @@
+From 03839951515b0ea2b21d649b1fe7b63f9817d0c8 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <dgolle@allnet.de>
+Date: Sun, 9 Sep 2012 14:24:39 +0300
+Subject: [PATCH] rt2x00: add MediaTek/RaLink Rt3352 WiSoC
+
+Support for the RT3352 WiSoC was developed for and tested with the ALL5002
+devboard running OpenWrt. For now, this supports only devices with internal
+TXALC. Corrections were made according to the remarks of Stanislaw Gruszka and
+Gertjan van Wingerde, thank you guys for reviewing!
+
+Signed-off-by: Daniel Golle <dgolle@allnet.de>
+Signed-off-by: John W. Linville <linville@tuxdriver.com>
+---
+ drivers/net/wireless/rt2x00/rt2800.h    |   5 +
+ drivers/net/wireless/rt2x00/rt2800lib.c | 211 +++++++++++++++++++++++++++++++-
+ drivers/net/wireless/rt2x00/rt2x00.h    |   1 +
+ 3 files changed, 212 insertions(+), 5 deletions(-)
+
+diff --git a/drivers/net/wireless/rt2x00/rt2800.h b/drivers/net/wireless/rt2x00/rt2800.h
+index e13916f..6d67c3e 100644
+--- a/drivers/net/wireless/rt2x00/rt2800.h
++++ b/drivers/net/wireless/rt2x00/rt2800.h
+@@ -1943,6 +1943,11 @@ struct mac_iveiv_entry {
+ #define BBP47_TSSI_ADC6			FIELD8(0x80)
+ 
+ /*
++ * BBP 49
++ */
++#define BBP49_UPDATE_FLAG		FIELD8(0x01)
++
++/*
+  * BBP 109
+  */
+ #define BBP109_TX0_POWER		FIELD8(0x0f)
+diff --git a/drivers/net/wireless/rt2x00/rt2800lib.c b/drivers/net/wireless/rt2x00/rt2800lib.c
+index a04e222..9e09367 100644
+--- a/drivers/net/wireless/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/rt2x00/rt2800lib.c
+@@ -1615,6 +1615,7 @@ void rt2800_config_ant(struct rt2x00_dev *rt2x00dev, struct antenna_setup *ant)
+ 	case 1:
+ 		if (rt2x00_rt(rt2x00dev, RT3070) ||
+ 		    rt2x00_rt(rt2x00dev, RT3090) ||
++		    rt2x00_rt(rt2x00dev, RT3352) ||
+ 		    rt2x00_rt(rt2x00dev, RT3390)) {
+ 			rt2x00_eeprom_read(rt2x00dev,
+ 					   EEPROM_NIC_CONF1, &eeprom);
+@@ -2053,6 +2054,60 @@ static void rt2800_config_channel_rf3290(struct rt2x00_dev *rt2x00dev,
+ 	}
+ }
+ 
++static void rt2800_config_channel_rf3322(struct rt2x00_dev *rt2x00dev,
++					 struct ieee80211_conf *conf,
++					 struct rf_channel *rf,
++					 struct channel_info *info)
++{
++	u8 rfcsr;
++
++	rt2800_rfcsr_write(rt2x00dev, 8, rf->rf1);
++	rt2800_rfcsr_write(rt2x00dev, 9, rf->rf3);
++
++	rt2800_rfcsr_write(rt2x00dev, 11, 0x42);
++	rt2800_rfcsr_write(rt2x00dev, 12, 0x1c);
++	rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
++
++	if (info->default_power1 > POWER_BOUND)
++		rt2800_rfcsr_write(rt2x00dev, 47, POWER_BOUND);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 47, info->default_power1);
++
++	if (info->default_power2 > POWER_BOUND)
++		rt2800_rfcsr_write(rt2x00dev, 48, POWER_BOUND);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 48, info->default_power2);
++
++	rt2800_rfcsr_read(rt2x00dev, 17, &rfcsr);
++	if (rt2x00dev->freq_offset > FREQ_OFFSET_BOUND)
++		rt2x00_set_field8(&rfcsr, RFCSR17_CODE, FREQ_OFFSET_BOUND);
++	else
++		rt2x00_set_field8(&rfcsr, RFCSR17_CODE, rt2x00dev->freq_offset);
++
++	rt2800_rfcsr_write(rt2x00dev, 17, rfcsr);
++
++	rt2800_rfcsr_read(rt2x00dev, 1, &rfcsr);
++	rt2x00_set_field8(&rfcsr, RFCSR1_RX0_PD, 1);
++	rt2x00_set_field8(&rfcsr, RFCSR1_TX0_PD, 1);
++
++	if ( rt2x00dev->default_ant.tx_chain_num == 2 )
++		rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 1);
++	else
++		rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 0);
++
++	if ( rt2x00dev->default_ant.rx_chain_num == 2 )
++		rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 1);
++	else
++		rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 0);
++
++	rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 0);
++	rt2x00_set_field8(&rfcsr, RFCSR1_TX2_PD, 0);
++
++	rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
++
++	rt2800_rfcsr_write(rt2x00dev, 31, 80);
++}
++
+ static void rt2800_config_channel_rf53xx(struct rt2x00_dev *rt2x00dev,
+ 					 struct ieee80211_conf *conf,
+ 					 struct rf_channel *rf,
+@@ -2182,6 +2237,9 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
+ 	case RF3290:
+ 		rt2800_config_channel_rf3290(rt2x00dev, conf, rf, info);
+ 		break;
++	case RF3322:
++		rt2800_config_channel_rf3322(rt2x00dev, conf, rf, info);
++		break;
+ 	case RF5360:
+ 	case RF5370:
+ 	case RF5372:
+@@ -2194,6 +2252,7 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
+ 	}
+ 
+ 	if (rt2x00_rf(rt2x00dev, RF3290) ||
++	    rt2x00_rf(rt2x00dev, RF3322) ||
+ 	    rt2x00_rf(rt2x00dev, RF5360) ||
+ 	    rt2x00_rf(rt2x00dev, RF5370) ||
+ 	    rt2x00_rf(rt2x00dev, RF5372) ||
+@@ -2212,10 +2271,17 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
+ 	/*
+ 	 * Change BBP settings
+ 	 */
+-	rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
+-	rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
+-	rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
+-	rt2800_bbp_write(rt2x00dev, 86, 0);
++	if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_bbp_write(rt2x00dev, 27, 0x0);
++		rt2800_bbp_write(rt2x00dev, 62, 0x26 + rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 27, 0x20);
++		rt2800_bbp_write(rt2x00dev, 62, 0x26 + rt2x00dev->lna_gain);
++	} else {
++		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 86, 0);
++	}
+ 
+ 	if (rf->channel <= 14) {
+ 		if (!rt2x00_rt(rt2x00dev, RT5390) &&
+@@ -2310,6 +2376,15 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
+ 	rt2800_register_read(rt2x00dev, CH_IDLE_STA, &reg);
+ 	rt2800_register_read(rt2x00dev, CH_BUSY_STA, &reg);
+ 	rt2800_register_read(rt2x00dev, CH_BUSY_STA_SEC, &reg);
++
++	/*
++	 * Clear update flag
++	 */
++	if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_bbp_read(rt2x00dev, 49, &bbp);
++		rt2x00_set_field8(&bbp, BBP49_UPDATE_FLAG, 0);
++		rt2800_bbp_write(rt2x00dev, 49, bbp);
++	}
+ }
+ 
+ static int rt2800_get_gain_calibration_delta(struct rt2x00_dev *rt2x00dev)
+@@ -2998,6 +3073,10 @@ static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000400);
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00000000);
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000030);
++	} else if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000402);
++		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00080606);
++		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
+ 	} else if (rt2x00_rt(rt2x00dev, RT3572)) {
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000400);
+ 		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x00080606);
+@@ -3378,6 +3457,11 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 		     rt2800_wait_bbp_ready(rt2x00dev)))
+ 		return -EACCES;
+ 
++	if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_bbp_write(rt2x00dev, 3, 0x00);
++		rt2800_bbp_write(rt2x00dev, 4, 0x50);
++	}
++
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392)) {
+@@ -3388,15 +3472,20 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 
+ 	if (rt2800_is_305x_soc(rt2x00dev) ||
+ 	    rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT3572) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 31, 0x08);
+ 
++	if (rt2x00_rt(rt2x00dev, RT3352))
++		rt2800_bbp_write(rt2x00dev, 47, 0x48);
++
+ 	rt2800_bbp_write(rt2x00dev, 65, 0x2c);
+ 	rt2800_bbp_write(rt2x00dev, 66, 0x38);
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 68, 0x0b);
+@@ -3405,6 +3494,7 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 		rt2800_bbp_write(rt2x00dev, 69, 0x16);
+ 		rt2800_bbp_write(rt2x00dev, 73, 0x12);
+ 	} else if (rt2x00_rt(rt2x00dev, RT3290) ||
++		   rt2x00_rt(rt2x00dev, RT3352) ||
+ 		   rt2x00_rt(rt2x00dev, RT5390) ||
+ 		   rt2x00_rt(rt2x00dev, RT5392)) {
+ 		rt2800_bbp_write(rt2x00dev, 69, 0x12);
+@@ -3436,6 +3526,10 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 	} else if (rt2800_is_305x_soc(rt2x00dev)) {
+ 		rt2800_bbp_write(rt2x00dev, 78, 0x0e);
+ 		rt2800_bbp_write(rt2x00dev, 80, 0x08);
++	} else if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_bbp_write(rt2x00dev, 78, 0x0e);
++		rt2800_bbp_write(rt2x00dev, 80, 0x08);
++		rt2800_bbp_write(rt2x00dev, 81, 0x37);
+ 	} else {
+ 		rt2800_bbp_write(rt2x00dev, 81, 0x37);
+ 	}
+@@ -3465,18 +3559,21 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 		rt2800_bbp_write(rt2x00dev, 84, 0x99);
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 86, 0x38);
+ 	else
+ 		rt2800_bbp_write(rt2x00dev, 86, 0x00);
+ 
+-	if (rt2x00_rt(rt2x00dev, RT5392))
++	if (rt2x00_rt(rt2x00dev, RT3352) ||
++	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 88, 0x90);
+ 
+ 	rt2800_bbp_write(rt2x00dev, 91, 0x04);
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 92, 0x02);
+@@ -3493,6 +3590,7 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 	    rt2x00_rt_rev_gte(rt2x00dev, RT3090, REV_RT3090E) ||
+ 	    rt2x00_rt_rev_gte(rt2x00dev, RT3390, REV_RT3390E) ||
+ 	    rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT3572) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392) ||
+@@ -3502,6 +3600,7 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 		rt2800_bbp_write(rt2x00dev, 103, 0x00);
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 104, 0x92);
+@@ -3510,6 +3609,8 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 		rt2800_bbp_write(rt2x00dev, 105, 0x01);
+ 	else if (rt2x00_rt(rt2x00dev, RT3290))
+ 		rt2800_bbp_write(rt2x00dev, 105, 0x1c);
++	else if (rt2x00_rt(rt2x00dev, RT3352))
++		rt2800_bbp_write(rt2x00dev, 105, 0x34);
+ 	else if (rt2x00_rt(rt2x00dev, RT5390) ||
+ 			 rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 105, 0x3c);
+@@ -3519,11 +3620,16 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390))
+ 		rt2800_bbp_write(rt2x00dev, 106, 0x03);
++	else if (rt2x00_rt(rt2x00dev, RT3352))
++		rt2800_bbp_write(rt2x00dev, 106, 0x05);
+ 	else if (rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 106, 0x12);
+ 	else
+ 		rt2800_bbp_write(rt2x00dev, 106, 0x35);
+ 
++	if (rt2x00_rt(rt2x00dev, RT3352))
++		rt2800_bbp_write(rt2x00dev, 120, 0x50);
++
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+@@ -3534,6 +3640,9 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 		rt2800_bbp_write(rt2x00dev, 135, 0xf6);
+ 	}
+ 
++	if (rt2x00_rt(rt2x00dev, RT3352))
++		rt2800_bbp_write(rt2x00dev, 137, 0x0f);
++
+ 	if (rt2x00_rt(rt2x00dev, RT3071) ||
+ 	    rt2x00_rt(rt2x00dev, RT3090) ||
+ 	    rt2x00_rt(rt2x00dev, RT3390) ||
+@@ -3574,6 +3683,28 @@ static int rt2800_init_bbp(struct rt2x00_dev *rt2x00dev)
+ 		rt2800_bbp_write(rt2x00dev, 3, value);
+ 	}
+ 
++	if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_bbp_write(rt2x00dev, 163, 0xbd);
++		/* Set ITxBF timeout to 0x9c40=1000msec */
++		rt2800_bbp_write(rt2x00dev, 179, 0x02);
++		rt2800_bbp_write(rt2x00dev, 180, 0x00);
++		rt2800_bbp_write(rt2x00dev, 182, 0x40);
++		rt2800_bbp_write(rt2x00dev, 180, 0x01);
++		rt2800_bbp_write(rt2x00dev, 182, 0x9c);
++		rt2800_bbp_write(rt2x00dev, 179, 0x00);
++		/* Reprogram the inband interface to put right values in RXWI */
++		rt2800_bbp_write(rt2x00dev, 142, 0x04);
++		rt2800_bbp_write(rt2x00dev, 143, 0x3b);
++		rt2800_bbp_write(rt2x00dev, 142, 0x06);
++		rt2800_bbp_write(rt2x00dev, 143, 0xa0);
++		rt2800_bbp_write(rt2x00dev, 142, 0x07);
++		rt2800_bbp_write(rt2x00dev, 143, 0xa1);
++		rt2800_bbp_write(rt2x00dev, 142, 0x08);
++		rt2800_bbp_write(rt2x00dev, 143, 0xa2);
++
++		rt2800_bbp_write(rt2x00dev, 148, 0xc8);
++	}
++
+ 	if (rt2x00_rt(rt2x00dev, RT5390) ||
+ 		rt2x00_rt(rt2x00dev, RT5392)) {
+ 		int ant, div_mode;
+@@ -3707,6 +3838,7 @@ static int rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
+ 	    !rt2x00_rt(rt2x00dev, RT3071) &&
+ 	    !rt2x00_rt(rt2x00dev, RT3090) &&
+ 	    !rt2x00_rt(rt2x00dev, RT3290) &&
++	    !rt2x00_rt(rt2x00dev, RT3352) &&
+ 	    !rt2x00_rt(rt2x00dev, RT3390) &&
+ 	    !rt2x00_rt(rt2x00dev, RT3572) &&
+ 	    !rt2x00_rt(rt2x00dev, RT5390) &&
+@@ -3903,6 +4035,70 @@ static int rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
+ 		rt2800_rfcsr_write(rt2x00dev, 30, 0x00);
+ 		rt2800_rfcsr_write(rt2x00dev, 31, 0x00);
+ 		return 0;
++	} else if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_rfcsr_write(rt2x00dev, 0, 0xf0);
++		rt2800_rfcsr_write(rt2x00dev, 1, 0x23);
++		rt2800_rfcsr_write(rt2x00dev, 2, 0x50);
++		rt2800_rfcsr_write(rt2x00dev, 3, 0x18);
++		rt2800_rfcsr_write(rt2x00dev, 4, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 5, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 6, 0x33);
++		rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 8, 0xf1);
++		rt2800_rfcsr_write(rt2x00dev, 9, 0x02);
++		rt2800_rfcsr_write(rt2x00dev, 10, 0xd2);
++		rt2800_rfcsr_write(rt2x00dev, 11, 0x42);
++		rt2800_rfcsr_write(rt2x00dev, 12, 0x1c);
++		rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 14, 0x5a);
++		rt2800_rfcsr_write(rt2x00dev, 15, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 16, 0x01);
++		rt2800_rfcsr_write(rt2x00dev, 18, 0x45);
++		rt2800_rfcsr_write(rt2x00dev, 19, 0x02);
++		rt2800_rfcsr_write(rt2x00dev, 20, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 21, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 22, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 23, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 25, 0x80);
++		rt2800_rfcsr_write(rt2x00dev, 26, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 27, 0x03);
++		rt2800_rfcsr_write(rt2x00dev, 28, 0x03);
++		rt2800_rfcsr_write(rt2x00dev, 29, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 30, 0x10);
++		rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
++		rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
++		rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 34, 0x01);
++		rt2800_rfcsr_write(rt2x00dev, 35, 0x03);
++		rt2800_rfcsr_write(rt2x00dev, 36, 0xbd);
++		rt2800_rfcsr_write(rt2x00dev, 37, 0x3c);
++		rt2800_rfcsr_write(rt2x00dev, 38, 0x5f);
++		rt2800_rfcsr_write(rt2x00dev, 39, 0xc5);
++		rt2800_rfcsr_write(rt2x00dev, 40, 0x33);
++		rt2800_rfcsr_write(rt2x00dev, 41, 0x5b);
++		rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
++		rt2800_rfcsr_write(rt2x00dev, 43, 0xdb);
++		rt2800_rfcsr_write(rt2x00dev, 44, 0xdb);
++		rt2800_rfcsr_write(rt2x00dev, 45, 0xdb);
++		rt2800_rfcsr_write(rt2x00dev, 46, 0xdd);
++		rt2800_rfcsr_write(rt2x00dev, 47, 0x0d);
++		rt2800_rfcsr_write(rt2x00dev, 48, 0x14);
++		rt2800_rfcsr_write(rt2x00dev, 49, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 50, 0x2d);
++		rt2800_rfcsr_write(rt2x00dev, 51, 0x7f);
++		rt2800_rfcsr_write(rt2x00dev, 52, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 53, 0x52);
++		rt2800_rfcsr_write(rt2x00dev, 54, 0x1b);
++		rt2800_rfcsr_write(rt2x00dev, 55, 0x7f);
++		rt2800_rfcsr_write(rt2x00dev, 56, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 57, 0x52);
++		rt2800_rfcsr_write(rt2x00dev, 58, 0x1b);
++		rt2800_rfcsr_write(rt2x00dev, 59, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 60, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 61, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 62, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 63, 0x00);
+ 	} else if (rt2x00_rt(rt2x00dev, RT5390)) {
+ 		rt2800_rfcsr_write(rt2x00dev, 1, 0x0f);
+ 		rt2800_rfcsr_write(rt2x00dev, 2, 0x80);
+@@ -4104,6 +4300,7 @@ static int rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
+ 			rt2800_init_rx_filter(rt2x00dev, true, 0x27, 0x19);
+ 	} else if (rt2x00_rt(rt2x00dev, RT3071) ||
+ 		   rt2x00_rt(rt2x00dev, RT3090) ||
++		   rt2x00_rt(rt2x00dev, RT3352) ||
+ 		   rt2x00_rt(rt2x00dev, RT3390) ||
+ 		   rt2x00_rt(rt2x00dev, RT3572)) {
+ 		drv_data->calibration_bw20 =
+@@ -4566,6 +4763,7 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
+ 	case RT3071:
+ 	case RT3090:
+ 	case RT3290:
++	case RT3352:
+ 	case RT3390:
+ 	case RT3572:
+ 	case RT5390:
+@@ -4588,6 +4786,7 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
+ 	case RF3052:
+ 	case RF3290:
+ 	case RF3320:
++	case RF3322:
+ 	case RF5360:
+ 	case RF5370:
+ 	case RF5372:
+@@ -4612,6 +4811,7 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT3070) ||
+ 	    rt2x00_rt(rt2x00dev, RT3090) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT3390)) {
+ 		value = rt2x00_get_field16(eeprom,
+ 				EEPROM_NIC_CONF1_ANT_DIVERSITY);
+@@ -4904,6 +5104,7 @@ static int rt2800_probe_hw_mode(struct rt2x00_dev *rt2x00dev)
+ 		   rt2x00_rf(rt2x00dev, RF3022) ||
+ 		   rt2x00_rf(rt2x00dev, RF3290) ||
+ 		   rt2x00_rf(rt2x00dev, RF3320) ||
++		   rt2x00_rf(rt2x00dev, RF3322) ||
+ 		   rt2x00_rf(rt2x00dev, RF5360) ||
+ 		   rt2x00_rf(rt2x00dev, RF5370) ||
+ 		   rt2x00_rf(rt2x00dev, RF5372) ||
+diff --git a/drivers/net/wireless/rt2x00/rt2x00.h b/drivers/net/wireless/rt2x00/rt2x00.h
+index f991e8b..49375c8 100644
+--- a/drivers/net/wireless/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/rt2x00/rt2x00.h
+@@ -188,6 +188,7 @@ struct rt2x00_chip {
+ #define RT3071		0x3071
+ #define RT3090		0x3090	/* 2.4GHz PCIe */
+ #define RT3290		0x3290
++#define RT3352		0x3352  /* WSOC */
+ #define RT3390		0x3390
+ #define RT3572		0x3572
+ #define RT3593		0x3593
+-- 
+1.7.12.2
+
Index: package/mac80211/patches/564-ath9k_debugfs_diag.patch
===================================================================
--- package/mac80211/patches/564-ath9k_debugfs_diag.patch	(revision 0)
+++ package/mac80211/patches/564-ath9k_debugfs_diag.patch	(revision 0)
@@ -0,0 +1,139 @@
+--- a/drivers/net/wireless/ath/ath9k/debug.c
++++ b/drivers/net/wireless/ath/ath9k/debug.c
+@@ -1678,6 +1678,50 @@ static const struct file_operations fops
+ };
+ 
+ 
++static ssize_t read_file_diag(struct file *file, char __user *user_buf,
++			     size_t count, loff_t *ppos)
++{
++	struct ath_softc *sc = file->private_data;
++	struct ath_hw *ah = sc->sc_ah;
++	char buf[32];
++	unsigned int len;
++
++	len = sprintf(buf, "0x%08lx\n", ah->diag);
++	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
++}
++
++static ssize_t write_file_diag(struct file *file, const char __user *user_buf,
++			     size_t count, loff_t *ppos)
++{
++	struct ath_softc *sc = file->private_data;
++	struct ath_hw *ah = sc->sc_ah;
++	unsigned long diag;
++	char buf[32];
++	ssize_t len;
++
++	len = min(count, sizeof(buf) - 1);
++	if (copy_from_user(buf, user_buf, len))
++		return -EFAULT;
++
++	buf[len] = '\0';
++	if (strict_strtoul(buf, 0, &diag))
++		return -EINVAL;
++
++	ah->diag = diag;
++	ath9k_hw_update_diag(ah);
++
++	return count;
++}
++
++static const struct file_operations fops_diag = {
++	.read = read_file_diag,
++	.write = write_file_diag,
++	.open = simple_open,
++	.owner = THIS_MODULE,
++	.llseek = default_llseek,
++};
++
++
+ int ath9k_init_debug(struct ath_hw *ah)
+ {
+ 	struct ath_common *common = ath9k_hw_common(ah);
+@@ -1760,5 +1804,8 @@ int ath9k_init_debug(struct ath_hw *ah)
+ 	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+ 			    sc, &fops_chanbw);
+ 
++	debugfs_create_file("diag", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
++			    sc, &fops_diag);
++
+ 	return 0;
+ }
+--- a/drivers/net/wireless/ath/ath9k/hw.h
++++ b/drivers/net/wireless/ath/ath9k/hw.h
+@@ -498,6 +498,12 @@ enum {
+ 	ATH9K_RESET_COLD,
+ };
+ 
++enum {
++	ATH_DIAG_DISABLE_RX,
++	ATH_DIAG_DISABLE_TX,
++	ATH_DIAG_TRIGGER_ERROR,
++};
++
+ struct ath9k_hw_version {
+ 	u32 magic;
+ 	u16 devid;
+@@ -741,6 +747,8 @@ struct ath_hw {
+ 	u32 rfkill_polarity;
+ 	u32 ah_flags;
+ 
++	unsigned long diag;
++
+ 	bool htc_reset_init;
+ 
+ 	enum nl80211_iftype opmode;
+@@ -1007,6 +1015,7 @@ void ath9k_hw_set_sta_beacon_timers(stru
+ bool ath9k_hw_check_alive(struct ath_hw *ah);
+ 
+ bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
++void ath9k_hw_update_diag(struct ath_hw *ah);
+ 
+ #ifdef CONFIG_ATH9K_DEBUGFS
+ void ath9k_debug_sync_cause(struct ath_common *common, u32 sync_cause);
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -1749,6 +1749,20 @@ fail:
+ 	return -EINVAL;
+ }
+ 
++void ath9k_hw_update_diag(struct ath_hw *ah)
++{
++	if (test_bit(ATH_DIAG_DISABLE_RX, &ah->diag))
++		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
++	else
++		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
++
++	if (test_bit(ATH_DIAG_DISABLE_TX, &ah->diag))
++		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
++	else
++		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
++}
++EXPORT_SYMBOL(ath9k_hw_update_diag);
++
+ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
+ 		   struct ath9k_hw_cal_data *caldata, bool fastcc)
+ {
+@@ -2026,6 +2040,7 @@ int ath9k_hw_reset(struct ath_hw *ah, st
+ 	}
+ 
+ 	ath9k_hw_apply_gpio_override(ah);
++	ath9k_hw_update_diag(ah);
+ 
+ 	return 0;
+ }
+--- a/drivers/net/wireless/ath/ath9k/main.c
++++ b/drivers/net/wireless/ath/ath9k/main.c
+@@ -476,6 +476,11 @@ irqreturn_t ath_isr(int irq, void *dev)
+ 	ath9k_hw_getisr(ah, &status);	/* NB: clears ISR too */
+ 	status &= ah->imask;	/* discard unasked-for bits */
+ 
++	if (test_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag)) {
++		status |= ATH9K_INT_FATAL;
++		clear_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag);
++	}
++
+ 	/*
+ 	 * If there are no status bits set, then this interrupt was not
+ 	 * for me (should have been caught above).
Index: package/mac80211/patches/405-regd_no_assoc_hints.patch
===================================================================
--- package/mac80211/patches/405-regd_no_assoc_hints.patch	(revision 31639)
+++ package/mac80211/patches/405-regd_no_assoc_hints.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/net/wireless/reg.c
 +++ b/net/wireless/reg.c
-@@ -1699,6 +1699,8 @@ void regulatory_hint_11d(struct wiphy *w
+@@ -1796,6 +1796,8 @@ void regulatory_hint_11d(struct wiphy *w
  	enum environment_cap env = ENVIRON_ANY;
  	struct regulatory_request *request;
  
@@ -9,7 +9,7 @@
  	mutex_lock(&reg_mutex);
  
  	if (unlikely(!last_request))
-@@ -1934,6 +1936,8 @@ static void restore_regulatory_settings(
+@@ -2030,6 +2032,8 @@ static void restore_regulatory_settings(
  
  void regulatory_hint_disconnect(void)
  {
Index: package/mac80211/patches/604-rt2x00-add-CONFIG_RT2X00_LIB_EEPROM-option.patch
===================================================================
--- package/mac80211/patches/604-rt2x00-add-CONFIG_RT2X00_LIB_EEPROM-option.patch	(revision 31639)
+++ package/mac80211/patches/604-rt2x00-add-CONFIG_RT2X00_LIB_EEPROM-option.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -614,6 +614,7 @@ export CONFIG_RT2X00=y
+@@ -624,6 +624,7 @@ export CONFIG_RT2X00=y
  export CONFIG_RT2X00_LIB=m
  export CONFIG_RT2800_LIB=m
  export CONFIG_RT2X00_LIB_FIRMWARE=y
Index: package/mac80211/patches/050-compat_firmware.patch
===================================================================
--- package/mac80211/patches/050-compat_firmware.patch	(revision 31639)
+++ package/mac80211/patches/050-compat_firmware.patch	(working copy)
@@ -1,20 +1,17 @@
 --- a/compat/Makefile
 +++ b/compat/Makefile
-@@ -1,10 +1,13 @@
+@@ -1,7 +1,10 @@
  obj-m += compat.o
  #compat-objs :=
  
 -obj-$(CONFIG_COMPAT_FIRMWARE_CLASS) += compat_firmware_class.o
- 
- compat-y += main.o
- 
 +ifdef CONFIG_COMPAT_FIRMWARE_CLASS
 +  compat-y += compat_firmware_class.o
 +endif
 +
- # Compat kernel compatibility code
- compat-$(CONFIG_COMPAT_KERNEL_2_6_14) += compat-2.6.14.o
- compat-$(CONFIG_COMPAT_KERNEL_2_6_18) += compat-2.6.18.o
+ obj-$(CONFIG_COMPAT_NET_SCH_CODEL) += sch_codel.o
+ 
+ sch_fq_codel-y = sch_fq_codel_core.o flow_dissector.o
 --- a/compat/compat_firmware_class.c
 +++ b/compat/compat_firmware_class.c
 @@ -741,19 +741,16 @@ compat_request_firmware_nowait(
@@ -41,10 +38,10 @@
  EXPORT_SYMBOL_GPL(request_firmware_nowait);
 --- a/compat/main.c
 +++ b/compat/main.c
-@@ -37,6 +37,17 @@ void compat_dependency_symbol(void)
- }
+@@ -47,6 +47,17 @@ void compat_dependency_symbol(void)
  EXPORT_SYMBOL_GPL(compat_dependency_symbol);
  
+ 
 +#if defined(CONFIG_FW_LOADER) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33))
 +int __init firmware_class_init(void);
 +void __exit firmware_class_exit(void);
@@ -58,10 +55,10 @@
 +
  static int __init compat_init(void)
  {
- 	/* pm-qos for kernels <= 2.6.24, this is a no-op on newer kernels */
-@@ -51,7 +62,8 @@ static int __init compat_init(void)
- 	       COMPAT_BASE_TREE " " COMPAT_BASE_TREE_VERSION
- 	       "\n");
+ 	compat_pm_qos_power_init();
+@@ -63,7 +74,8 @@ static int __init compat_init(void)
+ 	printk(KERN_INFO "compat.git: "
+ 	       COMPAT_BASE_TREE "\n");
  
 -        return 0;
 +	firmware_class_init();
@@ -69,7 +66,7 @@
  }
  module_init(compat_init);
  
-@@ -60,7 +72,8 @@ static void __exit compat_exit(void)
+@@ -72,7 +84,8 @@ static void __exit compat_exit(void)
  	compat_pm_qos_power_deinit();
  	compat_system_workqueue_destroy();
  
Index: package/mac80211/patches/022-remove_crc8_and_cordic.patch
===================================================================
--- package/mac80211/patches/022-remove_crc8_and_cordic.patch	(revision 31639)
+++ package/mac80211/patches/022-remove_crc8_and_cordic.patch	(working copy)
@@ -1,8 +1,8 @@
 --- a/compat/Makefile
 +++ b/compat/Makefile
-@@ -38,8 +38,6 @@ compat-$(CONFIG_COMPAT_KERNEL_3_2) += co
- compat-$(CONFIG_COMPAT_KERNEL_3_3) += compat-3.3.o
- compat-$(CONFIG_COMPAT_KERNEL_3_5) += compat-3.5.o
+@@ -47,8 +47,6 @@ compat-$(CONFIG_COMPAT_KERNEL_3_3) += \
+ compat-$(CONFIG_COMPAT_KERNEL_3_4) += compat-3.4.o
+ compat-$(CONFIG_COMPAT_KERNEL_3_7) += compat-3.7.o
  
 -compat-$(CONFIG_COMPAT_CORDIC) += cordic.o
 -compat-$(CONFIG_COMPAT_CRC8) += crc8.o
Index: package/mac80211/patches/892_ath9k_htc_remove_interface_combination_specific_checks.patch
===================================================================
--- package/mac80211/patches/892_ath9k_htc_remove_interface_combination_specific_checks.patch	(revision 0)
+++ package/mac80211/patches/892_ath9k_htc_remove_interface_combination_specific_checks.patch	(revision 0)
@@ -0,0 +1,31 @@
+diff --git a/drivers/net/wireless/ath/ath9k/htc_drv_main.c b/drivers/net/wireless/ath/ath9k/htc_drv_main.c
+index ca78e33..66f6a74 100644
+--- a/drivers/net/wireless/ath/ath9k/htc_drv_main.c
++++ b/drivers/net/wireless/ath/ath9k/htc_drv_main.c
+@@ -1036,26 +1036,6 @@  static int ath9k_htc_add_interface(struct ieee80211_hw *hw,
+ 
+ 	mutex_lock(&priv->mutex);
+ 
+-	if (priv->nvifs >= ATH9K_HTC_MAX_VIF) {
+-		mutex_unlock(&priv->mutex);
+-		return -ENOBUFS;
+-	}
+-
+-	if (priv->num_ibss_vif ||
+-	    (priv->nvifs && vif->type == NL80211_IFTYPE_ADHOC)) {
+-		ath_err(common, "IBSS coexistence with other modes is not allowed\n");
+-		mutex_unlock(&priv->mutex);
+-		return -ENOBUFS;
+-	}
+-
+-	if (((vif->type == NL80211_IFTYPE_AP) ||
+-	     (vif->type == NL80211_IFTYPE_ADHOC)) &&
+-	    ((priv->num_ap_vif + priv->num_ibss_vif) >= ATH9K_HTC_MAX_BCN_VIF)) {
+-		ath_err(common, "Max. number of beaconing interfaces reached\n");
+-		mutex_unlock(&priv->mutex);
+-		return -ENOBUFS;
+-	}
+-
+ 	ath9k_htc_ps_wakeup(priv);
+ 	memset(&hvif, 0, sizeof(struct ath9k_htc_target_vif));
+ 	memcpy(&hvif.myaddr, vif->addr, ETH_ALEN);
Index: package/mac80211/patches/820-b43-add-antenna-control.patch
===================================================================
--- package/mac80211/patches/820-b43-add-antenna-control.patch	(revision 31639)
+++ package/mac80211/patches/820-b43-add-antenna-control.patch	(working copy)
@@ -9,7 +9,7 @@
  	antenna = b43_antenna_to_phyctl(antenna);
  	ctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
  	/* We can't send beacons with short preamble. Would get PHY errors. */
-@@ -3045,8 +3045,8 @@ static int b43_chip_init(struct b43_wlde
+@@ -3049,8 +3049,8 @@ static int b43_chip_init(struct b43_wlde
  
  	/* Select the antennae */
  	if (phy->ops->set_rx_antenna)
@@ -20,7 +20,7 @@
  
  	if (phy->type == B43_PHYTYPE_B) {
  		value16 = b43_read16(dev, 0x005E);
-@@ -3789,7 +3789,6 @@ static int b43_op_config(struct ieee8021
+@@ -3794,7 +3794,6 @@ static int b43_op_config(struct ieee8021
  	struct b43_wldev *dev;
  	struct b43_phy *phy;
  	struct ieee80211_conf *conf = &hw->conf;
@@ -28,7 +28,7 @@
  	int err = 0;
  	bool reload_bss = false;
  
-@@ -3843,11 +3842,9 @@ static int b43_op_config(struct ieee8021
+@@ -3848,11 +3847,9 @@ static int b43_op_config(struct ieee8021
  	}
  
  	/* Antennas for RX and management frame TX. */
@@ -42,7 +42,7 @@
  
  	if (wl->radio_enabled != phy->radio_on) {
  		if (wl->radio_enabled) {
-@@ -4934,6 +4931,47 @@ static int b43_op_get_survey(struct ieee
+@@ -4974,6 +4971,47 @@ static int b43_op_get_survey(struct ieee
  	return 0;
  }
  
@@ -90,7 +90,7 @@
  static const struct ieee80211_ops b43_hw_ops = {
  	.tx			= b43_op_tx,
  	.conf_tx		= b43_op_conf_tx,
-@@ -4955,6 +4993,8 @@ static const struct ieee80211_ops b43_hw
+@@ -4995,6 +5033,8 @@ static const struct ieee80211_ops b43_hw
  	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
  	.get_survey		= b43_op_get_survey,
  	.rfkill_poll		= b43_rfkill_poll,
@@ -99,7 +99,7 @@
  };
  
  /* Hard-reset the chip. Do not call this directly.
-@@ -5201,6 +5241,8 @@ static int b43_one_core_attach(struct b4
+@@ -5241,6 +5281,8 @@ static int b43_one_core_attach(struct b4
  	if (!wldev)
  		goto out;
  
@@ -108,19 +108,19 @@
  	wldev->use_pio = b43_modparam_pio;
  	wldev->dev = dev;
  	wldev->wl = wl;
-@@ -5291,6 +5333,9 @@ static struct b43_wl *b43_wireless_init(
+@@ -5331,6 +5373,9 @@ static struct b43_wl *b43_wireless_init(
  
  	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
  
 +	hw->wiphy->available_antennas_rx = 0x3;
 +	hw->wiphy->available_antennas_tx = 0x3;
 +
- 	hw->queues = modparam_qos ? B43_QOS_QUEUE_NUM : 1;
- 	wl->mac80211_initially_registered_queues = hw->queues;
+ 	wl->hw_registred = false;
  	hw->max_rates = 2;
+ 	SET_IEEE80211_DEV(hw, dev->dev);
 --- a/drivers/net/wireless/b43/b43.h
 +++ b/drivers/net/wireless/b43/b43.h
-@@ -804,6 +804,8 @@ struct b43_wldev {
+@@ -808,6 +808,8 @@ struct b43_wldev {
  	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
  	bool use_pio;			/* TRUE if next init should use PIO */
  	int gpiomask;			/* GPIO LED mask as a module parameter */
Index: package/mac80211/patches/851-brcmsmac-start-adding-support-for-core-rev-28.patch
===================================================================
--- package/mac80211/patches/851-brcmsmac-start-adding-support-for-core-rev-28.patch	(revision 0)
+++ package/mac80211/patches/851-brcmsmac-start-adding-support-for-core-rev-28.patch	(revision 0)
@@ -0,0 +1,75 @@
+--- a/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
+@@ -97,6 +97,7 @@ static struct bcma_device_id brcms_corei
+ 	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 17, BCMA_ANY_CLASS),
+ 	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 23, BCMA_ANY_CLASS),
+ 	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 24, BCMA_ANY_CLASS),
++//	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 28, BCMA_ANY_CLASS),
+ 	BCMA_CORETABLE_END
+ };
+ MODULE_DEVICE_TABLE(bcma, brcms_coreid_table);
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.c
+@@ -734,7 +734,7 @@ static void brcms_c_ucode_bsinit(struct 
+ 	brcms_c_write_mhf(wlc_hw, wlc_hw->band->mhfs);
+ 
+ 	/* do band-specific ucode IHR, SHM, and SCR inits */
+-	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23) || D11REV_IS(wlc_hw->corerev, 28)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band))
+ 			brcms_c_write_inits(wlc_hw, ucode->d11n0bsinitvals16);
+ 		else
+@@ -2259,7 +2259,7 @@ static void brcms_ucode_download(struct 
+ 	if (wlc_hw->ucode_loaded)
+ 		return;
+ 
+-	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23) || D11REV_IS(wlc_hw->corerev, 28)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band)) {
+ 			brcms_ucode_write(wlc_hw, ucode->bcm43xx_16_mimo,
+ 					  ucode->bcm43xx_16_mimosz);
+@@ -3221,7 +3221,7 @@ static void brcms_b_coreinit(struct brcm
+ 
+ 	sflags = bcma_aread32(core, BCMA_IOST);
+ 
+-	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23) || D11REV_IS(wlc_hw->corerev, 28)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band))
+ 			brcms_c_write_inits(wlc_hw, ucode->d11n0initvals16);
+ 		else
+@@ -5818,6 +5818,8 @@ static bool brcms_c_chipmatch_soc(struct
+ 
+ 	if (chipinfo->id == BCMA_CHIP_ID_BCM4716)
+ 		return true;
++	if (chipinfo->id == BCMA_CHIP_ID_BCM5357)
++		return true;
+ 
+ 	pr_err("unknown chip id %04x\n", chipinfo->id);
+ 	return false;
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.h
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.h
+@@ -65,7 +65,7 @@
+ #define	SW_TIMER_MAC_STAT_UPD		30	/* periodic MAC stats update */
+ 
+ /* max # supported core revisions (0 .. MAXCOREREV - 1) */
+-#define	MAXCOREREV		28
++#define	MAXCOREREV		29
+ 
+ /* Double check that unsupported cores are not enabled */
+ #if CONF_MSK(D11CONF, 0x4f) || CONF_GE(D11CONF, MAXCOREREV)
+--- a/drivers/net/wireless/brcm80211/brcmsmac/types.h
++++ b/drivers/net/wireless/brcm80211/brcmsmac/types.h
+@@ -93,11 +93,11 @@
+ #define BOARD_GPIO_13		0x2000
+ 
+ /* **** Core type/rev defaults **** */
+-#define D11CONF		0x0fffffb0	/* Supported  D11 revs: 4, 5, 7-27
++#define D11CONF		0x1fffffb0	/* Supported  D11 revs: 4, 5, 7-27
+ 					 * also need to update wlc.h MAXCOREREV
+ 					 */
+ 
+-#define NCONF		0x000001ff	/* Supported nphy revs:
++#define NCONF		0x000002ff	/* Supported nphy revs:
+ 					 *      0       4321a0
+ 					 *      1       4321a1
+ 					 *      2       4321b0/b1/c0/c1
Index: package/mac80211/patches/003-disable_bt.patch
===================================================================
--- package/mac80211/patches/003-disable_bt.patch	(revision 31639)
+++ package/mac80211/patches/003-disable_bt.patch	(working copy)
@@ -1,13 +1,15 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -99,8 +99,8 @@ ifndef CONFIG_COMPAT_KERNEL_2_6_27
+@@ -100,9 +100,9 @@ ifndef CONFIG_COMPAT_KERNEL_2_6_27
  ifeq ($(CONFIG_BT),y)
  # we'll ignore compiling bluetooth
  else
 - export CONFIG_COMPAT_BLUETOOTH=y
 - export CONFIG_COMPAT_BLUETOOTH_MODULES=m
+- export CONFIG_HID_GENERIC=m
 +# export CONFIG_COMPAT_BLUETOOTH=y
 +# export CONFIG_COMPAT_BLUETOOTH_MODULES=m
++# export CONFIG_HID_GENERIC=m
  endif
  endif #CONFIG_COMPAT_KERNEL_2_6_27
  
Index: package/mac80211/patches/011-no_sdio.patch
===================================================================
--- package/mac80211/patches/011-no_sdio.patch	(revision 31639)
+++ package/mac80211/patches/011-no_sdio.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -564,7 +564,7 @@ endif #CONFIG_SPI_MASTER end of SPI driv
+@@ -582,7 +582,7 @@ endif #CONFIG_SPI_MASTER end of SPI driv
  ifdef CONFIG_MMC
  
  # export CONFIG_SSB_SDIOHOST=y
Index: package/mac80211/patches/005-disable_ssb_build.patch
===================================================================
--- package/mac80211/patches/005-disable_ssb_build.patch	(revision 31639)
+++ package/mac80211/patches/005-disable_ssb_build.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/Makefile
 +++ b/Makefile
-@@ -29,7 +29,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
+@@ -45,7 +45,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
  
  obj-$(CONFIG_COMPAT_NET_USB_MODULES) += drivers/net/usb/
  
@@ -19,7 +19,7 @@
  else
  include $(KLIB_BUILD)/.config
  endif
-@@ -338,7 +338,8 @@ export CONFIG_IPW2200_QOS=y
+@@ -353,7 +353,8 @@ export CONFIG_IPW2200_QOS=y
  # % echo 1 > /sys/bus/pci/drivers/ipw2200/*/rtap_iface
  endif #CONFIG_WIRELESS_EXT
  
@@ -29,7 +29,7 @@
  # Sonics Silicon Backplane
  export CONFIG_SSB_SPROM=y
  
-@@ -351,7 +352,7 @@ endif #CONFIG_PCMCIA
+@@ -366,7 +367,7 @@ endif #CONFIG_PCMCIA
  # export CONFIG_SSB_DEBUG=y
  export CONFIG_SSB_DRIVER_PCICORE=y
  export CONFIG_B43_SSB=y
@@ -38,7 +38,7 @@
  
  export CONFIG_BCMA=m
  export CONFIG_BCMA_BLOCKIO=y
-@@ -562,7 +563,7 @@ endif #CONFIG_SPI_MASTER end of SPI driv
+@@ -580,7 +581,7 @@ endif #CONFIG_SPI_MASTER end of SPI driv
  
  ifdef CONFIG_MMC
  
Index: package/mac80211/patches/016-remove_pid_algo.patch
===================================================================
--- package/mac80211/patches/016-remove_pid_algo.patch	(revision 31639)
+++ package/mac80211/patches/016-remove_pid_algo.patch	(working copy)
@@ -1,7 +1,7 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -167,7 +167,7 @@ export CONFIG_MAC80211_RC_DEFAULT_MINSTR
- # This is the one used by our compat-wireless net/mac80211/rate.c
+@@ -169,7 +169,7 @@ export CONFIG_MAC80211_RC_DEFAULT_MINSTR
+ # This is the one used by our compat-drivers net/mac80211/rate.c
  # in case you have and old kernel which is overriding this to pid.
  export CONFIG_COMPAT_MAC80211_RC_DEFAULT=minstrel_ht
 -export CONFIG_MAC80211_RC_PID=y
Index: package/mac80211/patches/071-add_codel_ifdef.patch
===================================================================
--- package/mac80211/patches/071-add_codel_ifdef.patch	(revision 0)
+++ package/mac80211/patches/071-add_codel_ifdef.patch	(revision 0)
@@ -0,0 +1,19 @@
+--- a/include/linux/compat-3.5.h
++++ b/include/linux/compat-3.5.h
+@@ -8,6 +8,8 @@
+ 
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
+ 
++#ifndef TCA_CODEL_MAX
++
+ /*
+  * This backports:
+  *
+@@ -135,6 +137,7 @@ static inline int compat_vga_switcheroo_
+ 
+ #define SIZE_MAX    (~(size_t)0)
+ 
++#endif /* TCA_CODEL_MAX */
+ 
+ #include <linux/pkt_sched.h>
+ 
Index: package/mac80211/patches/621-rt2x00-fix-rt3352-lnagain.patch
===================================================================
--- package/mac80211/patches/621-rt2x00-fix-rt3352-lnagain.patch	(revision 0)
+++ package/mac80211/patches/621-rt2x00-fix-rt3352-lnagain.patch	(revision 0)
@@ -0,0 +1,30 @@
+From d0ae5f33c0221339a50bd1005c569934417003a5 Mon Sep 17 00:00:00 2001
+From: Daniel Golle <dgolle@allnet.de>
+Date: Thu, 4 Oct 2012 00:34:01 +0200
+Subject: [PATCH] rt2x00/rt3352: Fix lnagain assignment to use register 66.
+To: users@rt2x00.serialmonkey.com
+Cc: gwingerde@gmail.com
+
+---
+ drivers/net/wireless/rt2x00/rt2800lib.c | 4 ++--
+ 1 file changed, 2 insertions(+), 2 deletions(-)
+
+diff --git a/drivers/net/wireless/rt2x00/rt2800lib.c b/drivers/net/wireless/rt2x00/rt2800lib.c
+index 540c94f..01dc889 100644
+--- a/drivers/net/wireless/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/rt2x00/rt2800lib.c
+@@ -2252,9 +2252,9 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
+ 	 */
+ 	if (rt2x00_rt(rt2x00dev, RT3352)) {
+ 		rt2800_bbp_write(rt2x00dev, 27, 0x0);
+-		rt2800_bbp_write(rt2x00dev, 62, 0x26 + rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
+ 		rt2800_bbp_write(rt2x00dev, 27, 0x20);
+-		rt2800_bbp_write(rt2x00dev, 62, 0x26 + rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
+ 	} else {
+ 		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
+ 		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
+-- 
+1.7.12.2
+
Index: package/mac80211/patches/520-mac80211_cur_txpower.patch
===================================================================
--- package/mac80211/patches/520-mac80211_cur_txpower.patch	(revision 31639)
+++ package/mac80211/patches/520-mac80211_cur_txpower.patch	(working copy)
@@ -1,22 +1,21 @@
 --- a/include/net/mac80211.h
 +++ b/include/net/mac80211.h
-@@ -825,7 +825,7 @@ enum ieee80211_smps_mode {
-  */
- struct ieee80211_conf {
- 	u32 flags;
--	int power_level, dynamic_ps_timeout;
-+	int cur_power_level, power_level, dynamic_ps_timeout;
- 	int max_sleep_period;
+@@ -1372,6 +1372,7 @@ struct ieee80211_hw {
+ 	u8 max_tx_aggregation_subframes;
+ 	u8 offchannel_tx_hw_queue;
+ 	u8 radiotap_mcs_details;
++	s8 cur_power_level;
+ 	netdev_features_t netdev_features;
+ };
  
- 	u16 listen_interval;
 --- a/net/mac80211/cfg.c
 +++ b/net/mac80211/cfg.c
-@@ -1757,7 +1757,7 @@ static int ieee80211_get_tx_power(struct
+@@ -1967,7 +1967,7 @@ static int ieee80211_get_tx_power(struct
  {
  	struct ieee80211_local *local = wiphy_priv(wiphy);
  
 -	*dbm = local->hw.conf.power_level;
-+	*dbm = local->hw.conf.cur_power_level;
++	*dbm = local->hw.cur_power_level;
  
  	return 0;
  }
@@ -26,7 +25,7 @@
  
  	if (local->hw.conf.power_level != power) {
  		changed |= IEEE80211_CONF_CHANGE_POWER;
-+		local->hw.conf.cur_power_level = power;
++		local->hw.cur_power_level = power;
  		local->hw.conf.power_level = power;
  	}
  
Index: package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
===================================================================
--- package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch	(revision 31639)
+++ package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath5k/initvals.c
 +++ b/drivers/net/wireless/ath/ath5k/initvals.c
-@@ -63,8 +63,14 @@ static const struct ath5k_ini ar5210_ini
+@@ -65,8 +65,14 @@ static const struct ath5k_ini ar5210_ini
  	{ AR5K_IMR,		0 },
  	{ AR5K_IER,		AR5K_IER_DISABLE },
  	{ AR5K_BSR,		0, AR5K_INI_READ },
@@ -17,7 +17,7 @@
  	{ AR5K_RXNOFRM,		8 },
 --- a/drivers/net/wireless/ath/ath5k/dma.c
 +++ b/drivers/net/wireless/ath/ath5k/dma.c
-@@ -861,10 +861,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
+@@ -863,10 +863,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
  	 * guess we can tweak it and see how it goes ;-)
  	 */
  	if (ah->ah_version != AR5K_AR5210) {
Index: package/mac80211/patches/530-ath9k_fix_initvals.patch
===================================================================
--- package/mac80211/patches/530-ath9k_fix_initvals.patch	(revision 0)
+++ package/mac80211/patches/530-ath9k_fix_initvals.patch	(revision 0)
@@ -0,0 +1,208 @@
+--- a/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
+@@ -534,108 +534,108 @@ static const u32 ar9300_2p2_baseband_cor
+ 
+ static const u32 ar9300Modes_high_power_tx_gain_table_2p2[][5] = {
+ 	/* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+-	{0x0000a2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+-	{0x0000a2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+-	{0x0000a2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
++	{0x0000a2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
++	{0x0000a2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
++	{0x0000a2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ 	{0x0000a2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+-	{0x0000a410, 0x000050d9, 0x000050d9, 0x000050d9, 0x000050d9},
+-	{0x0000a500, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+-	{0x0000a504, 0x06000003, 0x06000003, 0x04000002, 0x04000002},
+-	{0x0000a508, 0x0a000020, 0x0a000020, 0x08000004, 0x08000004},
+-	{0x0000a50c, 0x10000023, 0x10000023, 0x0b000200, 0x0b000200},
+-	{0x0000a510, 0x15000028, 0x15000028, 0x0f000202, 0x0f000202},
+-	{0x0000a514, 0x1b00002b, 0x1b00002b, 0x12000400, 0x12000400},
+-	{0x0000a518, 0x1f020028, 0x1f020028, 0x16000402, 0x16000402},
+-	{0x0000a51c, 0x2502002b, 0x2502002b, 0x19000404, 0x19000404},
+-	{0x0000a520, 0x2a04002a, 0x2a04002a, 0x1c000603, 0x1c000603},
+-	{0x0000a524, 0x2e06002a, 0x2e06002a, 0x21000a02, 0x21000a02},
+-	{0x0000a528, 0x3302202d, 0x3302202d, 0x25000a04, 0x25000a04},
+-	{0x0000a52c, 0x3804202c, 0x3804202c, 0x28000a20, 0x28000a20},
+-	{0x0000a530, 0x3c06202c, 0x3c06202c, 0x2c000e20, 0x2c000e20},
+-	{0x0000a534, 0x4108202d, 0x4108202d, 0x30000e22, 0x30000e22},
+-	{0x0000a538, 0x4506402d, 0x4506402d, 0x34000e24, 0x34000e24},
+-	{0x0000a53c, 0x4906222d, 0x4906222d, 0x38001640, 0x38001640},
+-	{0x0000a540, 0x4d062231, 0x4d062231, 0x3c001660, 0x3c001660},
+-	{0x0000a544, 0x50082231, 0x50082231, 0x3f001861, 0x3f001861},
+-	{0x0000a548, 0x5608422e, 0x5608422e, 0x43001a81, 0x43001a81},
+-	{0x0000a54c, 0x5a08442e, 0x5a08442e, 0x47001a83, 0x47001a83},
+-	{0x0000a550, 0x5e0a4431, 0x5e0a4431, 0x4a001c84, 0x4a001c84},
+-	{0x0000a554, 0x640a4432, 0x640a4432, 0x4e001ce3, 0x4e001ce3},
+-	{0x0000a558, 0x680a4434, 0x680a4434, 0x52001ce5, 0x52001ce5},
+-	{0x0000a55c, 0x6c0a6434, 0x6c0a6434, 0x56001ce9, 0x56001ce9},
+-	{0x0000a560, 0x6f0a6633, 0x6f0a6633, 0x5a001ceb, 0x5a001ceb},
+-	{0x0000a564, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a568, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a56c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a570, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a574, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a578, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a57c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a580, 0x00800000, 0x00800000, 0x00800000, 0x00800000},
+-	{0x0000a584, 0x06800003, 0x06800003, 0x04800002, 0x04800002},
+-	{0x0000a588, 0x0a800020, 0x0a800020, 0x08800004, 0x08800004},
+-	{0x0000a58c, 0x10800023, 0x10800023, 0x0b800200, 0x0b800200},
+-	{0x0000a590, 0x15800028, 0x15800028, 0x0f800202, 0x0f800202},
+-	{0x0000a594, 0x1b80002b, 0x1b80002b, 0x12800400, 0x12800400},
+-	{0x0000a598, 0x1f820028, 0x1f820028, 0x16800402, 0x16800402},
+-	{0x0000a59c, 0x2582002b, 0x2582002b, 0x19800404, 0x19800404},
+-	{0x0000a5a0, 0x2a84002a, 0x2a84002a, 0x1c800603, 0x1c800603},
+-	{0x0000a5a4, 0x2e86002a, 0x2e86002a, 0x21800a02, 0x21800a02},
+-	{0x0000a5a8, 0x3382202d, 0x3382202d, 0x25800a04, 0x25800a04},
+-	{0x0000a5ac, 0x3884202c, 0x3884202c, 0x28800a20, 0x28800a20},
+-	{0x0000a5b0, 0x3c86202c, 0x3c86202c, 0x2c800e20, 0x2c800e20},
+-	{0x0000a5b4, 0x4188202d, 0x4188202d, 0x30800e22, 0x30800e22},
+-	{0x0000a5b8, 0x4586402d, 0x4586402d, 0x34800e24, 0x34800e24},
+-	{0x0000a5bc, 0x4986222d, 0x4986222d, 0x38801640, 0x38801640},
+-	{0x0000a5c0, 0x4d862231, 0x4d862231, 0x3c801660, 0x3c801660},
+-	{0x0000a5c4, 0x50882231, 0x50882231, 0x3f801861, 0x3f801861},
+-	{0x0000a5c8, 0x5688422e, 0x5688422e, 0x43801a81, 0x43801a81},
+-	{0x0000a5cc, 0x5a88442e, 0x5a88442e, 0x47801a83, 0x47801a83},
+-	{0x0000a5d0, 0x5e8a4431, 0x5e8a4431, 0x4a801c84, 0x4a801c84},
+-	{0x0000a5d4, 0x648a4432, 0x648a4432, 0x4e801ce3, 0x4e801ce3},
+-	{0x0000a5d8, 0x688a4434, 0x688a4434, 0x52801ce5, 0x52801ce5},
+-	{0x0000a5dc, 0x6c8a6434, 0x6c8a6434, 0x56801ce9, 0x56801ce9},
+-	{0x0000a5e0, 0x6f8a6633, 0x6f8a6633, 0x5a801ceb, 0x5a801ceb},
+-	{0x0000a5e4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5e8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5ec, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5f0, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5f4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5f8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5fc, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
++	{0x0000a410, 0x000050d8, 0x000050d8, 0x000050d9, 0x000050d9},
++	{0x0000a500, 0x00002220, 0x00002220, 0x00000000, 0x00000000},
++	{0x0000a504, 0x04002222, 0x04002222, 0x04000002, 0x04000002},
++	{0x0000a508, 0x09002421, 0x09002421, 0x08000004, 0x08000004},
++	{0x0000a50c, 0x0d002621, 0x0d002621, 0x0b000200, 0x0b000200},
++	{0x0000a510, 0x13004620, 0x13004620, 0x0f000202, 0x0f000202},
++	{0x0000a514, 0x19004a20, 0x19004a20, 0x11000400, 0x11000400},
++	{0x0000a518, 0x1d004e20, 0x1d004e20, 0x15000402, 0x15000402},
++	{0x0000a51c, 0x21005420, 0x21005420, 0x19000404, 0x19000404},
++	{0x0000a520, 0x26005e20, 0x26005e20, 0x1b000603, 0x1b000603},
++	{0x0000a524, 0x2b005e40, 0x2b005e40, 0x1f000a02, 0x1f000a02},
++	{0x0000a528, 0x2f005e42, 0x2f005e42, 0x23000a04, 0x23000a04},
++	{0x0000a52c, 0x33005e44, 0x33005e44, 0x26000a20, 0x26000a20},
++	{0x0000a530, 0x38005e65, 0x38005e65, 0x2a000e20, 0x2a000e20},
++	{0x0000a534, 0x3c005e69, 0x3c005e69, 0x2e000e22, 0x2e000e22},
++	{0x0000a538, 0x40005e6b, 0x40005e6b, 0x31000e24, 0x31000e24},
++	{0x0000a53c, 0x44005e6d, 0x44005e6d, 0x34001640, 0x34001640},
++	{0x0000a540, 0x49005e72, 0x49005e72, 0x38001660, 0x38001660},
++	{0x0000a544, 0x4e005eb2, 0x4e005eb2, 0x3b001861, 0x3b001861},
++	{0x0000a548, 0x53005f12, 0x53005f12, 0x3e001a81, 0x3e001a81},
++	{0x0000a54c, 0x59025eb2, 0x59025eb2, 0x42001a83, 0x42001a83},
++	{0x0000a550, 0x5e025f12, 0x5e025f12, 0x44001c84, 0x44001c84},
++	{0x0000a554, 0x61027f12, 0x61027f12, 0x48001ce3, 0x48001ce3},
++	{0x0000a558, 0x6702bf12, 0x6702bf12, 0x4c001ce5, 0x4c001ce5},
++	{0x0000a55c, 0x6b02bf14, 0x6b02bf14, 0x50001ce9, 0x50001ce9},
++	{0x0000a560, 0x6f02bf16, 0x6f02bf16, 0x54001ceb, 0x54001ceb},
++	{0x0000a564, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a568, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a56c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a570, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a574, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a578, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a57c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a580, 0x00802220, 0x00802220, 0x00800000, 0x00800000},
++	{0x0000a584, 0x04802222, 0x04802222, 0x04800002, 0x04800002},
++	{0x0000a588, 0x09802421, 0x09802421, 0x08800004, 0x08800004},
++	{0x0000a58c, 0x0d802621, 0x0d802621, 0x0b800200, 0x0b800200},
++	{0x0000a590, 0x13804620, 0x13804620, 0x0f800202, 0x0f800202},
++	{0x0000a594, 0x19804a20, 0x19804a20, 0x11800400, 0x11800400},
++	{0x0000a598, 0x1d804e20, 0x1d804e20, 0x15800402, 0x15800402},
++	{0x0000a59c, 0x21805420, 0x21805420, 0x19800404, 0x19800404},
++	{0x0000a5a0, 0x26805e20, 0x26805e20, 0x1b800603, 0x1b800603},
++	{0x0000a5a4, 0x2b805e40, 0x2b805e40, 0x1f800a02, 0x1f800a02},
++	{0x0000a5a8, 0x2f805e42, 0x2f805e42, 0x23800a04, 0x23800a04},
++	{0x0000a5ac, 0x33805e44, 0x33805e44, 0x26800a20, 0x26800a20},
++	{0x0000a5b0, 0x38805e65, 0x38805e65, 0x2a800e20, 0x2a800e20},
++	{0x0000a5b4, 0x3c805e69, 0x3c805e69, 0x2e800e22, 0x2e800e22},
++	{0x0000a5b8, 0x40805e6b, 0x40805e6b, 0x31800e24, 0x31800e24},
++	{0x0000a5bc, 0x44805e6d, 0x44805e6d, 0x34801640, 0x34801640},
++	{0x0000a5c0, 0x49805e72, 0x49805e72, 0x38801660, 0x38801660},
++	{0x0000a5c4, 0x4e805eb2, 0x4e805eb2, 0x3b801861, 0x3b801861},
++	{0x0000a5c8, 0x53805f12, 0x53805f12, 0x3e801a81, 0x3e801a81},
++	{0x0000a5cc, 0x59825eb2, 0x59825eb2, 0x42801a83, 0x42801a83},
++	{0x0000a5d0, 0x5e825f12, 0x5e825f12, 0x44801c84, 0x44801c84},
++	{0x0000a5d4, 0x61827f12, 0x61827f12, 0x48801ce3, 0x48801ce3},
++	{0x0000a5d8, 0x6782bf12, 0x6782bf12, 0x4c801ce5, 0x4c801ce5},
++	{0x0000a5dc, 0x6b82bf14, 0x6b82bf14, 0x50801ce9, 0x50801ce9},
++	{0x0000a5e0, 0x6f82bf16, 0x6f82bf16, 0x54801ceb, 0x54801ceb},
++	{0x0000a5e4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5e8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5ec, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5f0, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5f4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5f8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5fc, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
+ 	{0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ 	{0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+-	{0x0000a608, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+-	{0x0000a60c, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+-	{0x0000a610, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+-	{0x0000a614, 0x01804601, 0x01804601, 0x01404000, 0x01404000},
+-	{0x0000a618, 0x01804601, 0x01804601, 0x01404501, 0x01404501},
+-	{0x0000a61c, 0x01804601, 0x01804601, 0x02008501, 0x02008501},
+-	{0x0000a620, 0x03408d02, 0x03408d02, 0x0280ca03, 0x0280ca03},
+-	{0x0000a624, 0x0300cc03, 0x0300cc03, 0x03010c04, 0x03010c04},
+-	{0x0000a628, 0x03410d04, 0x03410d04, 0x04014c04, 0x04014c04},
+-	{0x0000a62c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+-	{0x0000a630, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+-	{0x0000a634, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+-	{0x0000a638, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+-	{0x0000a63c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+-	{0x0000b2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+-	{0x0000b2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+-	{0x0000b2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
++	{0x0000a608, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
++	{0x0000a60c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
++	{0x0000a610, 0x00804000, 0x00804000, 0x00000000, 0x00000000},
++	{0x0000a614, 0x00804201, 0x00804201, 0x01404000, 0x01404000},
++	{0x0000a618, 0x0280c802, 0x0280c802, 0x01404501, 0x01404501},
++	{0x0000a61c, 0x0280ca03, 0x0280ca03, 0x02008501, 0x02008501},
++	{0x0000a620, 0x04c15104, 0x04c15104, 0x0280ca03, 0x0280ca03},
++	{0x0000a624, 0x04c15305, 0x04c15305, 0x03010c04, 0x03010c04},
++	{0x0000a628, 0x04c15305, 0x04c15305, 0x04014c04, 0x04014c04},
++	{0x0000a62c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
++	{0x0000a630, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
++	{0x0000a634, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
++	{0x0000a638, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
++	{0x0000a63c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
++	{0x0000b2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
++	{0x0000b2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
++	{0x0000b2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ 	{0x0000b2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+-	{0x0000c2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+-	{0x0000c2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+-	{0x0000c2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
++	{0x0000c2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
++	{0x0000c2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
++	{0x0000c2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ 	{0x0000c2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+-	{0x00016044, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+-	{0x00016048, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
+-	{0x00016068, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
+-	{0x00016444, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+-	{0x00016448, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
+-	{0x00016468, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
+-	{0x00016844, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+-	{0x00016848, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
+-	{0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
++	{0x00016044, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
++	{0x00016048, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
++	{0x00016068, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
++	{0x00016444, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
++	{0x00016448, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
++	{0x00016468, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
++	{0x00016844, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
++	{0x00016848, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
++	{0x00016868, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
+ };
+ 
+ static const u32 ar9300Modes_high_ob_db_tx_gain_table_2p2[][5] = {
Index: package/mac80211/patches/605-rt2x00-pci-eeprom.patch
===================================================================
--- package/mac80211/patches/605-rt2x00-pci-eeprom.patch	(revision 31639)
+++ package/mac80211/patches/605-rt2x00-pci-eeprom.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/rt2x00/rt2800pci.c
 +++ b/drivers/net/wireless/rt2x00/rt2800pci.c
-@@ -84,7 +84,7 @@ static void rt2800pci_mcu_status(struct 
+@@ -89,7 +89,7 @@ static void rt2800pci_mcu_status(struct 
  	rt2x00pci_register_write(rt2x00dev, H2M_MAILBOX_CID, ~0);
  }
  
@@ -9,14 +9,14 @@
  {
  	memcpy(rt2x00dev->eeprom, rt2x00dev->eeprom_file->data, EEPROM_SIZE);
  }
-@@ -968,8 +968,9 @@ static int rt2800pci_validate_eeprom(str
- 	/*
- 	 * Read EEPROM into buffer
- 	 */
+@@ -976,8 +976,9 @@ static irqreturn_t rt2800pci_interrupt(i
+  */
+ static void rt2800pci_read_eeprom(struct rt2x00_dev *rt2x00dev)
+ {
 -	if (rt2x00_is_soc(rt2x00dev))
 -		rt2800pci_read_eeprom_soc(rt2x00dev);
 +	if (rt2x00_is_soc(rt2x00dev) ||
-+			test_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags))
++	    test_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags))
 +		rt2800pci_read_eeprom_file(rt2x00dev);
  	else if (rt2800pci_efuse_detect(rt2x00dev))
  		rt2800pci_read_eeprom_efuse(rt2x00dev);
@@ -30,8 +30,8 @@
 +	struct rt2x00_platform_data *pdata;
  	struct rt2x00_dev *rt2x00dev;
  	int retval;
- 
-@@ -299,6 +300,12 @@ int rt2x00pci_probe(struct pci_dev *pci_
+ 	u16 chip;
+@@ -300,6 +301,12 @@ int rt2x00pci_probe(struct pci_dev *pci_
  	rt2x00dev->irq = pci_dev->irq;
  	rt2x00dev->name = pci_name(pci_dev);
  
Index: package/mac80211/patches/401-ath9k_blink_default.patch
===================================================================
--- package/mac80211/patches/401-ath9k_blink_default.patch	(revision 31639)
+++ package/mac80211/patches/401-ath9k_blink_default.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -39,7 +39,7 @@ int ath9k_modparam_nohwcrypt;
+@@ -40,7 +40,7 @@ int ath9k_modparam_nohwcrypt;
  module_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);
  MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption");
  
Index: package/mac80211/patches/566-ath9k_use_ieee80211_free_txskb.patch
===================================================================
--- package/mac80211/patches/566-ath9k_use_ieee80211_free_txskb.patch	(revision 0)
+++ package/mac80211/patches/566-ath9k_use_ieee80211_free_txskb.patch	(revision 0)
@@ -0,0 +1,149 @@
+--- a/drivers/net/wireless/ath/ath9k/xmit.c
++++ b/drivers/net/wireless/ath/ath9k/xmit.c
+@@ -66,8 +66,7 @@ static void ath_tx_update_baw(struct ath
+ static struct ath_buf *ath_tx_setup_buffer(struct ath_softc *sc,
+ 					   struct ath_txq *txq,
+ 					   struct ath_atx_tid *tid,
+-					   struct sk_buff *skb,
+-					   bool dequeue);
++					   struct sk_buff *skb);
+ 
+ enum {
+ 	MCS_HT20,
+@@ -176,7 +175,15 @@ static void ath_tx_flush_tid(struct ath_
+ 		fi = get_frame_info(skb);
+ 		bf = fi->bf;
+ 
+-		if (bf && fi->retries) {
++		if (!bf) {
++			bf = ath_tx_setup_buffer(sc, txq, tid, skb);
++			if (!bf) {
++				ieee80211_free_txskb(sc->hw, skb);
++				continue;
++			}
++		}
++
++		if (fi->retries) {
+ 			list_add_tail(&bf->list, &bf_head);
+ 			ath_tx_update_baw(sc, tid, bf->bf_state.seqno);
+ 			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
+@@ -789,10 +796,13 @@ static enum ATH_AGGR_STATUS ath_tx_form_
+ 		fi = get_frame_info(skb);
+ 		bf = fi->bf;
+ 		if (!fi->bf)
+-			bf = ath_tx_setup_buffer(sc, txq, tid, skb, true);
++			bf = ath_tx_setup_buffer(sc, txq, tid, skb);
+ 
+-		if (!bf)
++		if (!bf) {
++			__skb_unlink(skb, &tid->buf_q);
++			ieee80211_free_txskb(sc->hw, skb);
+ 			continue;
++		}
+ 
+ 		bf->bf_state.bf_type = BUF_AMPDU | BUF_AGGR;
+ 		seqno = bf->bf_state.seqno;
+@@ -1735,9 +1745,11 @@ static void ath_tx_send_ampdu(struct ath
+ 		return;
+ 	}
+ 
+-	bf = ath_tx_setup_buffer(sc, txctl->txq, tid, skb, false);
+-	if (!bf)
++	bf = ath_tx_setup_buffer(sc, txctl->txq, tid, skb);
++	if (!bf) {
++		ieee80211_free_txskb(sc->hw, skb);
+ 		return;
++	}
+ 
+ 	bf->bf_state.bf_type = BUF_AMPDU;
+ 	INIT_LIST_HEAD(&bf_head);
+@@ -1761,11 +1773,6 @@ static void ath_tx_send_normal(struct at
+ 	struct ath_buf *bf;
+ 
+ 	bf = fi->bf;
+-	if (!bf)
+-		bf = ath_tx_setup_buffer(sc, txq, tid, skb, false);
+-
+-	if (!bf)
+-		return;
+ 
+ 	INIT_LIST_HEAD(&bf_head);
+ 	list_add_tail(&bf->list, &bf_head);
+@@ -1839,8 +1846,7 @@ u8 ath_txchainmask_reduction(struct ath_
+ static struct ath_buf *ath_tx_setup_buffer(struct ath_softc *sc,
+ 					   struct ath_txq *txq,
+ 					   struct ath_atx_tid *tid,
+-					   struct sk_buff *skb,
+-					   bool dequeue)
++					   struct sk_buff *skb)
+ {
+ 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ 	struct ath_frame_info *fi = get_frame_info(skb);
+@@ -1852,7 +1858,7 @@ static struct ath_buf *ath_tx_setup_buff
+ 	bf = ath_tx_get_buffer(sc);
+ 	if (!bf) {
+ 		ath_dbg(common, XMIT, "TX buffers are full\n");
+-		goto error;
++		return NULL;
+ 	}
+ 
+ 	ATH_TXBUF_RESET(bf);
+@@ -1881,18 +1887,12 @@ static struct ath_buf *ath_tx_setup_buff
+ 		ath_err(ath9k_hw_common(sc->sc_ah),
+ 			"dma_mapping_error() on TX\n");
+ 		ath_tx_return_buffer(sc, bf);
+-		goto error;
++		return NULL;
+ 	}
+ 
+ 	fi->bf = bf;
+ 
+ 	return bf;
+-
+-error:
+-	if (dequeue)
+-		__skb_unlink(skb, &tid->buf_q);
+-	dev_kfree_skb_any(skb);
+-	return NULL;
+ }
+ 
+ /* FIXME: tx power */
+@@ -1921,9 +1921,14 @@ static void ath_tx_start_dma(struct ath_
+ 		 */
+ 		ath_tx_send_ampdu(sc, tid, skb, txctl);
+ 	} else {
+-		bf = ath_tx_setup_buffer(sc, txctl->txq, tid, skb, false);
+-		if (!bf)
++		bf = ath_tx_setup_buffer(sc, txctl->txq, tid, skb);
++		if (!bf) {
++			if (txctl->paprd)
++				dev_kfree_skb_any(skb);
++			else
++				ieee80211_free_txskb(sc->hw, skb);
+ 			return;
++		}
+ 
+ 		bf->bf_state.bfs_paprd = txctl->paprd;
+ 
+--- a/drivers/net/wireless/ath/ath9k/main.c
++++ b/drivers/net/wireless/ath/ath9k/main.c
+@@ -775,7 +775,7 @@ static void ath9k_tx(struct ieee80211_hw
+ 
+ 	return;
+ exit:
+-	dev_kfree_skb_any(skb);
++	ieee80211_free_txskb(hw, skb);
+ }
+ 
+ static void ath9k_stop(struct ieee80211_hw *hw)
+--- a/drivers/net/wireless/ath/ath9k/beacon.c
++++ b/drivers/net/wireless/ath/ath9k/beacon.c
+@@ -120,7 +120,7 @@ static void ath9k_tx_cabq(struct ieee802
+ 
+ 	if (ath_tx_start(hw, skb, &txctl) != 0) {
+ 		ath_dbg(common, XMIT, "CABQ TX failed\n");
+-		dev_kfree_skb_any(skb);
++		ieee80211_free_txskb(hw, skb);
+ 	}
+ }
+ 
Index: package/mac80211/patches/523-cfg80211_fix_antenna_gain.patch
===================================================================
--- package/mac80211/patches/523-cfg80211_fix_antenna_gain.patch	(revision 0)
+++ package/mac80211/patches/523-cfg80211_fix_antenna_gain.patch	(revision 0)
@@ -0,0 +1,12 @@
+--- a/net/wireless/reg.c
++++ b/net/wireless/reg.c
+@@ -908,8 +908,7 @@ static void handle_channel(struct wiphy 
+ 
+ 	chan->beacon_found = false;
+ 	chan->flags = flags | bw_flags | map_regdom_flags(reg_rule->flags);
+-	chan->max_antenna_gain = min(chan->orig_mag,
+-		(int) MBI_TO_DBI(power_rule->max_antenna_gain));
++	chan->max_antenna_gain = (int) MBI_TO_DBI(power_rule->max_antenna_gain);
+ 	chan->max_reg_power = (int) MBM_TO_DBM(power_rule->max_eirp);
+ 	if (chan->orig_mpwr) {
+ 		/*
Index: package/mac80211/patches/007-remove_misc_drivers.patch
===================================================================
--- package/mac80211/patches/007-remove_misc_drivers.patch	(revision 31639)
+++ package/mac80211/patches/007-remove_misc_drivers.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -237,7 +237,7 @@ $(warning "WARNING: CONFIG_CFG80211_WEXT
+@@ -241,7 +241,7 @@ $(warning "WARNING: CONFIG_CFG80211_WEXT
  endif #CONFIG_WIRELESS_EXT
  
  ifdef CONFIG_STAGING
@@ -9,7 +9,7 @@
  endif #CONFIG_STAGING
  
  # mac80211 test driver
-@@ -391,15 +391,15 @@ endif #CONFIG_CRC_ITU_T
+@@ -406,12 +406,12 @@ endif #CONFIG_CRC_ITU_T
  export CONFIG_MWL8K=m
  
  # Ethernet drivers go here
@@ -19,20 +19,15 @@
 +# export CONFIG_ATL1=m
 +# export CONFIG_ATL2=m
 +# export CONFIG_ATL1E=m
- ifdef CONFIG_COMPAT_KERNEL_2_6_27
--export CONFIG_ATL1C=n
+ ifndef CONFIG_COMPAT_KERNEL_2_6_28
+-export CONFIG_ATL1C=m
 -export CONFIG_ALX=m
-+# export CONFIG_ATL1C=n
++# export CONFIG_ATL1C=m
 +# export CONFIG_ALX=m
- else #CONFIG_COMPAT_KERNEL_2_6_27
--export CONFIG_ATL1C=n
--export CONFIG_ALX=m
-+# export CONFIG_ATL1C=n
-+# export CONFIG_ALX=m
- endif #CONFIG_COMPAT_KERNEL_2_6_27
+ endif #CONFIG_COMPAT_KERNEL_2_6_28
  
  ifdef CONFIG_WIRELESS_EXT
-@@ -460,21 +460,21 @@ endif #CONFIG_COMPAT_KERNEL_2_6_29
+@@ -472,21 +472,21 @@ endif #CONFIG_COMPAT_KERNEL_2_6_29
  # Note: this depends on CONFIG_USB_NET_RNDIS_HOST and CONFIG_USB_NET_CDCETHER
  # it also requires new RNDIS_HOST and CDC_ETHER modules which we add
  ifdef CONFIG_COMPAT_KERNEL_2_6_29
Index: package/mac80211/patches/550-mac80211_optimize_mcs_rate_mask.patch
===================================================================
--- package/mac80211/patches/550-mac80211_optimize_mcs_rate_mask.patch	(revision 31639)
+++ package/mac80211/patches/550-mac80211_optimize_mcs_rate_mask.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/net/mac80211/ieee80211_i.h
 +++ b/net/mac80211/ieee80211_i.h
-@@ -726,6 +726,8 @@ struct ieee80211_sub_if_data {
+@@ -715,6 +715,8 @@ struct ieee80211_sub_if_data {
  
  	/* bitmap of allowed (non-MCS) rate indexes for rate control */
  	u32 rc_rateidx_mask[IEEE80211_NUM_BANDS];
@@ -11,7 +11,7 @@
  	union {
 --- a/net/mac80211/cfg.c
 +++ b/net/mac80211/cfg.c
-@@ -1933,9 +1933,20 @@ static int ieee80211_set_bitrate_mask(st
+@@ -2160,9 +2160,20 @@ static int ieee80211_set_bitrate_mask(st
  	}
  
  	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
@@ -34,7 +34,7 @@
  	return 0;
 --- a/include/net/mac80211.h
 +++ b/include/net/mac80211.h
-@@ -3645,7 +3645,7 @@ void ieee80211_send_bar(struct ieee80211
+@@ -3721,7 +3721,7 @@ void ieee80211_send_bar(struct ieee80211
   *	(deprecated; this will be removed once drivers get updated to use
   *	rate_idx_mask)
   * @rate_idx_mask: user-requested (legacy) rate mask
@@ -43,7 +43,7 @@
   * @bss: whether this frame is sent out in AP or IBSS mode
   */
  struct ieee80211_tx_rate_control {
-@@ -3657,7 +3657,7 @@ struct ieee80211_tx_rate_control {
+@@ -3733,7 +3733,7 @@ struct ieee80211_tx_rate_control {
  	bool rts, short_preamble;
  	u8 max_rate_idx;
  	u32 rate_idx_mask;
@@ -54,22 +54,22 @@
  
 --- a/net/mac80211/tx.c
 +++ b/net/mac80211/tx.c
-@@ -642,9 +642,11 @@ ieee80211_tx_h_rate_ctrl(struct ieee8021
+@@ -631,9 +631,11 @@ ieee80211_tx_h_rate_ctrl(struct ieee8021
  		txrc.max_rate_idx = -1;
  	else
  		txrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;
 -	memcpy(txrc.rate_idx_mcs_mask,
--	       tx->sdata->rc_rateidx_mcs_mask[tx->channel->band],
+-	       tx->sdata->rc_rateidx_mcs_mask[info->band],
 -	       sizeof(txrc.rate_idx_mcs_mask));
 +
-+	if (tx->sdata->rc_has_mcs_mask[tx->channel->band])
++	if (tx->sdata->rc_has_mcs_mask[info->band])
 +		txrc.rate_idx_mcs_mask =
-+			tx->sdata->rc_rateidx_mcs_mask[tx->channel->band];
++			tx->sdata->rc_rateidx_mcs_mask[info->band];
 +
  	txrc.bss = (tx->sdata->vif.type == NL80211_IFTYPE_AP ||
  		    tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||
  		    tx->sdata->vif.type == NL80211_IFTYPE_ADHOC);
-@@ -2480,8 +2482,6 @@ struct sk_buff *ieee80211_beacon_get_tim
+@@ -2452,8 +2454,6 @@ struct sk_buff *ieee80211_beacon_get_tim
  		txrc.max_rate_idx = -1;
  	else
  		txrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;
Index: package/mac80211/patches/110-disable_usb_compat.patch
===================================================================
--- package/mac80211/patches/110-disable_usb_compat.patch	(revision 31639)
+++ package/mac80211/patches/110-disable_usb_compat.patch	(working copy)
@@ -22,7 +22,7 @@
   * @anchor: anchor the requests are bound to
 --- a/include/linux/compat-2.6.28.h
 +++ b/include/linux/compat-2.6.28.h
-@@ -73,7 +73,7 @@ int pcmcia_loop_config(struct pcmcia_dev
+@@ -74,7 +74,7 @@ int pcmcia_loop_config(struct pcmcia_dev
  /* USB anchors were added as of 2.6.23 */
  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23))
  
@@ -33,7 +33,7 @@
  #endif
 --- a/config.mk
 +++ b/config.mk
-@@ -498,7 +498,7 @@ endif #CONFIG_COMPAT_KERNEL_2_6_29
+@@ -510,7 +510,7 @@ endif #CONFIG_COMPAT_KERNEL_2_6_29
  # This activates a threading fix for usb urb.
  # this is mainline commit: b3e670443b7fb8a2d29831b62b44a039c283e351
  # This fix will be included in some stable releases.
Index: package/mac80211/patches/019-remove_ath5k_pci_option.patch
===================================================================
--- package/mac80211/patches/019-remove_ath5k_pci_option.patch	(revision 31639)
+++ package/mac80211/patches/019-remove_ath5k_pci_option.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -268,7 +268,7 @@ export CONFIG_ATH9K_BTCOEX_SUPPORT=y
+@@ -282,7 +282,7 @@ endif #CONFIG_COMPAT_KERNEL_2_6_27
  # PCI Drivers
  ifdef CONFIG_PCI
  
Index: package/mac80211/patches/432-ath5k_add_pciids.patch
===================================================================
--- package/mac80211/patches/432-ath5k_add_pciids.patch	(revision 31639)
+++ package/mac80211/patches/432-ath5k_add_pciids.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath5k/pci.c
 +++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -49,6 +49,8 @@ static DEFINE_PCI_DEVICE_TABLE(ath5k_pci
+@@ -50,6 +50,8 @@ static DEFINE_PCI_DEVICE_TABLE(ath5k_pci
  	{ PCI_VDEVICE(ATHEROS, 0x001b) }, /* 5413 Eagle */
  	{ PCI_VDEVICE(ATHEROS, 0x001c) }, /* PCI-E cards */
  	{ PCI_VDEVICE(ATHEROS, 0x001d) }, /* 2417 Nala */
Index: package/mac80211/patches/562-ath9k_add_idle_hack.patch
===================================================================
--- package/mac80211/patches/562-ath9k_add_idle_hack.patch	(revision 0)
+++ package/mac80211/patches/562-ath9k_add_idle_hack.patch	(revision 0)
@@ -0,0 +1,20 @@
+--- a/drivers/net/wireless/ath/ath9k/main.c
++++ b/drivers/net/wireless/ath/ath9k/main.c
+@@ -1087,6 +1087,7 @@ static void ath9k_remove_interface(struc
+ 	ath9k_calculate_summary_state(hw, NULL);
+ 
+ 	mutex_unlock(&sc->mutex);
++	ath9k_config(hw, IEEE80211_CONF_CHANGE_IDLE);
+ 	ath9k_ps_restore(sc);
+ }
+ 
+@@ -1139,7 +1140,8 @@ int ath9k_config(struct ieee80211_hw *hw
+ 	mutex_lock(&sc->mutex);
+ 
+ 	if (changed & IEEE80211_CONF_CHANGE_IDLE) {
+-		sc->ps_idle = !!(conf->flags & IEEE80211_CONF_IDLE);
++		sc->ps_idle = !!(conf->flags & IEEE80211_CONF_IDLE) &&
++			      !sc->nvifs;
+ 		if (sc->ps_idle) {
+ 			ath_cancel_work(sc);
+ 			ath9k_stop_btcoex(sc);
Index: package/mac80211/patches/017-remove_ath9k_rc.patch
===================================================================
--- package/mac80211/patches/017-remove_ath9k_rc.patch	(revision 31639)
+++ package/mac80211/patches/017-remove_ath9k_rc.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -261,7 +261,7 @@ export CONFIG_ATH9K_COMMON=m
+@@ -265,7 +265,7 @@ export CONFIG_ATH9K_COMMON=m
  # as default once we get minstrel properly tested and blessed by
  # our systems engineering team. CCK rates also need to be used
  # for long range considerations.
Index: package/mac80211/patches/b01-ath9k-allow-to-disable-bands-via-platform-data.patch
===================================================================
--- package/mac80211/patches/b01-ath9k-allow-to-disable-bands-via-platform-data.patch	(revision 0)
+++ package/mac80211/patches/b01-ath9k-allow-to-disable-bands-via-platform-data.patch	(revision 0)
@@ -0,0 +1,70 @@
+--- a/include/linux/ath9k_platform.h
++++ b/include/linux/ath9k_platform.h
+@@ -31,6 +31,9 @@ struct ath9k_platform_data {
+ 
+ 	bool endian_check;
+ 	bool is_clk_25mhz;
++	bool disable_2ghz;
++	bool disable_5ghz;
++
+ 	int (*get_mac_revision)(void);
+ 	int (*external_reset)(void);
+ 
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -2413,17 +2413,25 @@ int ath9k_hw_fill_cap_info(struct ath_hw
+ 	}
+ 
+ 	eeval = ah->eep_ops->get_eeprom(ah, EEP_OP_MODE);
+-	if ((eeval & (AR5416_OPFLAGS_11G | AR5416_OPFLAGS_11A)) == 0) {
+-		ath_err(common,
+-			"no band has been marked as supported in EEPROM\n");
+-		return -EINVAL;
++
++	if (eeval & AR5416_OPFLAGS_11A) {
++		if (ah->disable_5ghz)
++			ath_warn(common, "disabling 5GHz band\n");
++		else
++			pCap->hw_caps |= ATH9K_HW_CAP_5GHZ;
+ 	}
+ 
+-	if (eeval & AR5416_OPFLAGS_11A)
+-		pCap->hw_caps |= ATH9K_HW_CAP_5GHZ;
++	if (eeval & AR5416_OPFLAGS_11G) {
++		if (ah->disable_2ghz)
++			ath_warn(common, "disabling 2GHz band\n");
++		else
++			pCap->hw_caps |= ATH9K_HW_CAP_2GHZ;
++	}
+ 
+-	if (eeval & AR5416_OPFLAGS_11G)
+-		pCap->hw_caps |= ATH9K_HW_CAP_2GHZ;
++	if ((pCap->hw_caps & (ATH9K_HW_CAP_2GHZ | ATH9K_HW_CAP_5GHZ)) == 0) {
++		ath_err(common, "both bands are disabled\n");
++		return -EINVAL;
++	}
+ 
+ 	if (AR_SREV_9485(ah) || AR_SREV_9285(ah) || AR_SREV_9330(ah))
+ 		chip_chainmask = 1;
+--- a/drivers/net/wireless/ath/ath9k/hw.h
++++ b/drivers/net/wireless/ath/ath9k/hw.h
+@@ -927,6 +927,8 @@ struct ath_hw {
+ 	bool is_clk_25mhz;
+ 	int (*get_mac_revision)(void);
+ 	int (*external_reset)(void);
++	bool disable_2ghz;
++	bool disable_5ghz;
+ };
+ 
+ struct ath_bus_ops {
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -537,6 +537,8 @@ static int ath9k_init_softc(u16 devid, s
+ 		ah->is_clk_25mhz = pdata->is_clk_25mhz;
+ 		ah->get_mac_revision = pdata->get_mac_revision;
+ 		ah->external_reset = pdata->external_reset;
++		ah->disable_2ghz = pdata->disable_2ghz;
++		ah->disable_5ghz = pdata->disable_5ghz;
+ 		if (!pdata->endian_check)
+ 			ah->ah_flags |= AH_NO_EEP_SWAP;
+ 	}
Index: package/mac80211/patches/500-ath9k_eeprom_debugfs.patch
===================================================================
--- package/mac80211/patches/500-ath9k_eeprom_debugfs.patch	(revision 31639)
+++ package/mac80211/patches/500-ath9k_eeprom_debugfs.patch	(working copy)
@@ -54,7 +54,7 @@
  int ath9k_init_debug(struct ath_hw *ah)
  {
  	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1595,5 +1642,8 @@ int ath9k_init_debug(struct ath_hw *ah)
+@@ -1603,5 +1650,8 @@ int ath9k_init_debug(struct ath_hw *ah)
  	debugfs_create_u32("gpio_val", S_IRUSR | S_IWUSR,
  			   sc->debug.debugfs_phy, &sc->sc_ah->gpio_val);
  
Index: package/mac80211/patches/526-cfg80211_fix_max_reg_power.patch
===================================================================
--- package/mac80211/patches/526-cfg80211_fix_max_reg_power.patch	(revision 0)
+++ package/mac80211/patches/526-cfg80211_fix_max_reg_power.patch	(revision 0)
@@ -0,0 +1,21 @@
+--- a/net/wireless/reg.c
++++ b/net/wireless/reg.c
+@@ -901,7 +901,7 @@ static void handle_channel(struct wiphy 
+ 			map_regdom_flags(reg_rule->flags) | bw_flags;
+ 		chan->max_antenna_gain = chan->orig_mag =
+ 			(int) MBI_TO_DBI(power_rule->max_antenna_gain);
+-		chan->max_power = chan->orig_mpwr =
++		chan->max_reg_power = chan->max_power = chan->orig_mpwr =
+ 			(int) MBM_TO_DBM(power_rule->max_eirp);
+ 		return;
+ 	}
+@@ -1323,7 +1323,8 @@ static void handle_channel_custom(struct
+ 
+ 	chan->flags |= map_regdom_flags(reg_rule->flags) | bw_flags;
+ 	chan->max_antenna_gain = (int) MBI_TO_DBI(power_rule->max_antenna_gain);
+-	chan->max_power = (int) MBM_TO_DBM(power_rule->max_eirp);
++	chan->max_reg_power = chan->max_power =
++		(int) MBM_TO_DBM(power_rule->max_eirp);
+ }
+ 
+ static void handle_band_custom(struct wiphy *wiphy, enum ieee80211_band band,
Index: package/mac80211/patches/000-disable_ethernet.patch
===================================================================
--- package/mac80211/patches/000-disable_ethernet.patch	(revision 31639)
+++ package/mac80211/patches/000-disable_ethernet.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/Makefile
 +++ b/Makefile
-@@ -29,9 +29,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
+@@ -45,9 +45,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
  
  obj-$(CONFIG_COMPAT_NET_USB_MODULES) += drivers/net/usb/
  
Index: package/mac80211/patches/568-ath9k_fix_stale_pointer.patch
===================================================================
--- package/mac80211/patches/568-ath9k_fix_stale_pointer.patch	(revision 0)
+++ package/mac80211/patches/568-ath9k_fix_stale_pointer.patch	(revision 0)
@@ -0,0 +1,18 @@
+--- a/drivers/net/wireless/ath/ath9k/xmit.c
++++ b/drivers/net/wireless/ath/ath9k/xmit.c
+@@ -312,6 +312,7 @@ static struct ath_buf *ath_tx_get_buffer
+ 	}
+ 
+ 	bf = list_first_entry(&sc->tx.txbuf, struct ath_buf, list);
++	bf->bf_next = NULL;
+ 	list_del(&bf->list);
+ 
+ 	spin_unlock_bh(&sc->tx.txbuflock);
+@@ -1778,6 +1779,7 @@ static void ath_tx_send_normal(struct at
+ 	list_add_tail(&bf->list, &bf_head);
+ 	bf->bf_state.bf_type = 0;
+ 
++	bf->bf_next = NULL;
+ 	bf->bf_lastbf = bf;
+ 	ath_tx_fill_desc(sc, bf, txq, fi->framelen);
+ 	ath_tx_txqaddbuf(sc, txq, &bf_head, false);
Index: package/mac80211/patches/130-mesh_pathtbl_backport.patch
===================================================================
--- package/mac80211/patches/130-mesh_pathtbl_backport.patch	(revision 31639)
+++ package/mac80211/patches/130-mesh_pathtbl_backport.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/net/mac80211/mesh_pathtbl.c
 +++ b/net/mac80211/mesh_pathtbl.c
-@@ -826,7 +826,6 @@ static void table_flush_by_iface(struct 
+@@ -813,7 +813,6 @@ static void table_flush_by_iface(struct 
  	struct hlist_node *p;
  	int i;
  
Index: package/mac80211/patches/501-ath9k-eeprom_endianess.patch
===================================================================
--- package/mac80211/patches/501-ath9k-eeprom_endianess.patch	(revision 31639)
+++ package/mac80211/patches/501-ath9k-eeprom_endianess.patch	(working copy)
@@ -1,15 +1,15 @@
 --- a/drivers/net/wireless/ath/ath9k/eeprom_def.c
 +++ b/drivers/net/wireless/ath/ath9k/eeprom_def.c
-@@ -267,7 +267,7 @@ static int ath9k_hw_def_check_eeprom(str
- 	struct ar5416_eeprom_def *eep =
- 		(struct ar5416_eeprom_def *) &ah->eeprom.def;
+@@ -266,7 +266,7 @@ static int ath9k_hw_def_check_eeprom(str
+ {
+ 	struct ar5416_eeprom_def *eep = &ah->eeprom.def;
  	struct ath_common *common = ath9k_hw_common(ah);
 -	u16 *eepdata, temp, magic, magic2;
 +	u16 *eepdata, temp, magic;
  	u32 sum = 0, el;
  	bool need_swap = false;
  	int i, addr, size;
-@@ -277,27 +277,16 @@ static int ath9k_hw_def_check_eeprom(str
+@@ -276,27 +276,16 @@ static int ath9k_hw_def_check_eeprom(str
  		return false;
  	}
  
@@ -49,7 +49,7 @@
  
 --- a/drivers/net/wireless/ath/ath9k/eeprom_4k.c
 +++ b/drivers/net/wireless/ath/ath9k/eeprom_4k.c
-@@ -196,7 +196,7 @@ static int ath9k_hw_4k_check_eeprom(stru
+@@ -195,7 +195,7 @@ static int ath9k_hw_4k_check_eeprom(stru
  	int i, addr;
  
  
@@ -71,7 +71,7 @@
  			ath_err(common, "Reading Magic # failed\n");
 --- a/drivers/net/wireless/ath/ath9k/hw.h
 +++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -662,6 +662,7 @@ enum ath_cal_list {
+@@ -705,6 +705,7 @@ enum ath_cal_list {
  #define AH_USE_EEPROM   0x1
  #define AH_UNPLUGGED    0x2 /* The card has been physically removed. */
  #define AH_FASTCC       0x4
@@ -81,7 +81,7 @@
  	struct ath_ops reg_ops;
 --- a/drivers/net/wireless/ath/ath9k/init.c
 +++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -534,6 +534,8 @@ static int ath9k_init_softc(u16 devid, s
+@@ -537,6 +537,8 @@ static int ath9k_init_softc(u16 devid, s
  		ah->is_clk_25mhz = pdata->is_clk_25mhz;
  		ah->get_mac_revision = pdata->get_mac_revision;
  		ah->external_reset = pdata->external_reset;
Index: package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch
===================================================================
--- package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch	(revision 31639)
+++ package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath5k/pci.c
 +++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -22,6 +22,7 @@
+@@ -23,6 +23,7 @@
  #include <linux/pci-aspm.h>
  #include <linux/etherdevice.h>
  #include <linux/module.h>
@@ -8,7 +8,7 @@
  #include "../ath.h"
  #include "ath5k.h"
  #include "debug.h"
-@@ -73,7 +74,7 @@ static void ath5k_pci_read_cachesize(str
+@@ -74,7 +75,7 @@ static void ath5k_pci_read_cachesize(str
  }
  
  /*
@@ -17,7 +17,7 @@
   */
  static bool
  ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
-@@ -81,6 +82,19 @@ ath5k_pci_eeprom_read(struct ath_common 
+@@ -82,6 +83,19 @@ ath5k_pci_eeprom_read(struct ath_common 
  	struct ath5k_hw *ah = (struct ath5k_hw *) common->ah;
  	u32 status, timeout;
  
@@ -37,7 +37,7 @@
  	/*
  	 * Initialize EEPROM access
  	 */
-@@ -124,6 +138,16 @@ static int ath5k_pci_eeprom_read_mac(str
+@@ -125,6 +139,16 @@ static int ath5k_pci_eeprom_read_mac(str
  	u16 data;
  	int octet;
  
Index: package/mac80211/patches/531-ath9k_fix_initvals.patch
===================================================================
--- package/mac80211/patches/531-ath9k_fix_initvals.patch	(revision 31639)
+++ package/mac80211/patches/531-ath9k_fix_initvals.patch	(working copy)
@@ -1,208 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
-@@ -533,108 +533,108 @@ static const u32 ar9300_2p2_baseband_cor
- 
- static const u32 ar9300Modes_high_power_tx_gain_table_2p2[][5] = {
- 	/* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
--	{0x0000a2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
--	{0x0000a2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
--	{0x0000a2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
-+	{0x0000a2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
-+	{0x0000a2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
-+	{0x0000a2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
- 	{0x0000a2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
--	{0x0000a410, 0x000050d9, 0x000050d9, 0x000050d9, 0x000050d9},
--	{0x0000a500, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
--	{0x0000a504, 0x06000003, 0x06000003, 0x04000002, 0x04000002},
--	{0x0000a508, 0x0a000020, 0x0a000020, 0x08000004, 0x08000004},
--	{0x0000a50c, 0x10000023, 0x10000023, 0x0b000200, 0x0b000200},
--	{0x0000a510, 0x15000028, 0x15000028, 0x0f000202, 0x0f000202},
--	{0x0000a514, 0x1b00002b, 0x1b00002b, 0x12000400, 0x12000400},
--	{0x0000a518, 0x1f020028, 0x1f020028, 0x16000402, 0x16000402},
--	{0x0000a51c, 0x2502002b, 0x2502002b, 0x19000404, 0x19000404},
--	{0x0000a520, 0x2a04002a, 0x2a04002a, 0x1c000603, 0x1c000603},
--	{0x0000a524, 0x2e06002a, 0x2e06002a, 0x21000a02, 0x21000a02},
--	{0x0000a528, 0x3302202d, 0x3302202d, 0x25000a04, 0x25000a04},
--	{0x0000a52c, 0x3804202c, 0x3804202c, 0x28000a20, 0x28000a20},
--	{0x0000a530, 0x3c06202c, 0x3c06202c, 0x2c000e20, 0x2c000e20},
--	{0x0000a534, 0x4108202d, 0x4108202d, 0x30000e22, 0x30000e22},
--	{0x0000a538, 0x4506402d, 0x4506402d, 0x34000e24, 0x34000e24},
--	{0x0000a53c, 0x4906222d, 0x4906222d, 0x38001640, 0x38001640},
--	{0x0000a540, 0x4d062231, 0x4d062231, 0x3c001660, 0x3c001660},
--	{0x0000a544, 0x50082231, 0x50082231, 0x3f001861, 0x3f001861},
--	{0x0000a548, 0x5608422e, 0x5608422e, 0x43001a81, 0x43001a81},
--	{0x0000a54c, 0x5a08442e, 0x5a08442e, 0x47001a83, 0x47001a83},
--	{0x0000a550, 0x5e0a4431, 0x5e0a4431, 0x4a001c84, 0x4a001c84},
--	{0x0000a554, 0x640a4432, 0x640a4432, 0x4e001ce3, 0x4e001ce3},
--	{0x0000a558, 0x680a4434, 0x680a4434, 0x52001ce5, 0x52001ce5},
--	{0x0000a55c, 0x6c0a6434, 0x6c0a6434, 0x56001ce9, 0x56001ce9},
--	{0x0000a560, 0x6f0a6633, 0x6f0a6633, 0x5a001ceb, 0x5a001ceb},
--	{0x0000a564, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a568, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a56c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a570, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a574, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a578, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a57c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a580, 0x00800000, 0x00800000, 0x00800000, 0x00800000},
--	{0x0000a584, 0x06800003, 0x06800003, 0x04800002, 0x04800002},
--	{0x0000a588, 0x0a800020, 0x0a800020, 0x08800004, 0x08800004},
--	{0x0000a58c, 0x10800023, 0x10800023, 0x0b800200, 0x0b800200},
--	{0x0000a590, 0x15800028, 0x15800028, 0x0f800202, 0x0f800202},
--	{0x0000a594, 0x1b80002b, 0x1b80002b, 0x12800400, 0x12800400},
--	{0x0000a598, 0x1f820028, 0x1f820028, 0x16800402, 0x16800402},
--	{0x0000a59c, 0x2582002b, 0x2582002b, 0x19800404, 0x19800404},
--	{0x0000a5a0, 0x2a84002a, 0x2a84002a, 0x1c800603, 0x1c800603},
--	{0x0000a5a4, 0x2e86002a, 0x2e86002a, 0x21800a02, 0x21800a02},
--	{0x0000a5a8, 0x3382202d, 0x3382202d, 0x25800a04, 0x25800a04},
--	{0x0000a5ac, 0x3884202c, 0x3884202c, 0x28800a20, 0x28800a20},
--	{0x0000a5b0, 0x3c86202c, 0x3c86202c, 0x2c800e20, 0x2c800e20},
--	{0x0000a5b4, 0x4188202d, 0x4188202d, 0x30800e22, 0x30800e22},
--	{0x0000a5b8, 0x4586402d, 0x4586402d, 0x34800e24, 0x34800e24},
--	{0x0000a5bc, 0x4986222d, 0x4986222d, 0x38801640, 0x38801640},
--	{0x0000a5c0, 0x4d862231, 0x4d862231, 0x3c801660, 0x3c801660},
--	{0x0000a5c4, 0x50882231, 0x50882231, 0x3f801861, 0x3f801861},
--	{0x0000a5c8, 0x5688422e, 0x5688422e, 0x43801a81, 0x43801a81},
--	{0x0000a5cc, 0x5a88442e, 0x5a88442e, 0x47801a83, 0x47801a83},
--	{0x0000a5d0, 0x5e8a4431, 0x5e8a4431, 0x4a801c84, 0x4a801c84},
--	{0x0000a5d4, 0x648a4432, 0x648a4432, 0x4e801ce3, 0x4e801ce3},
--	{0x0000a5d8, 0x688a4434, 0x688a4434, 0x52801ce5, 0x52801ce5},
--	{0x0000a5dc, 0x6c8a6434, 0x6c8a6434, 0x56801ce9, 0x56801ce9},
--	{0x0000a5e0, 0x6f8a6633, 0x6f8a6633, 0x5a801ceb, 0x5a801ceb},
--	{0x0000a5e4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5e8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5ec, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5f0, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5f4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5f8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5fc, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
-+	{0x0000a410, 0x000050d8, 0x000050d8, 0x000050d9, 0x000050d9},
-+	{0x0000a500, 0x00002220, 0x00002220, 0x00000000, 0x00000000},
-+	{0x0000a504, 0x04002222, 0x04002222, 0x04000002, 0x04000002},
-+	{0x0000a508, 0x09002421, 0x09002421, 0x08000004, 0x08000004},
-+	{0x0000a50c, 0x0d002621, 0x0d002621, 0x0b000200, 0x0b000200},
-+	{0x0000a510, 0x13004620, 0x13004620, 0x0f000202, 0x0f000202},
-+	{0x0000a514, 0x19004a20, 0x19004a20, 0x11000400, 0x11000400},
-+	{0x0000a518, 0x1d004e20, 0x1d004e20, 0x15000402, 0x15000402},
-+	{0x0000a51c, 0x21005420, 0x21005420, 0x19000404, 0x19000404},
-+	{0x0000a520, 0x26005e20, 0x26005e20, 0x1b000603, 0x1b000603},
-+	{0x0000a524, 0x2b005e40, 0x2b005e40, 0x1f000a02, 0x1f000a02},
-+	{0x0000a528, 0x2f005e42, 0x2f005e42, 0x23000a04, 0x23000a04},
-+	{0x0000a52c, 0x33005e44, 0x33005e44, 0x26000a20, 0x26000a20},
-+	{0x0000a530, 0x38005e65, 0x38005e65, 0x2a000e20, 0x2a000e20},
-+	{0x0000a534, 0x3c005e69, 0x3c005e69, 0x2e000e22, 0x2e000e22},
-+	{0x0000a538, 0x40005e6b, 0x40005e6b, 0x31000e24, 0x31000e24},
-+	{0x0000a53c, 0x44005e6d, 0x44005e6d, 0x34001640, 0x34001640},
-+	{0x0000a540, 0x49005e72, 0x49005e72, 0x38001660, 0x38001660},
-+	{0x0000a544, 0x4e005eb2, 0x4e005eb2, 0x3b001861, 0x3b001861},
-+	{0x0000a548, 0x53005f12, 0x53005f12, 0x3e001a81, 0x3e001a81},
-+	{0x0000a54c, 0x59025eb2, 0x59025eb2, 0x42001a83, 0x42001a83},
-+	{0x0000a550, 0x5e025f12, 0x5e025f12, 0x44001c84, 0x44001c84},
-+	{0x0000a554, 0x61027f12, 0x61027f12, 0x48001ce3, 0x48001ce3},
-+	{0x0000a558, 0x6702bf12, 0x6702bf12, 0x4c001ce5, 0x4c001ce5},
-+	{0x0000a55c, 0x6b02bf14, 0x6b02bf14, 0x50001ce9, 0x50001ce9},
-+	{0x0000a560, 0x6f02bf16, 0x6f02bf16, 0x54001ceb, 0x54001ceb},
-+	{0x0000a564, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a568, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a56c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a570, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a574, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a578, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a57c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a580, 0x00802220, 0x00802220, 0x00800000, 0x00800000},
-+	{0x0000a584, 0x04802222, 0x04802222, 0x04800002, 0x04800002},
-+	{0x0000a588, 0x09802421, 0x09802421, 0x08800004, 0x08800004},
-+	{0x0000a58c, 0x0d802621, 0x0d802621, 0x0b800200, 0x0b800200},
-+	{0x0000a590, 0x13804620, 0x13804620, 0x0f800202, 0x0f800202},
-+	{0x0000a594, 0x19804a20, 0x19804a20, 0x11800400, 0x11800400},
-+	{0x0000a598, 0x1d804e20, 0x1d804e20, 0x15800402, 0x15800402},
-+	{0x0000a59c, 0x21805420, 0x21805420, 0x19800404, 0x19800404},
-+	{0x0000a5a0, 0x26805e20, 0x26805e20, 0x1b800603, 0x1b800603},
-+	{0x0000a5a4, 0x2b805e40, 0x2b805e40, 0x1f800a02, 0x1f800a02},
-+	{0x0000a5a8, 0x2f805e42, 0x2f805e42, 0x23800a04, 0x23800a04},
-+	{0x0000a5ac, 0x33805e44, 0x33805e44, 0x26800a20, 0x26800a20},
-+	{0x0000a5b0, 0x38805e65, 0x38805e65, 0x2a800e20, 0x2a800e20},
-+	{0x0000a5b4, 0x3c805e69, 0x3c805e69, 0x2e800e22, 0x2e800e22},
-+	{0x0000a5b8, 0x40805e6b, 0x40805e6b, 0x31800e24, 0x31800e24},
-+	{0x0000a5bc, 0x44805e6d, 0x44805e6d, 0x34801640, 0x34801640},
-+	{0x0000a5c0, 0x49805e72, 0x49805e72, 0x38801660, 0x38801660},
-+	{0x0000a5c4, 0x4e805eb2, 0x4e805eb2, 0x3b801861, 0x3b801861},
-+	{0x0000a5c8, 0x53805f12, 0x53805f12, 0x3e801a81, 0x3e801a81},
-+	{0x0000a5cc, 0x59825eb2, 0x59825eb2, 0x42801a83, 0x42801a83},
-+	{0x0000a5d0, 0x5e825f12, 0x5e825f12, 0x44801c84, 0x44801c84},
-+	{0x0000a5d4, 0x61827f12, 0x61827f12, 0x48801ce3, 0x48801ce3},
-+	{0x0000a5d8, 0x6782bf12, 0x6782bf12, 0x4c801ce5, 0x4c801ce5},
-+	{0x0000a5dc, 0x6b82bf14, 0x6b82bf14, 0x50801ce9, 0x50801ce9},
-+	{0x0000a5e0, 0x6f82bf16, 0x6f82bf16, 0x54801ceb, 0x54801ceb},
-+	{0x0000a5e4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5e8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5ec, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5f0, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5f4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5f8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5fc, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
- 	{0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- 	{0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
--	{0x0000a608, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
--	{0x0000a60c, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
--	{0x0000a610, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
--	{0x0000a614, 0x01804601, 0x01804601, 0x01404000, 0x01404000},
--	{0x0000a618, 0x01804601, 0x01804601, 0x01404501, 0x01404501},
--	{0x0000a61c, 0x01804601, 0x01804601, 0x02008501, 0x02008501},
--	{0x0000a620, 0x03408d02, 0x03408d02, 0x0280ca03, 0x0280ca03},
--	{0x0000a624, 0x0300cc03, 0x0300cc03, 0x03010c04, 0x03010c04},
--	{0x0000a628, 0x03410d04, 0x03410d04, 0x04014c04, 0x04014c04},
--	{0x0000a62c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
--	{0x0000a630, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
--	{0x0000a634, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
--	{0x0000a638, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
--	{0x0000a63c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
--	{0x0000b2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
--	{0x0000b2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
--	{0x0000b2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
-+	{0x0000a608, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
-+	{0x0000a60c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
-+	{0x0000a610, 0x00804000, 0x00804000, 0x00000000, 0x00000000},
-+	{0x0000a614, 0x00804201, 0x00804201, 0x01404000, 0x01404000},
-+	{0x0000a618, 0x0280c802, 0x0280c802, 0x01404501, 0x01404501},
-+	{0x0000a61c, 0x0280ca03, 0x0280ca03, 0x02008501, 0x02008501},
-+	{0x0000a620, 0x04c15104, 0x04c15104, 0x0280ca03, 0x0280ca03},
-+	{0x0000a624, 0x04c15305, 0x04c15305, 0x03010c04, 0x03010c04},
-+	{0x0000a628, 0x04c15305, 0x04c15305, 0x04014c04, 0x04014c04},
-+	{0x0000a62c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
-+	{0x0000a630, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
-+	{0x0000a634, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
-+	{0x0000a638, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
-+	{0x0000a63c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
-+	{0x0000b2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
-+	{0x0000b2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
-+	{0x0000b2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
- 	{0x0000b2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
--	{0x0000c2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
--	{0x0000c2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
--	{0x0000c2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
-+	{0x0000c2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
-+	{0x0000c2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
-+	{0x0000c2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
- 	{0x0000c2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
--	{0x00016044, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
--	{0x00016048, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
--	{0x00016068, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
--	{0x00016444, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
--	{0x00016448, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
--	{0x00016468, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
--	{0x00016844, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
--	{0x00016848, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
--	{0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
-+	{0x00016044, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
-+	{0x00016048, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
-+	{0x00016068, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
-+	{0x00016444, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
-+	{0x00016448, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
-+	{0x00016468, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
-+	{0x00016844, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
-+	{0x00016848, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
-+	{0x00016868, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
- };
- 
- static const u32 ar9300Modes_high_ob_db_tx_gain_table_2p2[][5] = {
Index: package/mac80211/patches/524-mac80211_configure_antenna_gain.patch
===================================================================
--- package/mac80211/patches/524-mac80211_configure_antenna_gain.patch	(revision 0)
+++ package/mac80211/patches/524-mac80211_configure_antenna_gain.patch	(revision 0)
@@ -0,0 +1,179 @@
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -851,6 +851,7 @@ enum ieee80211_smps_mode {
+  *	the CONF_PS flag is set.
+  *
+  * @power_level: requested transmit power (in dBm)
++ * @max_antenna_gain: maximum antenna gain adjusted by user config (in dBi)
+  *
+  * @channel: the channel to tune to
+  * @channel_type: the channel (HT) type
+@@ -870,6 +871,7 @@ struct ieee80211_conf {
+ 	u32 flags;
+ 	int power_level, dynamic_ps_timeout;
+ 	int max_sleep_period;
++	int max_antenna_gain;
+ 
+ 	u16 listen_interval;
+ 	u8 ps_dtim_period;
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -101,7 +101,7 @@ int ieee80211_hw_config(struct ieee80211
+ {
+ 	struct ieee80211_channel *chan;
+ 	int ret = 0;
+-	int power;
++	int power, ant_gain, max_power;
+ 	enum nl80211_channel_type channel_type;
+ 	u32 offchannel_flag;
+ 
+@@ -152,19 +152,31 @@ int ieee80211_hw_config(struct ieee80211
+ 		changed |= IEEE80211_CONF_CHANGE_SMPS;
+ 	}
+ 
+-	if (test_bit(SCAN_SW_SCANNING, &local->scanning) ||
+-	    test_bit(SCAN_ONCHANNEL_SCANNING, &local->scanning) ||
+-	    test_bit(SCAN_HW_SCANNING, &local->scanning) ||
+-	    !local->ap_power_level)
+-		power = chan->max_power;
+-	else
+-		power = min(chan->max_power, local->ap_power_level);
++	max_power = chan->max_reg_power;
++	if (!test_bit(SCAN_SW_SCANNING, &local->scanning) &&
++	    !test_bit(SCAN_ONCHANNEL_SCANNING, &local->scanning) &&
++	    !test_bit(SCAN_HW_SCANNING, &local->scanning) &&
++	    local->ap_power_level)
++		max_power = min(max_power, local->ap_power_level);
++
++	ant_gain = chan->max_antenna_gain;
++	if (local->user_antenna_gain > 0) {
++		if (local->user_antenna_gain > ant_gain) {
++			max_power -= local->user_antenna_gain - ant_gain;
++			ant_gain = 0;
++		} else
++			ant_gain -= local->user_antenna_gain;
++	}
++
++	power = min(chan->max_power, max_power);
+ 
+ 	if (local->user_power_level >= 0)
+ 		power = min(power, local->user_power_level);
+ 
+-	if (local->hw.conf.power_level != power) {
++	if (local->hw.conf.power_level != power ||
++		local->hw.conf.max_antenna_gain != ant_gain) {
+ 		changed |= IEEE80211_CONF_CHANGE_POWER;
++		local->hw.conf.max_antenna_gain = ant_gain;
+ 		local->hw.cur_power_level = power;
+ 		local->hw.conf.power_level = power;
+ 	}
+@@ -620,6 +632,7 @@ struct ieee80211_hw *ieee80211_alloc_hw(
+ 					 IEEE80211_RADIOTAP_MCS_HAVE_GI |
+ 					 IEEE80211_RADIOTAP_MCS_HAVE_BW;
+ 	local->user_power_level = -1;
++	local->user_antenna_gain = -1;
+ 	wiphy->ht_capa_mod_mask = &mac80211_ht_capa_mod_mask;
+ 
+ 	INIT_LIST_HEAD(&local->interfaces);
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -1063,6 +1063,7 @@ struct ieee80211_local {
+ 
+ 	int user_power_level; /* in dBm */
+ 	int ap_power_level; /* in dBm */
++	int user_antenna_gain; /* in dBi */
+ 
+ 	enum ieee80211_smps_mode smps_mode;
+ 
+--- a/include/linux/nl80211.h
++++ b/include/linux/nl80211.h
+@@ -1517,6 +1517,8 @@ enum nl80211_attrs {
+ 
+ 	NL80211_ATTR_USER_REG_HINT_TYPE,
+ 
++	NL80211_ATTR_WIPHY_ANTENNA_GAIN,
++
+ 	/* add attributes here, update the policy in nl80211.c */
+ 
+ 	__NL80211_ATTR_AFTER_LAST,
+--- a/net/wireless/nl80211.c
++++ b/net/wireless/nl80211.c
+@@ -355,6 +355,7 @@ static const struct nla_policy nl80211_p
+ 	[NL80211_ATTR_BG_SCAN_PERIOD] = { .type = NLA_U16 },
+ 	[NL80211_ATTR_WDEV] = { .type = NLA_U64 },
+ 	[NL80211_ATTR_USER_REG_HINT_TYPE] = { .type = NLA_U32 },
++	[NL80211_ATTR_WIPHY_ANTENNA_GAIN] = { .type = NLA_U32 },
+ };
+ 
+ /* policy for the key attributes */
+@@ -1604,6 +1605,22 @@ static int nl80211_set_wiphy(struct sk_b
+ 			goto bad_res;
+ 	}
+ 
++	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_GAIN]) {
++		int idx, dbi = 0;
++
++		if (!rdev->ops->set_antenna_gain) {
++			result = -EOPNOTSUPP;
++			goto bad_res;
++		}
++
++		idx = NL80211_ATTR_WIPHY_ANTENNA_GAIN;
++		dbi = nla_get_u32(info->attrs[idx]);
++
++		result = rdev->ops->set_antenna_gain(&rdev->wiphy, dbi);
++		if (result)
++			goto bad_res;
++	}
++
+ 	if (info->attrs[NL80211_ATTR_WIPHY_ANTENNA_TX] &&
+ 	    info->attrs[NL80211_ATTR_WIPHY_ANTENNA_RX]) {
+ 		u32 tx_ant, rx_ant;
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -1984,6 +1984,19 @@ static int ieee80211_get_tx_power(struct
+ 	return 0;
+ }
+ 
++static int ieee80211_set_antenna_gain(struct wiphy *wiphy, int dbi)
++{
++	struct ieee80211_local *local = wiphy_priv(wiphy);
++
++	if (dbi < 0)
++		return -EINVAL;
++
++	local->user_antenna_gain = dbi;
++	ieee80211_hw_config(local, 0);
++
++	return 0;
++}
++
+ static int ieee80211_set_wds_peer(struct wiphy *wiphy, struct net_device *dev,
+ 				  const u8 *addr)
+ {
+@@ -3085,6 +3098,7 @@ struct cfg80211_ops mac80211_config_ops 
+ 	.set_wiphy_params = ieee80211_set_wiphy_params,
+ 	.set_tx_power = ieee80211_set_tx_power,
+ 	.get_tx_power = ieee80211_get_tx_power,
++	.set_antenna_gain = ieee80211_set_antenna_gain,
+ 	.set_wds_peer = ieee80211_set_wds_peer,
+ 	.rfkill_poll = ieee80211_rfkill_poll,
+ 	CFG80211_TESTMODE_CMD(ieee80211_testmode_cmd)
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -1552,6 +1552,7 @@ struct cfg80211_gtk_rekey_data {
+  *	the power passed is in mBm, to get dBm use MBM_TO_DBM().
+  * @get_tx_power: store the current TX power into the dbm variable;
+  *	return 0 if successful
++ * @set_antenna_gain: set antenna gain to reduce maximum tx power if necessary
+  *
+  * @set_wds_peer: set the WDS peer for a WDS interface
+  *
+@@ -1751,6 +1752,7 @@ struct cfg80211_ops {
+ 	int	(*set_tx_power)(struct wiphy *wiphy,
+ 				enum nl80211_tx_power_setting type, int mbm);
+ 	int	(*get_tx_power)(struct wiphy *wiphy, int *dbm);
++	int	(*set_antenna_gain)(struct wiphy *wiphy, int dbi);
+ 
+ 	int	(*set_wds_peer)(struct wiphy *wiphy, struct net_device *dev,
+ 				const u8 *addr);
Index: package/mac80211/patches/006-disable_bcma_build.patch
===================================================================
--- package/mac80211/patches/006-disable_bcma_build.patch	(revision 31639)
+++ package/mac80211/patches/006-disable_bcma_build.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/Makefile
 +++ b/Makefile
-@@ -29,7 +29,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
+@@ -45,7 +45,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
  
  obj-$(CONFIG_COMPAT_NET_USB_MODULES) += drivers/net/usb/
  
@@ -10,7 +10,7 @@
  ifeq ($(CONFIG_STAGING_EXCLUDE_BUILD),)
 --- a/config.mk
 +++ b/config.mk
-@@ -354,12 +354,12 @@ export CONFIG_SSB_DRIVER_PCICORE=y
+@@ -369,12 +369,12 @@ export CONFIG_SSB_DRIVER_PCICORE=y
  export CONFIG_B43_SSB=y
  endif #__CONFIG_SSB
  
Index: package/mac80211/patches/600-rt2x00-disable-pci-code-if-CONFIG_PCI-not-defined.patch
===================================================================
--- package/mac80211/patches/600-rt2x00-disable-pci-code-if-CONFIG_PCI-not-defined.patch	(revision 31639)
+++ package/mac80211/patches/600-rt2x00-disable-pci-code-if-CONFIG_PCI-not-defined.patch	(working copy)
@@ -8,7 +8,7 @@
  /*
   * PCI driver handlers.
   */
-@@ -383,6 +384,7 @@ int rt2x00pci_resume(struct pci_dev *pci
+@@ -392,6 +393,7 @@ int rt2x00pci_resume(struct pci_dev *pci
  }
  EXPORT_SYMBOL_GPL(rt2x00pci_resume);
  #endif /* CONFIG_PM */
Index: package/mac80211/patches/404-world_regd_fixup.patch
===================================================================
--- package/mac80211/patches/404-world_regd_fixup.patch	(revision 31639)
+++ package/mac80211/patches/404-world_regd_fixup.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/regd.c
 +++ b/drivers/net/wireless/ath/regd.c
-@@ -43,7 +43,8 @@ static int __ath_regd_init(struct ath_re
+@@ -44,7 +44,8 @@ static int __ath_regd_init(struct ath_re
  				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
  
  /* We allow IBSS on these on a case by case basis by regulatory domain */
@@ -10,7 +10,7 @@
  				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
  #define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 40, 0, 30,\
  				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-@@ -61,57 +62,56 @@ static int __ath_regd_init(struct ath_re
+@@ -62,57 +63,56 @@ static int __ath_regd_init(struct ath_re
  #define ATH9K_5GHZ_NO_MIDBAND	ATH9K_5GHZ_5150_5350, \
  				ATH9K_5GHZ_5725_5850
  
Index: package/mac80211/patches/849-brcmsmac-add-device-found-on-some-SoCs-like-the-bcm4.patch
===================================================================
--- package/mac80211/patches/849-brcmsmac-add-device-found-on-some-SoCs-like-the-bcm4.patch	(revision 0)
+++ package/mac80211/patches/849-brcmsmac-add-device-found-on-some-SoCs-like-the-bcm4.patch	(revision 0)
@@ -0,0 +1,39 @@
+--- a/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
+@@ -94,6 +94,7 @@ MODULE_FIRMWARE("brcm/bcm43xx_hdr-0.fw")
+ 
+ /* recognized BCMA Core IDs */
+ static struct bcma_device_id brcms_coreid_table[] = {
++//	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 17, BCMA_ANY_CLASS),
+ 	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 23, BCMA_ANY_CLASS),
+ 	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 24, BCMA_ANY_CLASS),
+ 	BCMA_CORETABLE_END
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.c
+@@ -734,7 +734,7 @@ static void brcms_c_ucode_bsinit(struct 
+ 	brcms_c_write_mhf(wlc_hw, wlc_hw->band->mhfs);
+ 
+ 	/* do band-specific ucode IHR, SHM, and SCR inits */
+-	if (D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band))
+ 			brcms_c_write_inits(wlc_hw, ucode->d11n0bsinitvals16);
+ 		else
+@@ -2259,7 +2259,7 @@ static void brcms_ucode_download(struct 
+ 	if (wlc_hw->ucode_loaded)
+ 		return;
+ 
+-	if (D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band)) {
+ 			brcms_ucode_write(wlc_hw, ucode->bcm43xx_16_mimo,
+ 					  ucode->bcm43xx_16_mimosz);
+@@ -3221,7 +3221,7 @@ static void brcms_b_coreinit(struct brcm
+ 
+ 	sflags = bcma_aread32(core, BCMA_IOST);
+ 
+-	if (D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band))
+ 			brcms_c_write_inits(wlc_hw, ucode->d11n0initvals16);
+ 		else
Index: package/mac80211/patches/522-ath9k_per_chain_signal_strength.patch
===================================================================
--- package/mac80211/patches/522-ath9k_per_chain_signal_strength.patch	(revision 31639)
+++ package/mac80211/patches/522-ath9k_per_chain_signal_strength.patch	(working copy)
@@ -1,29 +1,27 @@
 --- a/include/net/mac80211.h
 +++ b/include/net/mac80211.h
-@@ -693,6 +693,9 @@ enum mac80211_rx_flags {
-  * @mactime: value in microseconds of the 64-bit Time Synchronization Function
-  * 	(TSF) timer when the first data symbol (MPDU) arrived at the hardware.
-  * @band: the active band when this frame was received
+@@ -729,6 +729,9 @@ enum mac80211_rx_flags {
+  * @signal: signal strength when receiving this frame, either in dBm, in dB or
+  *	unspecified depending on the hardware capabilities flags
+  *	@IEEE80211_HW_SIGNAL_*
 + * @chains: bitmask of receive chains for which separate signal strength
 + *	values were filled.
 + * @chain_signal: per-chain signal strength, same format as @signal
-  * @freq: frequency the radio was tuned to when receiving this frame, in MHz
-  * @signal: signal strength when receiving this frame, either in dBm, in dB or
-  *	unspecified depending on the hardware capabilities flags
-@@ -706,6 +709,10 @@ enum mac80211_rx_flags {
- struct ieee80211_rx_status {
- 	u64 mactime;
- 	enum ieee80211_band band;
-+
+  * @antenna: antenna used
+  * @rate_idx: index of data rate into band's supported rates or MCS index if
+  *	HT rates are use (RX_FLAG_HT)
+@@ -749,6 +752,8 @@ struct ieee80211_rx_status {
+ 	u8 band;
+ 	u8 antenna;
+ 	s8 signal;
 +	u8 chains;
 +	s8 chain_signal[4];
-+
- 	int freq;
- 	int signal;
- 	int antenna;
+ 	u8 ampdu_delimiter_crc;
+ };
+ 
 --- a/net/mac80211/sta_info.h
 +++ b/net/mac80211/sta_info.h
-@@ -320,6 +320,11 @@ struct sta_info {
+@@ -325,6 +325,11 @@ struct sta_info {
  	unsigned long rx_dropped;
  	int last_signal;
  	struct ewma avg_signal;
@@ -37,7 +35,7 @@
  
 --- a/net/mac80211/rx.c
 +++ b/net/mac80211/rx.c
-@@ -1262,6 +1262,7 @@ ieee80211_rx_h_sta_process(struct ieee80
+@@ -1271,6 +1271,7 @@ ieee80211_rx_h_sta_process(struct ieee80
  	struct sk_buff *skb = rx->skb;
  	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
  	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
@@ -45,7 +43,7 @@
  
  	if (!sta)
  		return RX_CONTINUE;
-@@ -1306,6 +1307,19 @@ ieee80211_rx_h_sta_process(struct ieee80
+@@ -1315,6 +1316,19 @@ ieee80211_rx_h_sta_process(struct ieee80
  		ewma_add(&sta->avg_signal, -status->signal);
  	}
  
@@ -67,7 +65,7 @@
  	 * exchange sequence.
 --- a/net/mac80211/sta_info.c
 +++ b/net/mac80211/sta_info.c
-@@ -256,6 +256,8 @@ struct sta_info *sta_info_alloc(struct i
+@@ -254,6 +254,8 @@ struct sta_info *sta_info_alloc(struct i
  	do_posix_clock_monotonic_gettime(&uptime);
  	sta->last_connected = uptime.tv_sec;
  	ewma_init(&sta->avg_signal, 1024, 8);
@@ -78,7 +76,7 @@
  		kfree(sta);
 --- a/include/net/cfg80211.h
 +++ b/include/net/cfg80211.h
-@@ -522,6 +522,8 @@ struct station_parameters {
+@@ -549,6 +549,8 @@ struct station_parameters {
   * @STATION_INFO_STA_FLAGS: @sta_flags filled
   * @STATION_INFO_BEACON_LOSS_COUNT: @beacon_loss_count filled
   * @STATION_INFO_T_OFFSET: @t_offset filled
@@ -87,7 +85,7 @@
   */
  enum station_info_flags {
  	STATION_INFO_INACTIVE_TIME	= 1<<0,
-@@ -545,6 +547,8 @@ enum station_info_flags {
+@@ -572,6 +574,8 @@ enum station_info_flags {
  	STATION_INFO_STA_FLAGS		= 1<<18,
  	STATION_INFO_BEACON_LOSS_COUNT	= 1<<19,
  	STATION_INFO_T_OFFSET		= 1<<20,
@@ -96,17 +94,17 @@
  };
  
  /**
-@@ -626,6 +630,9 @@ struct sta_bss_parameters {
- 	NOTE: For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
-  * @signal_avg: avg signal strength, type depends on the wiphy's signal_type
- 	NOTE: For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
+@@ -655,6 +659,9 @@ struct sta_bss_parameters {
+  *	For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
+  * @signal_avg: Average signal strength, type depends on the wiphy's signal_type.
+  *	For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
 + * @chains: bitmask for filled values in @chain_signal, @chain_signal_avg
 + * @chain_signal: per-chain signal strength of last received packet in dBm
 + * @chain_signal_avg: per-chain signal strength average in dBm
   * @txrate: current unicast bitrate from this station
   * @rxrate: current unicast bitrate to this station
   * @rx_packets: packets received from this station
-@@ -658,6 +665,11 @@ struct station_info {
+@@ -687,6 +694,11 @@ struct station_info {
  	u8 plink_state;
  	s8 signal;
  	s8 signal_avg;
@@ -137,7 +135,7 @@
  	u8 rs_num_delims;
 --- a/drivers/net/wireless/ath/ath9k/recv.c
 +++ b/drivers/net/wireless/ath/ath9k/recv.c
-@@ -988,6 +988,7 @@ static int ath9k_rx_skb_preprocess(struc
+@@ -955,6 +955,7 @@ static int ath9k_rx_skb_preprocess(struc
  				   bool *decrypt_error)
  {
  	struct ath_hw *ah = common->ah;
@@ -145,7 +143,7 @@
  
  	/*
  	 * everything but the rate is checked here, the rate check is done
-@@ -1013,6 +1014,20 @@ static int ath9k_rx_skb_preprocess(struc
+@@ -980,6 +981,20 @@ static int ath9k_rx_skb_preprocess(struc
  	if (rx_stats->rs_moreaggr)
  		rx_status->flag |= RX_FLAG_NO_SIGNAL_VAL;
  
@@ -166,28 +164,9 @@
  	return 0;
  }
  
-@@ -1543,14 +1558,14 @@ static void ath_ant_comb_scan(struct ath
- 	struct ath_ant_comb *antcomb = &sc->ant_comb;
- 	int alt_ratio = 0, alt_rssi_avg = 0, main_rssi_avg = 0, curr_alt_set;
- 	int curr_main_set;
--	int main_rssi = rs->rs_rssi_ctl0;
--	int alt_rssi = rs->rs_rssi_ctl1;
-+	int main_rssi = rs->rs_rssi_ctl[0];
-+	int alt_rssi = rs->rs_rssi_ctl[1];
- 	int rx_ant_conf,  main_ant_conf;
- 	bool short_scan = false;
- 
--	rx_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_CURRENT_SHIFT) &
-+	rx_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_CURRENT_SHIFT) &
- 		       ATH_ANT_RX_MASK;
--	main_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_MAIN_SHIFT) &
-+	main_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_MAIN_SHIFT) &
- 			 ATH_ANT_RX_MASK;
- 
- 	/* Record packet only when both main_rssi and  alt_rssi is positive */
 --- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
 +++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
-@@ -455,12 +455,12 @@ int ath9k_hw_process_rxdesc_edma(struct 
+@@ -458,12 +458,12 @@ int ath9k_hw_process_rxdesc_edma(struct 
  
  	/* XXX: Keycache */
  	rxs->rs_rssi = MS(rxsp->status5, AR_RxRSSICombined);
@@ -269,7 +248,7 @@
  	RX_SAMP_DBG(rate) = rs->rs_rate;
 --- a/include/linux/nl80211.h
 +++ b/include/linux/nl80211.h
-@@ -1693,6 +1693,8 @@ enum nl80211_sta_bss_param {
+@@ -1760,6 +1760,8 @@ enum nl80211_sta_bss_param {
   * @NL80211_STA_INFO_STA_FLAGS: Contains a struct nl80211_sta_flag_update.
   * @NL80211_STA_INFO_BEACON_LOSS: count of times beacon loss was detected (u32)
   * @NL80211_STA_INFO_T_OFFSET: timing offset with respect to this STA (s64)
@@ -278,7 +257,7 @@
   * @__NL80211_STA_INFO_AFTER_LAST: internal
   * @NL80211_STA_INFO_MAX: highest possible station info attribute
   */
-@@ -1717,6 +1719,8 @@ enum nl80211_sta_info {
+@@ -1784,6 +1786,8 @@ enum nl80211_sta_info {
  	NL80211_STA_INFO_STA_FLAGS,
  	NL80211_STA_INFO_BEACON_LOSS,
  	NL80211_STA_INFO_T_OFFSET,
@@ -289,7 +268,7 @@
  	__NL80211_STA_INFO_AFTER_LAST,
 --- a/net/wireless/nl80211.c
 +++ b/net/wireless/nl80211.c
-@@ -2406,6 +2406,33 @@ nla_put_failure:
+@@ -2769,6 +2769,32 @@ nla_put_failure:
  	return false;
  }
  
@@ -304,26 +283,25 @@
 +
 +	attr = nla_nest_start(msg, id);
 +	if (!attr)
-+		goto nla_put_failure;
++		return false;
 +
 +	for (i = 0; i < 4; i++) {
 +		if (!(mask & BIT(i)))
 +			continue;
 +
-+		NLA_PUT_U8(msg, i, signal[i]);
++		if (nla_put_u8(msg, i, signal[i]))
++			return false;
 +	}
 +
 +	nla_nest_end(msg, attr);
 +
 +	return true;
-+nla_put_failure:
-+	return false;
 +}
 +
  static int nl80211_send_station(struct sk_buff *msg, u32 pid, u32 seq,
  				int flags,
  				struct cfg80211_registered_device *rdev,
-@@ -2460,6 +2487,18 @@ static int nl80211_send_station(struct s
+@@ -2830,6 +2856,18 @@ static int nl80211_send_station(struct s
  	default:
  		break;
  	}
@@ -344,16 +322,16 @@
  					  NL80211_STA_INFO_TX_BITRATE))
 --- a/net/mac80211/cfg.c
 +++ b/net/mac80211/cfg.c
-@@ -354,6 +354,7 @@ static void sta_set_sinfo(struct sta_inf
- {
+@@ -367,6 +367,7 @@ static void sta_set_sinfo(struct sta_inf
  	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct ieee80211_local *local = sdata->local;
  	struct timespec uptime;
 +	int i;
  
  	sinfo->generation = sdata->local->sta_generation;
  
-@@ -391,6 +392,17 @@ static void sta_set_sinfo(struct sta_inf
- 		sinfo->signal = (s8)sta->last_signal;
+@@ -406,6 +407,17 @@ static void sta_set_sinfo(struct sta_inf
+ 			sinfo->signal = (s8)sta->last_signal;
  		sinfo->signal_avg = (s8) -ewma_read(&sta->avg_signal);
  	}
 +	if (sta->chains) {
@@ -370,3 +348,37 @@
  
  	sta_set_rate_info_tx(sta, &sta->last_tx_rate, &sinfo->txrate);
  
+--- a/drivers/net/wireless/ath/ath9k/dfs.c
++++ b/drivers/net/wireless/ath/ath9k/dfs.c
+@@ -164,8 +164,8 @@ void ath9k_dfs_process_phyerr(struct ath
+ 		return;
+ 	}
+ 
+-	ard.rssi = rs->rs_rssi_ctl0;
+-	ard.ext_rssi = rs->rs_rssi_ext0;
++	ard.rssi = rs->rs_rssi_ctl[0];
++	ard.ext_rssi = rs->rs_rssi_ext[0];
+ 
+ 	/*
+ 	 * hardware stores this as 8 bit signed value.
+--- a/drivers/net/wireless/ath/ath9k/antenna.c
++++ b/drivers/net/wireless/ath/ath9k/antenna.c
+@@ -529,14 +529,14 @@ void ath_ant_comb_scan(struct ath_softc 
+ 	struct ath_ant_comb *antcomb = &sc->ant_comb;
+ 	int alt_ratio = 0, alt_rssi_avg = 0, main_rssi_avg = 0, curr_alt_set;
+ 	int curr_main_set;
+-	int main_rssi = rs->rs_rssi_ctl0;
+-	int alt_rssi = rs->rs_rssi_ctl1;
++	int main_rssi = rs->rs_rssi_ctl[0];
++	int alt_rssi = rs->rs_rssi_ctl[1];
+ 	int rx_ant_conf,  main_ant_conf;
+ 	bool short_scan = false;
+ 
+-	rx_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_CURRENT_SHIFT) &
++	rx_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_CURRENT_SHIFT) &
+ 		       ATH_ANT_RX_MASK;
+-	main_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_MAIN_SHIFT) &
++	main_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_MAIN_SHIFT) &
+ 			 ATH_ANT_RX_MASK;
+ 
+ 	/* Record packet only when both main_rssi and  alt_rssi is positive */
Index: package/mac80211/patches/023-ath9k_disable_btcoex.patch
===================================================================
--- package/mac80211/patches/023-ath9k_disable_btcoex.patch	(revision 31639)
+++ package/mac80211/patches/023-ath9k_disable_btcoex.patch	(working copy)
@@ -1,11 +1,11 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -263,7 +263,7 @@ export CONFIG_ATH9K_COMMON=m
+@@ -267,7 +267,7 @@ export CONFIG_ATH9K_COMMON=m
  # for long range considerations.
  # export CONFIG_COMPAT_ATH9K_RATE_CONTROL=y
  
 -export CONFIG_ATH9K_BTCOEX_SUPPORT=y
 +# export CONFIG_ATH9K_BTCOEX_SUPPORT=y
  
- # PCI Drivers
- ifdef CONFIG_PCI
+ # WIL6210 requires MSI only available >= 2.6.30
+ ifndef CONFIG_COMPAT_KERNEL_2_6_30
Index: package/mac80211/patches/060-compat_add_module_pci_driver.patch
===================================================================
--- package/mac80211/patches/060-compat_add_module_pci_driver.patch	(revision 31639)
+++ package/mac80211/patches/060-compat_add_module_pci_driver.patch	(working copy)
@@ -1,8 +1,8 @@
 --- a/include/linux/compat-3.4.h
 +++ b/include/linux/compat-3.4.h
-@@ -62,6 +62,19 @@ static inline void eth_hw_addr_random(st
- #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,31)) */
- #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)) */
+@@ -112,6 +112,19 @@ static inline void eth_hw_addr_random(st
+ 	module_driver(__pci_driver, pci_register_driver, \
+ 		       pci_unregister_driver)
  
 +/* source include/linux/pci.h */
 +/**
Index: package/mac80211/patches/890_ath9k_advertize_beacon_int_infra_match.patch
===================================================================
--- package/mac80211/patches/890_ath9k_advertize_beacon_int_infra_match.patch	(revision 0)
+++ package/mac80211/patches/890_ath9k_advertize_beacon_int_infra_match.patch	(revision 0)
@@ -0,0 +1,12 @@
+diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c
+index fad3ccd..546bae9 100644
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -687,6 +687,7 @@  static const struct ieee80211_iface_combination if_comb = {
+ 	.n_limits = ARRAY_SIZE(if_limits),
+ 	.max_interfaces = 2048,
+ 	.num_different_channels = 1,
++	.beacon_int_infra_match = true,
+ };
+ 
+ void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
Index: package/mac80211/patches/001-disable_b44.patch
===================================================================
--- package/mac80211/patches/001-disable_b44.patch	(revision 31639)
+++ package/mac80211/patches/001-disable_b44.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -362,8 +362,8 @@ export CONFIG_B43_BCMA_EXTRA=y
+@@ -377,8 +377,8 @@ export CONFIG_B43_BCMA_EXTRA=y
  
  export CONFIG_P54_PCI=m
  
Index: package/mac80211/patches/525-ath9k_use_configured_antenna_gain.patch
===================================================================
--- package/mac80211/patches/525-ath9k_use_configured_antenna_gain.patch	(revision 0)
+++ package/mac80211/patches/525-ath9k_use_configured_antenna_gain.patch	(revision 0)
@@ -0,0 +1,34 @@
+--- a/drivers/net/wireless/ath/ath.h
++++ b/drivers/net/wireless/ath/ath.h
+@@ -73,6 +73,7 @@ struct ath_regulatory {
+ 	u16 max_power_level;
+ 	u16 current_rd;
+ 	int16_t power_limit;
++	int16_t max_antenna_gain;
+ 	struct reg_dmn_pair_mapping *regpair;
+ };
+ 
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -2828,7 +2828,7 @@ void ath9k_hw_apply_txpower(struct ath_h
+ 	channel = chan->chan;
+ 	chan_pwr = min_t(int, channel->max_power * 2, MAX_RATE_POWER);
+ 	new_pwr = min_t(int, chan_pwr, reg->power_limit);
+-	max_gain = chan_pwr - new_pwr + channel->max_antenna_gain * 2;
++	max_gain = chan_pwr - new_pwr + reg->max_antenna_gain * 2;
+ 
+ 	ant_gain = get_antenna_gain(ah, chan);
+ 	if (ant_gain > max_gain)
+--- a/drivers/net/wireless/ath/ath9k/main.c
++++ b/drivers/net/wireless/ath/ath9k/main.c
+@@ -1263,7 +1263,10 @@ int ath9k_config(struct ieee80211_hw *hw
+ 	}
+ 
+ 	if (changed & IEEE80211_CONF_CHANGE_POWER) {
++		struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
++
+ 		ath_dbg(common, CONFIG, "Set power: %d\n", conf->power_level);
++		reg->max_antenna_gain = conf->max_antenna_gain;
+ 		sc->config.txpowlimit = 2 * conf->power_level;
+ 		ath9k_cmn_update_txpow(ah, sc->curtxpow,
+ 				       sc->config.txpowlimit, &sc->curtxpow);
Index: package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch
===================================================================
--- package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch	(revision 31639)
+++ package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
 +++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-@@ -86,13 +86,8 @@ ath5k_add_interface(struct ieee80211_hw 
+@@ -89,13 +89,8 @@ ath5k_add_interface(struct ieee80211_hw 
  		goto end;
  	}
  
@@ -18,7 +18,7 @@
  		goto end;
 --- a/drivers/net/wireless/ath/ath5k/base.c
 +++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -1871,7 +1871,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
+@@ -1878,7 +1878,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
  	}
  
  	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
@@ -27,7 +27,7 @@
  			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
  		u64 tsf = ath5k_hw_get_tsf64(ah);
  		u32 tsftu = TSF_TO_TU(tsf);
-@@ -1957,7 +1957,7 @@ ath5k_beacon_update_timers(struct ath5k_
+@@ -1964,7 +1964,7 @@ ath5k_beacon_update_timers(struct ath5k_
  
  	intval = ah->bintval & AR5K_BEACON_PERIOD;
  	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
@@ -36,7 +36,7 @@
  		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
  		if (intval < 15)
  			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
-@@ -2422,6 +2422,7 @@ static const struct ieee80211_iface_limi
+@@ -2427,6 +2427,7 @@ static const struct ieee80211_iface_limi
  #ifdef CONFIG_MAC80211_MESH
  				 BIT(NL80211_IFTYPE_MESH_POINT) |
  #endif
Index: package/mac80211/patches/100-disable_pcmcia_compat.patch
===================================================================
--- package/mac80211/patches/100-disable_pcmcia_compat.patch	(revision 31639)
+++ package/mac80211/patches/100-disable_pcmcia_compat.patch	(working copy)
@@ -11,16 +11,16 @@
  struct pcmcia_cfg_mem {
 --- a/compat/compat-2.6.33.c
 +++ b/compat/compat-2.6.33.c
-@@ -11,7 +11,7 @@
+@@ -10,7 +10,7 @@
+ 
  #include <linux/compat.h>
- #include <linux/autoconf.h>
  
 -#if defined(CONFIG_PCCARD) || defined(CONFIG_PCCARD_MODULE)
 +#if 0
  
  /**
   * pccard_loop_tuple() - loop over tuples in the CIS
-@@ -73,7 +73,7 @@ next_entry:
+@@ -72,7 +72,7 @@ next_entry:
  EXPORT_SYMBOL_GPL(pccard_loop_tuple);
  /* Source: drivers/pcmcia/cistpl.c */
  
@@ -31,7 +31,7 @@
  	struct pcmcia_device *p_dev;
 --- a/include/linux/compat-2.6.28.h
 +++ b/include/linux/compat-2.6.28.h
-@@ -48,7 +48,7 @@ typedef u32 phys_addr_t;
+@@ -49,7 +49,7 @@ typedef u32 phys_addr_t;
  })
  #endif /* From include/asm-generic/bug.h */
  
@@ -51,7 +51,7 @@
  #include <pcmcia/cs_types.h>
  #include <pcmcia/cistpl.h>
  #include <pcmcia/ds.h>
-@@ -74,9 +74,9 @@ static inline struct sk_buff *netdev_all
+@@ -82,9 +82,9 @@ static inline struct sk_buff *netdev_all
  	return skb;
  }
  
Index: package/mac80211/patches/021-add_include_for_bcma.patch
===================================================================
--- package/mac80211/patches/021-add_include_for_bcma.patch	(revision 31639)
+++ package/mac80211/patches/021-add_include_for_bcma.patch	(working copy)
@@ -1,8 +1,8 @@
 --- a/include/linux/compat-3.0.h
 +++ b/include/linux/compat-3.0.h
-@@ -7,6 +7,8 @@
+@@ -36,6 +36,8 @@ static inline struct page *shmem_read_ma
+ #endif
  
- #include <linux/rcupdate.h>
  
 +#include <linux/mod_devicetable.h>
 +
Index: package/mac80211/patches/420-ath5k_disable_fast_cc.patch
===================================================================
--- package/mac80211/patches/420-ath5k_disable_fast_cc.patch	(revision 31639)
+++ package/mac80211/patches/420-ath5k_disable_fast_cc.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath5k/reset.c
 +++ b/drivers/net/wireless/ath/ath5k/reset.c
-@@ -1155,6 +1155,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
+@@ -1156,6 +1156,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
  	tsf_lo = 0;
  	mode = 0;
  
@@ -8,7 +8,7 @@
  	/*
  	 * Sanity check for fast flag
  	 * Fast channel change only available
-@@ -1162,6 +1163,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
+@@ -1163,6 +1164,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
  	 */
  	if (fast && (ah->ah_radio != AR5K_RF2413) &&
  	(ah->ah_radio != AR5K_RF5413))
Index: package/mac80211/patches/008-disable_mesh.patch
===================================================================
--- package/mac80211/patches/008-disable_mesh.patch	(revision 31639)
+++ package/mac80211/patches/008-disable_mesh.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -175,7 +175,7 @@ export CONFIG_MAC80211_LEDS=y
+@@ -177,7 +177,7 @@ export CONFIG_MAC80211_LEDS=y
  endif #CONFIG_LEDS_TRIGGERS
  
  # enable mesh networking too
Index: package/mac80211/patches/403-ath_regd_optional.patch
===================================================================
--- package/mac80211/patches/403-ath_regd_optional.patch	(revision 31639)
+++ package/mac80211/patches/403-ath_regd_optional.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/regd.c
 +++ b/drivers/net/wireless/ath/regd.c
-@@ -199,6 +199,10 @@ ath_reg_apply_beaconing_flags(struct wip
+@@ -200,6 +200,10 @@ ath_reg_apply_beaconing_flags(struct wip
  	u32 bandwidth = 0;
  	int r;
  
@@ -11,7 +11,7 @@
  	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
  
  		if (!wiphy->bands[band])
-@@ -258,6 +262,10 @@ ath_reg_apply_active_scan_flags(struct w
+@@ -259,6 +263,10 @@ ath_reg_apply_active_scan_flags(struct w
  	u32 bandwidth = 0;
  	int r;
  
@@ -22,7 +22,7 @@
  	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
  	if (!sband)
  		return;
-@@ -307,6 +315,10 @@ static void ath_reg_apply_radar_flags(st
+@@ -308,6 +316,10 @@ static void ath_reg_apply_radar_flags(st
  	struct ieee80211_channel *ch;
  	unsigned int i;
  
@@ -33,7 +33,7 @@
  	if (!wiphy->bands[IEEE80211_BAND_5GHZ])
  		return;
  
-@@ -513,6 +525,10 @@ ath_regd_init_wiphy(struct ath_regulator
+@@ -514,6 +526,10 @@ ath_regd_init_wiphy(struct ath_regulator
  {
  	const struct ieee80211_regdomain *regd;
  
Index: package/mac80211/patches/010-no_pcmcia.patch
===================================================================
--- package/mac80211/patches/010-no_pcmcia.patch	(revision 31639)
+++ package/mac80211/patches/010-no_pcmcia.patch	(working copy)
@@ -9,7 +9,7 @@
  # export CONFIG_SSB=m
  else
  include $(KLIB_BUILD)/.config
-@@ -289,7 +289,7 @@ export CONFIG_B43=m
+@@ -304,7 +304,7 @@ export CONFIG_B43=m
  export CONFIG_B43_HWRNG=y
  export CONFIG_B43_PCI_AUTOSELECT=y
  ifdef CONFIG_PCMCIA
Index: package/mac80211/patches/015-remove-rt2x00-options.patch
===================================================================
--- package/mac80211/patches/015-remove-rt2x00-options.patch	(revision 31639)
+++ package/mac80211/patches/015-remove-rt2x00-options.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -370,7 +370,7 @@ export CONFIG_RTL8180=m
+@@ -385,7 +385,7 @@ export CONFIG_RTL8180=m
  
  export CONFIG_ADM8211=m
  
@@ -9,7 +9,7 @@
  export CONFIG_RT2400PCI=m
  export CONFIG_RT2500PCI=m
  ifdef CONFIG_CRC_CCITT
-@@ -512,7 +512,7 @@ export CONFIG_RT2800USB_RT35XX=y
+@@ -528,7 +528,7 @@ export CONFIG_RT2800USB_RT35XX=y
  export CONFIG_RT2800USB_RT53XX=y
  export CONFIG_RT2800USB_UNKNOWN=y
  endif #CONFIG_CRC_CCITT
Index: package/mac80211/patches/622-rt2x00-fix-rt3352-ext-pa.patch
===================================================================
--- package/mac80211/patches/622-rt2x00-fix-rt3352-ext-pa.patch	(revision 0)
+++ package/mac80211/patches/622-rt2x00-fix-rt3352-ext-pa.patch	(revision 0)
@@ -0,0 +1,212 @@
+--- a/drivers/net/wireless/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/rt2x00/rt2800lib.c
+@@ -2271,15 +2271,18 @@ static void rt2800_config_channel(struct
+ 	/*
+ 	 * Change BBP settings
+ 	 */
++	rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
++	rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
++	rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
++
+ 	if (rt2x00_rt(rt2x00dev, RT3352)) {
+ 		rt2800_bbp_write(rt2x00dev, 27, 0x0);
+ 		rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
+ 		rt2800_bbp_write(rt2x00dev, 27, 0x20);
+ 		rt2800_bbp_write(rt2x00dev, 66, 0x26 + rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 86, 0x38);
++		rt2800_bbp_write(rt2x00dev, 83, 0x6a);
+ 	} else {
+-		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
+-		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
+-		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
+ 		rt2800_bbp_write(rt2x00dev, 86, 0);
+ 	}
+ 
+@@ -3850,6 +3853,7 @@ static int rt2800_init_rfcsr(struct rt2x
+ 	 * Init RF calibration.
+ 	 */
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392)) {
+ 		rt2800_rfcsr_read(rt2x00dev, 2, &rfcsr);
+@@ -4036,6 +4040,10 @@ static int rt2800_init_rfcsr(struct rt2x
+ 		rt2800_rfcsr_write(rt2x00dev, 31, 0x00);
+ 		return 0;
+ 	} else if (rt2x00_rt(rt2x00dev, RT3352)) {
++		int tx0_int_pa = test_bit(CAPABILITY_INTERNAL_PA_TX0,
++					  &rt2x00dev->cap_flags);
++		int tx1_int_pa = test_bit(CAPABILITY_INTERNAL_PA_TX1,
++					  &rt2x00dev->cap_flags);
+ 		rt2800_rfcsr_write(rt2x00dev, 0, 0xf0);
+ 		rt2800_rfcsr_write(rt2x00dev, 1, 0x23);
+ 		rt2800_rfcsr_write(rt2x00dev, 2, 0x50);
+@@ -4069,15 +4077,30 @@ static int rt2800_init_rfcsr(struct rt2x
+ 		rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
+ 		rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
+ 		rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
+-		rt2800_rfcsr_write(rt2x00dev, 34, 0x01);
++		rfcsr =  0x01;
++		if (!tx0_int_pa)
++			rt2x00_set_field8(&rfcsr, RFCSR34_TX0_EXT_PA, 1);
++		if (!tx1_int_pa)
++			rt2x00_set_field8(&rfcsr, RFCSR34_TX1_EXT_PA, 1);
++		rt2800_rfcsr_write(rt2x00dev, 34, rfcsr );
+ 		rt2800_rfcsr_write(rt2x00dev, 35, 0x03);
+ 		rt2800_rfcsr_write(rt2x00dev, 36, 0xbd);
+ 		rt2800_rfcsr_write(rt2x00dev, 37, 0x3c);
+ 		rt2800_rfcsr_write(rt2x00dev, 38, 0x5f);
+ 		rt2800_rfcsr_write(rt2x00dev, 39, 0xc5);
+ 		rt2800_rfcsr_write(rt2x00dev, 40, 0x33);
+-		rt2800_rfcsr_write(rt2x00dev, 41, 0x5b);
+-		rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
++		rfcsr = 0x52;
++		if (tx0_int_pa) {
++			rt2x00_set_field8(&rfcsr, RFCSR41_BIT1, 1);
++			rt2x00_set_field8(&rfcsr, RFCSR41_BIT4, 1);
++		}
++		rt2800_rfcsr_write(rt2x00dev, 41, rfcsr);
++		rfcsr = 0x52;
++		if (tx1_int_pa) {
++			rt2x00_set_field8(&rfcsr, RFCSR42_BIT1, 1);
++			rt2x00_set_field8(&rfcsr, RFCSR42_BIT4, 1);
++		}
++		rt2800_rfcsr_write(rt2x00dev, 42, rfcsr);
+ 		rt2800_rfcsr_write(rt2x00dev, 43, 0xdb);
+ 		rt2800_rfcsr_write(rt2x00dev, 44, 0xdb);
+ 		rt2800_rfcsr_write(rt2x00dev, 45, 0xdb);
+@@ -4085,15 +4108,20 @@ static int rt2800_init_rfcsr(struct rt2x
+ 		rt2800_rfcsr_write(rt2x00dev, 47, 0x0d);
+ 		rt2800_rfcsr_write(rt2x00dev, 48, 0x14);
+ 		rt2800_rfcsr_write(rt2x00dev, 49, 0x00);
+-		rt2800_rfcsr_write(rt2x00dev, 50, 0x2d);
+-		rt2800_rfcsr_write(rt2x00dev, 51, 0x7f);
+-		rt2800_rfcsr_write(rt2x00dev, 52, 0x00);
+-		rt2800_rfcsr_write(rt2x00dev, 53, 0x52);
+-		rt2800_rfcsr_write(rt2x00dev, 54, 0x1b);
+-		rt2800_rfcsr_write(rt2x00dev, 55, 0x7f);
+-		rt2800_rfcsr_write(rt2x00dev, 56, 0x00);
+-		rt2800_rfcsr_write(rt2x00dev, 57, 0x52);
+-		rt2800_rfcsr_write(rt2x00dev, 58, 0x1b);
++		rfcsr =  0x2d;
++		if (!tx0_int_pa)
++			rt2x00_set_field8(&rfcsr, RFCSR50_TX0_EXT_PA, 1);
++		if (!tx1_int_pa)
++			rt2x00_set_field8(&rfcsr, RFCSR50_TX1_EXT_PA, 1);
++		rt2800_rfcsr_write(rt2x00dev, 50, rfcsr);
++		rt2800_rfcsr_write(rt2x00dev, 51, (tx0_int_pa ? 0x7f : 0x52));
++		rt2800_rfcsr_write(rt2x00dev, 52, (tx0_int_pa ? 0x00 : 0xc0));
++		rt2800_rfcsr_write(rt2x00dev, 53, (tx0_int_pa ? 0x52 : 0xd2));
++		rt2800_rfcsr_write(rt2x00dev, 54, (tx0_int_pa ? 0x1b : 0xc0));
++		rt2800_rfcsr_write(rt2x00dev, 55, (tx1_int_pa ? 0x7f : 0x52));
++		rt2800_rfcsr_write(rt2x00dev, 56, (tx1_int_pa ? 0x00 : 0xc0));
++		rt2800_rfcsr_write(rt2x00dev, 57, (tx0_int_pa ? 0x52 : 0x49));
++		rt2800_rfcsr_write(rt2x00dev, 58, (tx1_int_pa ? 0x1b : 0xc0));
+ 		rt2800_rfcsr_write(rt2x00dev, 59, 0x00);
+ 		rt2800_rfcsr_write(rt2x00dev, 60, 0x00);
+ 		rt2800_rfcsr_write(rt2x00dev, 61, 0x00);
+@@ -4854,7 +4882,8 @@ static int rt2800_init_eeprom(struct rt2
+ 	/*
+ 	 * Detect if this device has Bluetooth co-existence.
+ 	 */
+-	if (rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_BT_COEXIST))
++	if (!rt2x00_rt(rt2x00dev, RT3352) &&
++	    rt2x00_get_field16(eeprom, EEPROM_NIC_CONF1_BT_COEXIST))
+ 		__set_bit(CAPABILITY_BT_COEXIST, &rt2x00dev->cap_flags);
+ 
+ 	/*
+@@ -4883,6 +4912,22 @@ static int rt2800_init_eeprom(struct rt2
+ 					EIRP_MAX_TX_POWER_LIMIT)
+ 		__set_bit(CAPABILITY_POWER_LIMIT, &rt2x00dev->cap_flags);
+ 
++	/*
++	 * Detect if device uses internal or external PA
++	 */
++	rt2x00_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1, &eeprom);
++
++	if (rt2x00_rt(rt2x00dev, RT3352)) {
++		if (!rt2x00_get_field16(eeprom,
++		    EEPROM_NIC_CONF1_EXTERNAL_TX0_PA_3352))
++			__set_bit(CAPABILITY_INTERNAL_PA_TX0,
++				  &rt2x00dev->cap_flags);
++		if (!rt2x00_get_field16(eeprom,
++		    EEPROM_NIC_CONF1_EXTERNAL_TX1_PA_3352))
++			__set_bit(CAPABILITY_INTERNAL_PA_TX1,
++				  &rt2x00dev->cap_flags);
++	}
++
+ 	return 0;
+ }
+ 
+--- a/drivers/net/wireless/rt2x00/rt2800.h
++++ b/drivers/net/wireless/rt2x00/rt2800.h
+@@ -2115,6 +2115,12 @@ struct mac_iveiv_entry {
+ #define RFCSR31_RX_CALIB		FIELD8(0x7f)
+ 
+ /*
++ * RFCSR 34:
++ */
++#define RFCSR34_TX0_EXT_PA		FIELD8(0x04)
++#define RFCSR34_TX1_EXT_PA		FIELD8(0x08)
++
++/*
+  * RFCSR 38:
+  */
+ #define RFCSR38_RX_LO1_EN		FIELD8(0x20)
+@@ -2125,6 +2131,18 @@ struct mac_iveiv_entry {
+ #define RFCSR39_RX_LO2_EN		FIELD8(0x80)
+ 
+ /*
++ * RFCSR 41:
++ */
++#define RFCSR41_BIT1			FIELD8(0x01)
++#define RFCSR41_BIT4			FIELD8(0x08)
++
++/*
++ * RFCSR 42:
++ */
++#define RFCSR42_BIT1			FIELD8(0x01)
++#define RFCSR42_BIT4			FIELD8(0x08)
++
++/*
+  * RFCSR 49:
+  */
+ #define RFCSR49_TX			FIELD8(0x3f)
+@@ -2133,6 +2151,8 @@ struct mac_iveiv_entry {
+  * RFCSR 50:
+  */
+ #define RFCSR50_TX			FIELD8(0x3f)
++#define RFCSR50_TX0_EXT_PA		FIELD8(0x02)
++#define RFCSR50_TX1_EXT_PA		FIELD8(0x10)
+ 
+ /*
+  * RF registers
+@@ -2220,6 +2240,8 @@ struct mac_iveiv_entry {
+  * INTERNAL_TX_ALC: 0: disable, 1: enable
+  * BT_COEXIST: 0: disable, 1: enable
+  * DAC_TEST: 0: disable, 1: enable
++ * EXTERNAL_TX0_PA: 0: disable, 1: enable (only on RT3352)
++ * EXTERNAL_TX1_PA: 0: disable, 1: enable (only on RT3352)
+  */
+ #define	EEPROM_NIC_CONF1		0x001b
+ #define EEPROM_NIC_CONF1_HW_RADIO		FIELD16(0x0001)
+@@ -2237,6 +2259,8 @@ struct mac_iveiv_entry {
+ #define EEPROM_NIC_CONF1_INTERNAL_TX_ALC		FIELD16(0x2000)
+ #define EEPROM_NIC_CONF1_BT_COEXIST		FIELD16(0x4000)
+ #define EEPROM_NIC_CONF1_DAC_TEST		FIELD16(0x8000)
++#define EEPROM_NIC_CONF1_EXTERNAL_TX0_PA_3352	FIELD16(0x4000)
++#define EEPROM_NIC_CONF1_EXTERNAL_TX1_PA_3352	FIELD16(0x8000)
+ 
+ /*
+  * EEPROM frequency
+--- a/drivers/net/wireless/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/rt2x00/rt2x00.h
+@@ -743,6 +743,8 @@ enum rt2x00_capability_flags {
+ 	CAPABILITY_DOUBLE_ANTENNA,
+ 	CAPABILITY_BT_COEXIST,
+ 	CAPABILITY_VCO_RECALIBRATION,
++	CAPABILITY_INTERNAL_PA_TX0,
++	CAPABILITY_INTERNAL_PA_TX1,
+ };
+ 
+ /*
Index: package/mac80211/patches/563-ath9k_rx_dma_stop_check.patch
===================================================================
--- package/mac80211/patches/563-ath9k_rx_dma_stop_check.patch	(revision 0)
+++ package/mac80211/patches/563-ath9k_rx_dma_stop_check.patch	(revision 0)
@@ -0,0 +1,28 @@
+--- a/drivers/net/wireless/ath/ath9k/mac.c
++++ b/drivers/net/wireless/ath/ath9k/mac.c
+@@ -689,7 +689,7 @@ bool ath9k_hw_stopdmarecv(struct ath_hw 
+ {
+ #define AH_RX_STOP_DMA_TIMEOUT 10000   /* usec */
+ 	struct ath_common *common = ath9k_hw_common(ah);
+-	u32 mac_status, last_mac_status = 0;
++	u32 mac_status = 0, last_mac_status = 0;
+ 	int i;
+ 
+ 	/* Enable access to the DMA observation bus */
+@@ -719,6 +719,16 @@ bool ath9k_hw_stopdmarecv(struct ath_hw 
+ 	}
+ 
+ 	if (i == 0) {
++		if (!AR_SREV_9300_20_OR_LATER(ah) &&
++		    (mac_status & 0x700) == 0) {
++			/*
++			 * DMA is idle but the MAC is still stuck
++			 * processing events
++			 */
++			*reset = true;
++			return true;
++		}
++
+ 		ath_err(common,
+ 			"DMA failed to stop in %d ms AR_CR=0x%08x AR_DIAG_SW=0x%08x DMADBG_7=0x%08x\n",
+ 			AH_RX_STOP_DMA_TIMEOUT / 1000,
Index: package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch
===================================================================
--- package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch	(revision 31639)
+++ package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch	(working copy)
@@ -19,7 +19,7 @@
 
 --- a/drivers/net/wireless/b43/b43.h
 +++ b/drivers/net/wireless/b43/b43.h
-@@ -1047,6 +1047,32 @@ static inline bool b43_using_pio_transfe
+@@ -1048,6 +1048,32 @@ static inline bool b43_using_pio_transfe
  	return dev->__using_pio_transfers;
  }
  
@@ -73,7 +73,7 @@
  struct b43_bus_dev *b43_bus_dev_ssb_init(struct ssb_device *sdev);
 --- a/drivers/net/wireless/b43/phy_common.c
 +++ b/drivers/net/wireless/b43/phy_common.c
-@@ -251,6 +251,12 @@ void b43_phy_write(struct b43_wldev *dev
+@@ -266,6 +266,12 @@ void b43_phy_write(struct b43_wldev *dev
  {
  	assert_mac_suspended(dev);
  	dev->phy.ops->phy_write(dev, reg, value);
@@ -88,7 +88,7 @@
  		dev->phy.writes_counter = 0;
 --- a/drivers/net/wireless/b43/phy_n.c
 +++ b/drivers/net/wireless/b43/phy_n.c
-@@ -4837,14 +4837,14 @@ static inline void check_phyreg(struct b
+@@ -5423,14 +5423,14 @@ static inline void check_phyreg(struct b
  static u16 b43_nphy_op_read(struct b43_wldev *dev, u16 reg)
  {
  	check_phyreg(dev, reg);
@@ -105,7 +105,7 @@
  	b43_write16(dev, B43_MMIO_PHY_DATA, value);
  }
  
-@@ -4852,7 +4852,7 @@ static void b43_nphy_op_maskset(struct b
+@@ -5438,7 +5438,7 @@ static void b43_nphy_op_maskset(struct b
  				 u16 set)
  {
  	check_phyreg(dev, reg);
@@ -114,7 +114,7 @@
  	b43_maskset16(dev, B43_MMIO_PHY_DATA, mask, set);
  }
  
-@@ -4863,7 +4863,7 @@ static u16 b43_nphy_op_radio_read(struct
+@@ -5449,7 +5449,7 @@ static u16 b43_nphy_op_radio_read(struct
  	/* N-PHY needs 0x100 for read access */
  	reg |= 0x100;
  
@@ -123,7 +123,7 @@
  	return b43_read16(dev, B43_MMIO_RADIO_DATA_LOW);
  }
  
-@@ -4872,7 +4872,7 @@ static void b43_nphy_op_radio_write(stru
+@@ -5458,7 +5458,7 @@ static void b43_nphy_op_radio_write(stru
  	/* Register 1 is a 32-bit register. */
  	B43_WARN_ON(reg == 1);
  
Index: package/mac80211/patches/567-ath9k_ani_mrc_fix.patch
===================================================================
--- package/mac80211/patches/567-ath9k_ani_mrc_fix.patch	(revision 0)
+++ package/mac80211/patches/567-ath9k_ani_mrc_fix.patch	(revision 0)
@@ -0,0 +1,13 @@
+--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+@@ -1035,6 +1035,10 @@ static bool ar9003_hw_ani_control(struct
+ 		 * is_on == 0 means MRC CCK is OFF (more noise imm)
+ 		 */
+ 		bool is_on = param ? 1 : 0;
++
++		if (ah->caps.rx_chainmask == 1)
++			break;
++
+ 		REG_RMW_FIELD(ah, AR_PHY_MRC_CCK_CTRL,
+ 			      AR_PHY_MRC_CCK_ENABLE, is_on);
+ 		REG_RMW_FIELD(ah, AR_PHY_MRC_CCK_CTRL,
Index: package/mac80211/patches/009-remove_mac80211_module_dependence.patch
===================================================================
--- package/mac80211/patches/009-remove_mac80211_module_dependence.patch	(revision 31639)
+++ package/mac80211/patches/009-remove_mac80211_module_dependence.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -53,7 +53,7 @@ endif
+@@ -54,7 +54,7 @@ endif
  ifeq ($(KERNEL_VERSION),2)
  ifeq ($(shell test $(KERNEL_VERSION) -eq 2 -a $(KERNEL_26SUBLEVEL) -ge 27 -a $(KERNEL_26SUBLEVEL) -le 31 && echo yes),yes)
  ifeq ($(CONFIG_MAC80211),)
Index: package/mac80211/patches/412-mac80211_allow_adhoc_and_ap.patch
===================================================================
--- package/mac80211/patches/412-mac80211_allow_adhoc_and_ap.patch	(revision 31639)
+++ package/mac80211/patches/412-mac80211_allow_adhoc_and_ap.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/net/mac80211/main.c
 +++ b/net/mac80211/main.c
-@@ -766,17 +766,11 @@ int ieee80211_register_hw(struct ieee802
+@@ -792,17 +792,11 @@ int ieee80211_register_hw(struct ieee802
  	 */
  	for (i = 0; i < hw->wiphy->n_iface_combinations; i++) {
  		const struct ieee80211_iface_combination *c;
Index: package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch
===================================================================
--- package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch	(revision 31639)
+++ package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch	(working copy)
@@ -1,7 +1,7 @@
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1936,8 +1936,8 @@ int ath9k_hw_reset(struct ath_hw *ah, st
- 	REG_WRITE(ah, AR_OBS, 8);
+@@ -1949,8 +1949,8 @@ int ath9k_hw_reset(struct ath_hw *ah, st
+ 		REG_WRITE(ah, AR_OBS, 8);
  
  	if (ah->config.rx_intr_mitigation) {
 -		REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, 500);
Index: package/mac80211/patches/120-pr_fmt_warnings.patch
===================================================================
--- package/mac80211/patches/120-pr_fmt_warnings.patch	(revision 31639)
+++ package/mac80211/patches/120-pr_fmt_warnings.patch	(working copy)
@@ -1,267 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/ani.c
-+++ b/drivers/net/wireless/ath/ath5k/ani.c
-@@ -14,6 +14,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include "ath5k.h"
---- a/drivers/net/wireless/ath/ath5k/attach.c
-+++ b/drivers/net/wireless/ath/ath5k/attach.c
-@@ -20,6 +20,7 @@
- * Attach/Detach Functions and helpers *
- \*************************************/
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/pci.h>
---- a/drivers/net/wireless/ath/ath5k/base.c
-+++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -40,6 +40,7 @@
-  *
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/module.h>
---- a/drivers/net/wireless/ath/ath5k/debug.c
-+++ b/drivers/net/wireless/ath/ath5k/debug.c
-@@ -58,6 +58,7 @@
-  * THE POSSIBILITY OF SUCH DAMAGES.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/export.h>
---- a/drivers/net/wireless/ath/ath5k/desc.c
-+++ b/drivers/net/wireless/ath/ath5k/desc.c
-@@ -21,6 +21,7 @@
-  Hardware Descriptor Functions
- \******************************/
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include "ath5k.h"
---- a/drivers/net/wireless/ath/ath5k/dma.c
-+++ b/drivers/net/wireless/ath/ath5k/dma.c
-@@ -29,6 +29,7 @@
-  * status registers (ISR).
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include "ath5k.h"
---- a/drivers/net/wireless/ath/ath5k/eeprom.c
-+++ b/drivers/net/wireless/ath/ath5k/eeprom.c
-@@ -21,6 +21,7 @@
- * EEPROM access functions and helpers *
- \*************************************/
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/slab.h>
---- a/drivers/net/wireless/ath/ath5k/initvals.c
-+++ b/drivers/net/wireless/ath/ath5k/initvals.c
-@@ -19,6 +19,7 @@
-  *
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include "ath5k.h"
---- a/drivers/net/wireless/ath/ath5k/led.c
-+++ b/drivers/net/wireless/ath/ath5k/led.c
-@@ -39,6 +39,7 @@
-  *
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/pci.h>
---- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-@@ -41,6 +41,7 @@
-  *
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <net/mac80211.h>
---- a/drivers/net/wireless/ath/ath5k/pci.c
-+++ b/drivers/net/wireless/ath/ath5k/pci.c
-@@ -14,6 +14,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/nl80211.h>
---- a/drivers/net/wireless/ath/ath5k/phy.c
-+++ b/drivers/net/wireless/ath/ath5k/phy.c
-@@ -22,6 +22,7 @@
- * PHY related functions *
- \***********************/
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/delay.h>
---- a/drivers/net/wireless/ath/ath5k/qcu.c
-+++ b/drivers/net/wireless/ath/ath5k/qcu.c
-@@ -20,6 +20,7 @@
- Queue Control Unit, DCF Control Unit Functions
- \********************************************/
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include "ath5k.h"
---- a/drivers/net/wireless/ath/ath5k/reset.c
-+++ b/drivers/net/wireless/ath/ath5k/reset.c
-@@ -23,6 +23,7 @@
-   Reset function and helpers
- \****************************/
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <asm/unaligned.h>
---- a/drivers/net/wireless/ath/ath5k/sysfs.c
-+++ b/drivers/net/wireless/ath/ath5k/sysfs.c
-@@ -1,3 +1,4 @@
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/device.h>
---- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
-+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
-@@ -15,6 +15,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/moduleparam.h>
---- a/drivers/net/wireless/ath/ath6kl/init.c
-+++ b/drivers/net/wireless/ath/ath6kl/init.c
-@@ -16,6 +16,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/moduleparam.h>
---- a/drivers/net/wireless/ath/ath6kl/main.c
-+++ b/drivers/net/wireless/ath/ath6kl/main.c
-@@ -15,6 +15,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include "core.h"
---- a/drivers/net/wireless/ath/ath6kl/txrx.c
-+++ b/drivers/net/wireless/ath/ath6kl/txrx.c
-@@ -15,6 +15,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include "core.h"
---- a/drivers/net/wireless/ath/ath9k/htc_drv_init.c
-+++ b/drivers/net/wireless/ath/ath9k/htc_drv_init.c
-@@ -14,6 +14,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include "htc.h"
---- a/drivers/net/wireless/ath/ath9k/htc_hst.c
-+++ b/drivers/net/wireless/ath/ath9k/htc_hst.c
-@@ -14,6 +14,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include "htc.h"
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -14,6 +14,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/dma-mapping.h>
---- a/drivers/net/wireless/ath/ath9k/pci.c
-+++ b/drivers/net/wireless/ath/ath9k/pci.c
-@@ -14,6 +14,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/nl80211.h>
---- a/drivers/net/wireless/ath/main.c
-+++ b/drivers/net/wireless/ath/main.c
-@@ -14,6 +14,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/kernel.h>
---- a/drivers/net/wireless/ath/regd.c
-+++ b/drivers/net/wireless/ath/regd.c
-@@ -14,6 +14,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/kernel.h>
---- a/drivers/net/wireless/iwlwifi/iwl-agn.c
-+++ b/drivers/net/wireless/iwlwifi/iwl-agn.c
-@@ -27,6 +27,7 @@
-  *
-  *****************************************************************************/
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/kernel.h>
---- a/drivers/net/wireless/iwlwifi/iwl-pci.c
-+++ b/drivers/net/wireless/iwlwifi/iwl-pci.c
-@@ -61,6 +61,7 @@
-  *
-  *****************************************************************************/
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/module.h>
Index: package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch
===================================================================
--- package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch	(revision 0)
+++ package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch	(revision 0)
@@ -0,0 +1,113 @@
+This adds a bwmode debugfs file which can be used to set alternate
+channel operating bandwidths.  Only tested with AR5413 and only at
+5 and 20 mhz channels.
+
+Signed-off-by: Pat Erley <pat-lkml at erley.org>
+---
+Other devices will need to be added to the switch in  write_file_bwmode
+
+drivers/net/wireless/ath/ath5k/debug.c |   86 ++++++++++++++++++++++++++++++++
+ 1 files changed, 86 insertions(+), 0 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath5k/debug.c
++++ b/drivers/net/wireless/ath/ath5k/debug.c
+@@ -813,6 +813,89 @@ static const struct file_operations fops
+ 	.llseek = default_llseek,
+ };
+ 
++/* debugfs: bwmode */
++
++static ssize_t read_file_bwmode(struct file *file, char __user *user_buf,
++				   size_t count, loff_t *ppos)
++{
++	struct ath5k_hw *ah = file->private_data;
++	char buf[15];
++	unsigned int len = 0;
++
++	int cur_ah_bwmode = ah->ah_bwmode;
++
++#define print_selected(MODE, LABEL) \
++	if (cur_ah_bwmode == MODE) \
++		len += snprintf(buf+len, sizeof(buf)-len, "[%s]", LABEL); \
++	else \
++		len += snprintf(buf+len, sizeof(buf)-len, "%s", LABEL); \
++	len += snprintf(buf+len, sizeof(buf)-len, " ");
++
++	print_selected(AR5K_BWMODE_5MHZ, "5");
++	print_selected(AR5K_BWMODE_10MHZ, "10");
++	print_selected(AR5K_BWMODE_DEFAULT, "20");
++	print_selected(AR5K_BWMODE_40MHZ, "40");
++#undef print_selected
++
++	len += snprintf(buf+len, sizeof(buf)-len, "\n");
++
++	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
++}
++
++static ssize_t write_file_bwmode(struct file *file,
++				 const char __user *userbuf,
++				 size_t count, loff_t *ppos)
++{
++	struct ath5k_hw *ah = file->private_data;
++	char buf[3];
++	int bw = 20;
++	int tobwmode = AR5K_BWMODE_DEFAULT;
++
++	if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
++		return -EFAULT;
++
++	/* TODO: Add check for active interface */
++
++	if(strncmp(buf, "5", 1) == 0 ) {
++		tobwmode = AR5K_BWMODE_5MHZ;
++		bw = 5;
++	} else if ( strncmp(buf, "10", 2) == 0 ) {
++		tobwmode = AR5K_BWMODE_10MHZ;
++		bw = 10;
++	} else if ( strncmp(buf, "20", 2) == 0 ) {
++		tobwmode = AR5K_BWMODE_DEFAULT;
++		bw = 20;
++	} else if ( strncmp(buf, "40", 2) == 0 ) {
++		tobwmode = AR5K_BWMODE_40MHZ;
++		bw = 40;
++	} else
++		return -EINVAL;
++
++	ATH5K_INFO(ah, "Changing to %imhz channel width[%i]\n",
++		bw, tobwmode);
++
++	switch (ah->ah_radio) {
++		/* TODO: only define radios that actually support 5/10mhz channels */
++		case AR5K_RF5413: case AR5K_RF5110: case AR5K_RF5111: case AR5K_RF5112: case AR5K_RF2413: case AR5K_RF2316: case AR5K_RF2317: case AR5K_RF2425:
++			if(ah->ah_bwmode != tobwmode) {
++				mutex_lock(&ah->lock);
++				ah->ah_bwmode = tobwmode;
++				mutex_unlock(&ah->lock);
++			}
++			break;
++		default:
++			return -EOPNOTSUPP;
++	}
++	return count;
++}
++
++static const struct file_operations fops_bwmode = {
++	.read = read_file_bwmode,
++	.write = write_file_bwmode,
++	.open = simple_open,
++	.owner = THIS_MODULE,
++	.llseek = default_llseek,
++};
+ 
+ /* debugfs: queues etc */
+ 
+@@ -904,6 +987,9 @@ ath5k_debug_init_device(struct ath5k_hw 
+ 	debugfs_create_file("beacon", S_IWUSR | S_IRUSR, phydir, ah,
+ 			    &fops_beacon);
+ 
++	debugfs_create_file("bwmode", S_IWUSR | S_IRUSR, phydir, ah,
++			    &fops_bwmode);
++
+ 	debugfs_create_file("reset", S_IWUSR, phydir, ah, &fops_reset);
+ 
+ 	debugfs_create_file("antenna", S_IWUSR | S_IRUSR, phydir, ah,
Index: package/mac80211/patches/530-ath9k_limit_qlen.patch
===================================================================
--- package/mac80211/patches/530-ath9k_limit_qlen.patch	(revision 31639)
+++ package/mac80211/patches/530-ath9k_limit_qlen.patch	(working copy)
@@ -1,143 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -243,6 +243,7 @@ struct ath_atx_tid {
- 	struct ath_node *an;
- 	struct ath_atx_ac *ac;
- 	unsigned long tx_buf[BITS_TO_LONGS(ATH_TID_MAX_BUFS)];
-+	int buf_pending;
- 	int bar_index;
- 	u16 seq_start;
- 	u16 seq_next;
-@@ -289,6 +290,9 @@ struct ath_tx_control {
-  *  (axq_qnum).
-  */
- struct ath_tx {
-+	u32 qlen_single;
-+	u32 qlen_aggr;
-+
- 	u16 seq_no;
- 	u32 txqsetup;
- 	spinlock_t txbuflock;
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1646,6 +1646,10 @@ int ath9k_init_debug(struct ath_hw *ah)
- 			    &fops_interrupt);
- 	debugfs_create_file("xmit", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_xmit);
-+	debugfs_create_u32("qlen_single", S_IRUSR | S_IWUSR,
-+			   sc->debug.debugfs_phy, &sc->tx.qlen_single);
-+	debugfs_create_u32("qlen_aggr", S_IRUSR | S_IWUSR,
-+			   sc->debug.debugfs_phy, &sc->tx.qlen_aggr);
- 	debugfs_create_file("stations", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_stations);
- 	debugfs_create_file("misc", S_IRUSR, sc->debug.debugfs_phy, sc,
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -392,6 +392,14 @@ static void ath_tx_count_frames(struct a
- 	}
- }
- 
-+static struct ath_atx_tid *ath_get_tid(struct ath_node *an, struct sk_buff *skb)
-+{
-+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-+	u8 tidno;
-+
-+	tidno = ieee80211_get_qos_ctl(hdr)[0] & IEEE80211_QOS_CTL_TID_MASK;
-+	return ATH_AN_2_TID(an, tidno);
-+}
- 
- static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,
- 				 struct ath_buf *bf, struct list_head *bf_q,
-@@ -486,6 +494,8 @@ static void ath_tx_complete_aggr(struct 
- 	__skb_queue_head_init(&bf_pending);
- 
- 	ath_tx_count_frames(sc, bf, ts, txok, &nframes, &nbad);
-+	tid->buf_pending -= nframes;
-+
- 	while (bf) {
- 		u16 seqno = bf->bf_state.seqno;
- 
-@@ -884,6 +894,7 @@ static enum ATH_AGGR_STATUS ath_tx_form_
- 			ath_tx_addto_baw(sc, tid, seqno);
- 		bf->bf_state.ndelim = ndelim;
- 
-+		tid->buf_pending++;
- 		__skb_unlink(skb, &tid->buf_q);
- 		list_add_tail(&bf->list, bf_q);
- 		if (bf_prev)
-@@ -1737,6 +1748,8 @@ static void ath_tx_send_ampdu(struct ath
- 	/* Add sub-frame to BAW */
- 	ath_tx_addto_baw(sc, tid, bf->bf_state.seqno);
- 
-+	tid->buf_pending++;
-+
- 	/* Queue to h/w without aggregation */
- 	TX_STAT_INC(txctl->txq->axq_qnum, a_queued_hw);
- 	bf->bf_lastbf = bf;
-@@ -1869,22 +1882,11 @@ error:
- 
- /* FIXME: tx power */
- static void ath_tx_start_dma(struct ath_softc *sc, struct sk_buff *skb,
--			     struct ath_tx_control *txctl)
-+			     struct ath_tx_control *txctl,
-+			     struct ath_atx_tid *tid)
- {
- 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
--	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
--	struct ath_atx_tid *tid = NULL;
- 	struct ath_buf *bf;
--	u8 tidno;
--
--	if ((sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT) && txctl->an &&
--		ieee80211_is_data_qos(hdr->frame_control)) {
--		tidno = ieee80211_get_qos_ctl(hdr)[0] &
--			IEEE80211_QOS_CTL_TID_MASK;
--		tid = ATH_AN_2_TID(txctl->an, tidno);
--
--		WARN_ON(tid->ac->txq != txctl->txq);
--	}
- 
- 	if ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) && tid) {
- 		/*
-@@ -1916,6 +1918,7 @@ int ath_tx_start(struct ieee80211_hw *hw
- 	struct ieee80211_vif *vif = info->control.vif;
- 	struct ath_softc *sc = hw->priv;
- 	struct ath_txq *txq = txctl->txq;
-+	struct ath_atx_tid *tid = NULL;
- 	int padpos, padsize;
- 	int frmlen = skb->len + FCS_LEN;
- 	int q;
-@@ -1958,6 +1961,24 @@ int ath_tx_start(struct ieee80211_hw *hw
- 
- 	setup_frame_info(hw, skb, frmlen);
- 
-+	if ((sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_HT) && txctl->an &&
-+	    ieee80211_is_data_qos(hdr->frame_control)) {
-+		tid = ath_get_tid(txctl->an, skb);
-+
-+		WARN_ON(tid->ac->txq != txq);
-+	}
-+
-+	if ((info->flags & IEEE80211_TX_CTL_AMPDU) && tid) {
-+		if (sc->tx.qlen_aggr > 0 && skb_queue_len(&tid->buf_q) +
-+		    tid->buf_pending >= sc->tx.qlen_aggr)
-+			return -ENOMEM;
-+	} else {
-+		if (sc->tx.qlen_single > 0 &&
-+		    txq->axq_depth - txq->axq_ampdu_depth >=
-+		      sc->tx.qlen_single)
-+			return -ENOMEM;
-+	}
-+
- 	/*
- 	 * At this point, the vif, hw_key and sta pointers in the tx control
- 	 * info are no longer valid (overwritten by the ath_frame_info data.
-@@ -1972,7 +1993,7 @@ int ath_tx_start(struct ieee80211_hw *hw
- 		txq->stopped = true;
- 	}
- 
--	ath_tx_start_dma(sc, skb, txctl);
-+	ath_tx_start_dma(sc, skb, txctl, tid);
- 
- 	ath_txq_unlock(sc, txq);
- 
Index: package/mac80211/patches/310-ap_scan.patch
===================================================================
--- package/mac80211/patches/310-ap_scan.patch	(revision 0)
+++ package/mac80211/patches/310-ap_scan.patch	(revision 0)
@@ -0,0 +1,11 @@
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -1796,8 +1796,6 @@ static int ieee80211_scan(struct wiphy *
+ 		 * beaconing hasn't been configured yet
+ 		 */
+ 	case NL80211_IFTYPE_AP:
+-		if (sdata->u.ap.beacon)
+-			return -EOPNOTSUPP;
+ 		break;
+ 	default:
+ 		return -EOPNOTSUPP;
Index: package/mac80211/patches/551-ath9k_optimize_interrupt_mitigation.patch
===================================================================
--- package/mac80211/patches/551-ath9k_optimize_interrupt_mitigation.patch	(revision 31639)
+++ package/mac80211/patches/551-ath9k_optimize_interrupt_mitigation.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
 +++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
-@@ -237,21 +237,19 @@ static bool ar9003_hw_get_isr(struct ath
+@@ -240,21 +240,19 @@ static bool ar9003_hw_get_isr(struct ath
  
  		*masked = isr & ATH9K_INT_COMMON;
  
Index: package/mac80211/patches/608-add_platform_data_mac_addr.patch
===================================================================
--- package/mac80211/patches/608-add_platform_data_mac_addr.patch	(revision 0)
+++ package/mac80211/patches/608-add_platform_data_mac_addr.patch	(revision 0)
@@ -0,0 +1,63 @@
+--- a/include/linux/rt2x00_platform.h
++++ b/include/linux/rt2x00_platform.h
+@@ -14,6 +14,7 @@
+ 
+ struct rt2x00_platform_data {
+ 	char *eeprom_file_name;
++	const u8 *mac_address;
+ 
+ 	int disable_2ghz;
+ 	int disable_5ghz;
+--- a/drivers/net/wireless/rt2x00/rt2x00dev.c
++++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
+@@ -825,6 +825,18 @@ static void rt2x00lib_rate(struct ieee80
+ 		entry->flags |= IEEE80211_RATE_SHORT_PREAMBLE;
+ }
+ 
++const u8 *rt2x00lib_get_mac_address(struct rt2x00_dev *rt2x00dev)
++{
++	struct rt2x00_platform_data *pdata;
++
++	pdata = rt2x00dev->dev->platform_data;
++	if (!pdata)
++		return NULL;
++
++	return pdata->mac_address;
++}
++EXPORT_SYMBOL_GPL(rt2x00lib_get_mac_address);
++
+ static int rt2x00lib_probe_hw_modes(struct rt2x00_dev *rt2x00dev,
+ 				    struct hw_mode_spec *spec)
+ {
+--- a/drivers/net/wireless/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/rt2x00/rt2x00.h
+@@ -1280,6 +1280,7 @@ static inline void rt2x00debug_dump_fram
+  */
+ u32 rt2x00lib_get_bssidx(struct rt2x00_dev *rt2x00dev,
+ 			 struct ieee80211_vif *vif);
++const u8 *rt2x00lib_get_mac_address(struct rt2x00_dev *rt2x00dev);
+ 
+ /*
+  * Interrupt context handlers.
+--- a/drivers/net/wireless/rt2x00/rt61pci.c
++++ b/drivers/net/wireless/rt2x00/rt61pci.c
+@@ -2392,6 +2392,7 @@ static int rt61pci_validate_eeprom(struc
+ 	u32 reg;
+ 	u16 word;
+ 	u8 *mac;
++	const u8 *pdata_mac;
+ 	s8 value;
+ 
+ 	rt2x00pci_register_read(rt2x00dev, E2PROM_CSR, &reg);
+@@ -2412,7 +2413,11 @@ static int rt61pci_validate_eeprom(struc
+ 	/*
+ 	 * Start validation of the data that has been read.
+ 	 */
++	pdata_mac = rt2x00lib_get_mac_address(rt2x00dev);
+ 	mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
++	if (pdata_mac)
++		memcpy(mac, pdata_mac, 6);
++
+ 	if (!is_valid_ether_addr(mac)) {
+ 		eth_random_addr(mac);
+ 		EEPROM(rt2x00dev, "MAC: %pM\n", mac);
Index: package/mac80211/patches/560-ath9k_reduce_ani_interval.patch
===================================================================
--- package/mac80211/patches/560-ath9k_reduce_ani_interval.patch	(revision 0)
+++ package/mac80211/patches/560-ath9k_reduce_ani_interval.patch	(revision 0)
@@ -0,0 +1,11 @@
+--- a/drivers/net/wireless/ath/ath9k/ani.h
++++ b/drivers/net/wireless/ath/ath9k/ani.h
+@@ -51,7 +51,7 @@
+ #define ATH9K_ANI_PERIOD                  300
+ 
+ /* in ms */
+-#define ATH9K_ANI_POLLINTERVAL            1000
++#define ATH9K_ANI_POLLINTERVAL            100
+ 
+ #define HAL_NOISE_IMMUNE_MAX              4
+ #define HAL_SPUR_IMMUNE_MAX               7
Index: package/mac80211/patches/800-b43-gpio-mask-module-option.patch
===================================================================
--- package/mac80211/patches/800-b43-gpio-mask-module-option.patch	(revision 31639)
+++ package/mac80211/patches/800-b43-gpio-mask-module-option.patch	(working copy)
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/b43/b43.h
 +++ b/drivers/net/wireless/b43/b43.h
-@@ -803,6 +803,7 @@ struct b43_wldev {
+@@ -807,6 +807,7 @@ struct b43_wldev {
  	bool qos_enabled;		/* TRUE, if QoS is used. */
  	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
  	bool use_pio;			/* TRUE if next init should use PIO */
@@ -22,7 +22,7 @@
  static int modparam_bad_frames_preempt;
  module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
  MODULE_PARM_DESC(bad_frames_preempt,
-@@ -2689,10 +2694,10 @@ static int b43_gpio_init(struct b43_wlde
+@@ -2688,10 +2693,10 @@ static int b43_gpio_init(struct b43_wlde
  	u32 mask, set;
  
  	b43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);
Index: package/mac80211/patches/891_ath9k_htc_advertize_allowed_vif_combinations.patch
===================================================================
--- package/mac80211/patches/891_ath9k_htc_advertize_allowed_vif_combinations.patch	(revision 0)
+++ package/mac80211/patches/891_ath9k_htc_advertize_allowed_vif_combinations.patch	(revision 0)
@@ -0,0 +1,53 @@
+diff --git a/drivers/net/wireless/ath/ath9k/htc_drv_init.c b/drivers/net/wireless/ath/ath9k/htc_drv_init.c
+index d98255e..4d65af1 100644
+--- a/drivers/net/wireless/ath/ath9k/htc_drv_init.c
++++ b/drivers/net/wireless/ath/ath9k/htc_drv_init.c
+@@ -694,6 +694,38 @@  err_hw:
+ 	return ret;
+ }
+ 
++/*
++ * It is possible to have atmost ATH9K_HTC_MAX_BCN_VIF beaconing interfaces
++ * therefore either we have 1 IBSS + ATH9K_HTC_MAX_BCN_VIF - 1 AP's, or we
++ * have only ATH9K_HTC_MAX_BCN_VIF AP's
++ */
++
++static const struct ieee80211_iface_limit if_limits_ibss[] = {
++	{.max = ATH9K_HTC_MAX_VIF, .types = BIT(NL80211_IFTYPE_STATION)},
++	{.max = ATH9K_HTC_MAX_VIF - 1, .types = BIT(NL80211_IFTYPE_AP)},
++	{.max = 1, .types = BIT(NL80211_IFTYPE_ADHOC)},
++};
++
++static const struct ieee80211_iface_limit if_limits_no_ibss[] = {
++	{.max = ATH9K_HTC_MAX_VIF, .types = BIT(NL80211_IFTYPE_STATION)},
++	{.max = ATH9K_HTC_MAX_VIF, .types = BIT(NL80211_IFTYPE_AP)},
++};
++
++static const struct ieee80211_iface_combination if_comb[] = {
++	{.limits = if_limits_ibss,
++	 .n_limits = ARRAY_SIZE(if_limits_ibss),
++	 .max_interfaces = ATH9K_HTC_MAX_VIF,
++	 .num_different_channels = 1,
++	 .beacon_int_infra_match = true,
++	},
++	{.limits = if_limits_no_ibss,
++	 .n_limits = ARRAY_SIZE(if_limits_no_ibss),
++	 .max_interfaces = ATH9K_HTC_MAX_VIF,
++	 .num_different_channels = 1,
++	 .beacon_int_infra_match = true,
++	},
++};
++
+ static void ath9k_set_hw_capab(struct ath9k_htc_priv *priv,
+ 			       struct ieee80211_hw *hw)
+ {
+@@ -716,6 +748,9 @@  static void ath9k_set_hw_capab(struct ath9k_htc_priv *priv,
+ 		BIT(NL80211_IFTYPE_P2P_GO) |
+ 		BIT(NL80211_IFTYPE_P2P_CLIENT);
+ 
++	hw->wiphy->iface_combinations = if_comb;
++	hw->wiphy->n_iface_combinations = ARRAY_SIZE(if_comb);
++
+ 	hw->wiphy->flags &= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
+ 
+ 	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN |
Index: package/mac80211/patches/070-disable_codel.patch
===================================================================
--- package/mac80211/patches/070-disable_codel.patch	(revision 0)
+++ package/mac80211/patches/070-disable_codel.patch	(revision 0)
@@ -0,0 +1,19 @@
+--- a/compat/scripts/gen-compat-config.sh
++++ b/compat/scripts/gen-compat-config.sh
+@@ -66,16 +66,3 @@ if [[ ${CONFIG_COMPAT_KERNEL_2_6_36} = "
+ 		echo "export CONFIG_COMPAT_KFIFO=y"
+ 	fi
+ fi
+-
+-if [[ ${CONFIG_COMPAT_KERNEL_3_5} = "y" ]]; then
+-	# We don't have 2.6.24 backport support yet for Codel / FQ CoDel
+-	# For those who want to try this is what is required that I can tell
+-	# so far:
+-	#  * struct Qdisc_ops
+-	#	- init and change callback ops use a different argument dataype
+-	# 	- you need to parse data received from userspace differently
+-	if [[ ${CONFIG_COMPAT_KERNEL_2_6_25} != "y" ]]; then
+-		echo "export CONFIG_COMPAT_NET_SCH_CODEL=m"
+-		echo "export CONFIG_COMPAT_NET_SCH_FQ_CODEL=m"
+-	fi
+-fi
Index: package/mac80211/Makefile
===================================================================
--- package/mac80211/Makefile	(revision 31639)
+++ package/mac80211/Makefile	(working copy)
@@ -10,10 +10,10 @@
 
 PKG_NAME:=mac80211
 
-PKG_VERSION:=2012-04-17
-PKG_RELEASE:=2
+PKG_VERSION:=2012-09-07
+PKG_RELEASE:=3
 PKG_SOURCE_URL:=http://mirror2.openwrt.org/sources
-PKG_MD5SUM:=2607092b22b5cb552dc3c79921c85369
+PKG_MD5SUM:=59e0a114ee4b755a6e47cb6cd0f32ebc
 
 PKG_SOURCE:=compat-wireless-$(PKG_VERSION).tar.bz2
 PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/compat-wireless-$(PKG_VERSION)
@@ -49,13 +49,13 @@
   SUBMENU:=$(WMENU)
   URL:=http://linuxwireless.org/
   MAINTAINER:=Felix Fietkau <nbd@openwrt.org>
-  DEPENDS:=@(!(TARGET_avr32||TARGET_ep93xx||TARGET_ps3||TARGET_pxcab)||BROKEN)
+  DEPENDS:=@(!(TARGET_avr32||TARGET_ps3||TARGET_pxcab)||BROKEN)
 endef
 
 define KernelPackage/cfg80211
   $(call KernelPackage/mac80211/Default)
   TITLE:=cfg80211 - wireless configuration API
-  DEPENDS+= +wireless-tools +iw +crda
+  DEPENDS+= +iw
   FILES:= \
 	$(PKG_BUILD_DIR)/compat/compat.ko \
 	$(PKG_BUILD_DIR)/net/wireless/cfg80211.ko
@@ -634,7 +634,7 @@
   DEPENDS:= +kmod-mac80211 @PCI_SUPPORT
   TITLE:=Intel AGN Wireless support
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlwifi/iwlwifi.ko
-  AUTOLOAD:=$(call AutoLoad,60,iwlagn)
+  AUTOLOAD:=$(call AutoLoad,60,iwlwifi)
   MENU:=1
 endef
 
@@ -710,7 +710,7 @@
   DEPENDS:= +kmod-mac80211 @PCI_SUPPORT
   TITLE:=Intel legacy Wireless support
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/iwlegacy/iwlegacy.ko
-  AUTOLOAD:=$(call AutoLoad,60,iwl-legacy)
+  AUTOLOAD:=$(call AutoLoad,60,iwlegacy)
 endef
 
 define KernelPackage/iwl-legacy/description
@@ -977,6 +977,8 @@
 		    G  => G-PHY
 		    LP => LP-PHY
 		    N  => N-PHY
+		    HT  => HT-PHY
+		    LCN  => LCN-PHY
 
 		  Example (keep files for G-PHY only):
 		    G
@@ -1078,36 +1080,62 @@
 Kernel module for Broadcom 43xx-legacy wireless support (mac80211 stack) new
 endef
 
-define KernelPackage/brcmsmac
+
+define KernelPackage/brcmutil
   $(call KernelPackage/mac80211/Default)
-  TITLE:=Broadcom IEEE802.11n PCIe SoftMAC WLAN driver
+  TITLE:=Broadcom IEEE802.11n common driver parts
   URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
-  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT +!TARGET_brcm47xx:kmod-bcma +kmod-lib-cordic +kmod-lib-crc8
-  FILES:= \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmsmac/brcmsmac.ko \
-	$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmutil/brcmutil.ko
-  AUTOLOAD:=$(call AutoLoad,30,brcmutil brcmsmac)
+  DEPENDS+=@PCI_SUPPORT||USB_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmutil/brcmutil.ko
+  AUTOLOAD:=$(call AutoLoad,30,brcmutil)
   MENU:=1
 endef
 
-define KernelPackage/brcmsmac/description
- Kernel modules for Broadcom IEEE802.11n PCIe Wireless cards
+define KernelPackage/brcmutil/description
+ This module contains some common parts needed by Broadcom Wireless drivers brcmsmac and brcmfmac.
 endef
 
-define KernelPackage/brcmsmac/config
+define KernelPackage/brcmutil/config
 	menu "Configuration"
-		depends on PACKAGE_kmod-brcmsmac
+		depends on PACKAGE_kmod-brcmutil
 
 	config PACKAGE_BRCM80211_DEBUG
-		bool "brcmsmac wireless debugging"
+		bool "Broadcom wireless driver debugging"
 		help
-		  Say Y, if you want to debug brcmsmac wireless driver.
+		  Say Y, if you want to debug brcmsmac and brcmfmac wireless driver.
 
 	endmenu
 endef
 
+define KernelPackage/brcmsmac
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Broadcom IEEE802.11n PCIe SoftMAC WLAN driver
+  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
+  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT +!TARGET_brcm47xx:kmod-bcma +kmod-lib-cordic +kmod-lib-crc8 +kmod-brcmutil
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmsmac/brcmsmac.ko
+  AUTOLOAD:=$(call AutoLoad,31,brcmsmac)
+endef
+
+define KernelPackage/brcmsmac/description
+ Kernel module for Broadcom IEEE802.11n PCIe Wireless cards
+endef
+
+define KernelPackage/brcmfmac
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Broadcom IEEE802.11n USB FullMAC WLAN driver
+  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
+  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-cfg80211 +@DRIVER_11N_SUPPORT +kmod-brcmutil
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmfmac/brcmfmac.ko
+  AUTOLOAD:=$(call AutoLoad,60,brcmfmac)
+endef
+
+define KernelPackage/brcmfmac/description
+ Kernel module for Broadcom IEEE802.11n USB Wireless cards
+endef
+
 BUILDFLAGS:= \
 	-I$(PKG_BUILD_DIR)/include \
+	-DCONFIG_CFG80211_INTERNAL_REGDB=y \
 	$(foreach opt,$(CONFOPTS),-DCONFIG_$(opt)) \
 	$(if $(CONFIG_PCI),-DCONFIG_B43_PCI_AUTOSELECT -DCONFIG_B43_PCICORE_AUTOSELECT) \
 	$(if $(CONFIG_LEDS_TRIGGERS), -DCONFIG_MAC80211_LEDS -DCONFIG_LEDS_TRIGGERS -DCONFIG_B43_LEDS -DCONFIG_B43LEGACY_LEDS) \
@@ -1143,13 +1171,15 @@
 	$(if $(CONFIG_PACKAGE_kmod-iwl3945),-DCONFIG_IWL3945) \
 	$(if $(CONFIG_PACKAGE_kmod-iwl4965),-DCONFIG_COMPAT_IWL4965) \
 	$(if $(CONFIG_PACKAGE_kmod-wl12xx),-DCONFIG_WL12XX -DCONFIG_COMPAT_WL12XX_SDIO) \
-	$(if $(CONFIG_PACKAGE_BRCM80211_DEBUG),-DCONFIG_BRCMDBG)
+	$(if $(CONFIG_PACKAGE_BRCM80211_DEBUG),-DCONFIG_BRCMDBG) \
+	$(if $(CONFIG_PACKAGE_kmod-brcmfmac),-DCONFIG_BRCMFMAC_USB)
 
 MAKE_OPTS:= \
 	CROSS_COMPILE="$(KERNEL_CROSS)" \
 	ARCH="$(LINUX_KARCH)" \
 	EXTRA_CFLAGS="$(BUILDFLAGS)" \
 	$(foreach opt,$(CONFOPTS),CONFIG_$(opt)=m) \
+	CONFIG_CFG80211_INTERNAL_REGDB=y \
 	CONFIG_CFG80211=$(if $(CONFIG_PACKAGE_kmod-cfg80211),m) \
 	CONFIG_MAC80211=$(if $(CONFIG_PACKAGE_kmod-mac80211),m) \
 	CONFIG_MAC80211_RC_MINSTREL=y \
@@ -1275,9 +1305,10 @@
 	CONFIG_ATL2= \
 	CONFIG_ATL1E= \
 	CONFIG_ATL1C= \
-	CONFIG_BRCMFMAC= \
-	CONFIG_BRCMUTIL=$(if $(CONFIG_PACKAGE_kmod-brcmsmac),m) \
+	CONFIG_BRCMUTIL=$(if $(CONFIG_PACKAGE_kmod-brcmutil),m) \
 	CONFIG_BRCMSMAC=$(if $(CONFIG_PACKAGE_kmod-brcmsmac),m) \
+	CONFIG_BRCMFMAC=$(if $(CONFIG_PACKAGE_kmod-brcmfmac),m) \
+	CONFIG_BRCMFMAC_USB=$(if $(CONFIG_PACKAGE_kmod-brcmfmac),y) \
 	CONFIG_BRCMDBG=$(if $(CONFIG_PACKAGE_BRCM80211_DEBUG),y) \
 	KLIB_BUILD="$(LINUX_DIR)" \
 	MODPROBE=true \
@@ -1300,9 +1331,13 @@
 	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(PKG_LINUX_FIRMWARE_SOURCE)
 	rm -rf $(PKG_BUILD_DIR)/include/linux/ssb
 	rm -rf $(PKG_BUILD_DIR)/include/linux/bcma
+	rm -rf $(PKG_BUILD_DIR)/include/net/bluetooth/
 	rm -f $(PKG_BUILD_DIR)/include/linux/eeprom_93cx6.h
+	rm -f $(PKG_BUILD_DIR)/include/linux/wl12xx.h
+	rm -f $(PKG_BUILD_DIR)/include/linux/spi/libertas_spi.h
 	rm -f $(PKG_BUILD_DIR)/include/net/ieee80211.h
 	echo 'compat-wireless-$(PKG_VERSION)-$(PKG_RELEASE)-$(REVISION)' > $(PKG_BUILD_DIR)/compat_version
+	$(CP) ./files/regdb.txt $(PKG_BUILD_DIR)/net/wireless/db.txt
 endef
 
 ifneq ($(CONFIG_PACKAGE_kmod-cfg80211)$(CONFIG_PACKAGE_kmod-lib80211),)
@@ -1312,6 +1347,12 @@
  endef
 endif
 
+define Build/Configure
+	cmp $(PKG_BUILD_DIR)/include/linux/ath9k_platform.h $(LINUX_DIR)/include/linux/ath9k_platform.h
+	cmp $(PKG_BUILD_DIR)/include/linux/ath5k_platform.h $(LINUX_DIR)/include/linux/ath5k_platform.h
+	cmp $(PKG_BUILD_DIR)/include/linux/rt2x00_platform.h $(LINUX_DIR)/include/linux/rt2x00_platform.h
+endef
+
 define Build/Compile
 	$(call Build/Compile/kmod)
 endef
@@ -1533,6 +1574,13 @@
 		$(1)/lib/firmware/brcm/
 endef
 
+define KernelPackage/brcmfmac/install
+	$(INSTALL_DIR) $(1)/lib/firmware/brcm
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/brcmfmac43236b.bin \
+		$(1)/lib/firmware/brcm/
+endef
+
 $(eval $(call KernelPackage,ath5k))
 $(eval $(call KernelPackage,lib80211))
 $(eval $(call KernelPackage,libertas-usb))
@@ -1566,7 +1614,9 @@
 $(eval $(call KernelPackage,carl9170))
 $(eval $(call KernelPackage,b43))
 $(eval $(call KernelPackage,b43legacy))
+$(eval $(call KernelPackage,brcmutil))
 $(eval $(call KernelPackage,brcmsmac))
+$(eval $(call KernelPackage,brcmfmac))
 $(eval $(call KernelPackage,net-libipw))
 $(eval $(call KernelPackage,net-ipw2100))
 $(eval $(call KernelPackage,net-ipw2200))
Index: package/mac80211/files/regdb.txt
===================================================================
--- package/mac80211/files/regdb.txt	(revision 0)
+++ package/mac80211/files/regdb.txt	(revision 0)
@@ -0,0 +1,697 @@
+# This is the world regulatory domain
+country 00:
+	(2402 - 2472 @ 40), (3, 20)
+        # Channel 12 - 13. No HT40 channel fits here
+        (2457 - 2482 @ 20), (3, 20), PASSIVE-SCAN, NO-IBSS
+        # Channel 14. Only JP enables this and for 802.11b only
+        (2474 - 2494 @ 20), (3, 20), PASSIVE-SCAN, NO-IBSS, NO-OFDM
+        # Channel 36 - 48
+        (5170 - 5250 @ 40), (3, 20)
+        # NB: 5260 MHz - 5700 MHz requies DFS
+        # Channel 149 - 165
+        (5735 - 5835 @ 40), (3, 20), PASSIVE-SCAN, NO-IBSS
+
+
+country AE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AL:
+	(2402 - 2482 @ 20), (N/A, 20)
+
+country AM:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 18)
+	(5250 - 5330 @ 20), (N/A, 18), DFS
+
+country AN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country AT: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AU:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 23)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country AW:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AZ:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country BA: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country BB:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 23)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country BD:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country BE: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country BG: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 23)
+	(5250 - 5290 @ 40), (N/A, 23), DFS
+	(5490 - 5710 @ 40), (N/A, 30), DFS
+
+country BH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+	(5735 - 5835 @ 20), (N/A, 20)
+
+country BL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country BN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country BO:
+	(2402 - 2482 @ 40), (N/A, 30)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country BR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country BY:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country BZ:
+	(2402 - 2482 @ 40), (N/A, 30)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country CA:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country CH: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country CL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 20)
+
+country CN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country CO:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country CR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country CS:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country CY: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+# Data from http://www.ctu.eu/164/download/VOR/VOR-12-08-2005-34.pdf
+# and http://www.ctu.eu/164/download/VOR/VOR-12-05-2007-6-AN.pdf
+# Power at 5250 - 5350 MHz and 5470 - 5725 MHz can be doubled if TPC is
+# implemented.
+country CZ: DFS-ETSI
+	(2400 - 2483.5 @ 40), (N/A, 100 mW)
+	(5150 - 5250 @ 40), (N/A, 200 mW), NO-OUTDOOR
+	(5250 - 5350 @ 40), (N/A, 100 mW), NO-OUTDOOR, DFS
+	(5470 - 5725 @ 40), (N/A, 500 mW), DFS
+
+# Data from "Frequenznutzungsplan" (as published in April 2008), downloaded from
+# http://www.bundesnetzagentur.de/cae/servlet/contentblob/38448/publicationFile/2659/Frequenznutzungsplan2008_Id17448pdf.pdf
+# For the 5GHz range also see
+# http://www.bundesnetzagentur.de/cae/servlet/contentblob/38216/publicationFile/6579/WLAN5GHzVfg7_2010_28042010pdf.pdf
+# The values have been reduced by a factor of 2 (3db) for non TPC devices
+# (in other words: devices with TPC can use twice the tx power of this table).
+# Note that the docs do not require TPC for 5150--5250; the reduction to
+# 100mW thus is not strictly required -- however the conservative 100mW
+# limit is used here as the non-interference with radar and satellite
+# apps relies on the attenuation by the building walls only in the
+# absence of DFS; the neighbour countries have 100mW limit here as well.
+
+country DE: DFS-ETSI
+	# entries 279004 and 280006
+	(2400 - 2483.5 @ 40), (N/A, 100 mW)
+	# entry 303005
+	(5150 - 5250 @ 40), (N/A, 100 mW), NO-OUTDOOR
+	# entries 304002 and 305002
+	(5250 - 5350 @ 40), (N/A, 100 mW), NO-OUTDOOR, DFS
+	# entries 308002, 309001 and 310003
+	(5470 - 5725 @ 40), (N/A, 500 mW), DFS
+
+country DK: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country DO:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country DZ:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country EC:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country EE: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country EG:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+
+country ES: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country FI: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country FR: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country GE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country GB: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country GD:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country GR: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country GL: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+	(5490 - 5710 @ 20), (N/A, 27), DFS
+
+country GT:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country GU:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country HN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country HK:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country HR: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country HT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country HU: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country ID:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country IE: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country IL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5150 - 5250 @ 40), (N/A, 200 mW), NO-OUTDOOR
+	(5250 - 5350 @ 40), (N/A, 200 mW), NO-OUTDOOR, DFS
+
+country IN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 20)
+
+country IS: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country IR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country IT: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country JM:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country JP:
+	(2402 - 2472 @ 40), (N/A, 20)
+	(2457 - 2482 @ 20), (N/A, 20)
+	(2474 - 2494 @ 20), (N/A, 20), NO-OFDM
+	(4910 - 4930 @ 10), (N/A, 23)
+	(4910 - 4990 @ 40), (N/A, 23)
+	(4930 - 4950 @ 10), (N/A, 23)
+	(5030 - 5045 @ 10), (N/A, 23)
+	(5030 - 5090 @ 40), (N/A, 23)
+	(5050 - 5060 @ 10), (N/A, 23)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 23), DFS
+
+country JO:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+
+country KE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country KH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country KP:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5330 @ 40), (3, 20)
+	(5160 - 5250 @ 40), (3, 20), DFS
+	(5490 - 5630 @ 40), (3, 30), DFS
+	(5735 - 5815 @ 40), (3, 30)
+
+country KR:
+	(2402 - 2482 @ 20), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 20)
+	(5250 - 5330 @ 20), (3, 20), DFS
+	(5490 - 5630 @ 20), (3, 30), DFS
+	(5735 - 5815 @ 20), (3, 30)
+
+country KW:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+
+country KZ:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country LB:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country LI: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country LK:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 20), DFS
+	(5490 - 5710 @ 20), (3, 20), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country LT: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country LU: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country LV: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country MC: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country MA:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country MO:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 23)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country MK: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country MT: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country MY:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 30), DFS
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country MX:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country NL: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20), NO-OUTDOOR
+	(5250 - 5330 @ 40), (N/A, 20), NO-OUTDOOR, DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country NO: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country NP:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country NZ:
+	(2402 - 2482 @ 40), (N/A, 30)
+	(5170 - 5250 @ 20), (3, 23)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country OM:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country PA:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country PE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country PG:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country PH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country PK:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country PL: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country PT: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country PR:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country QA:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country RO: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country RU:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 20), (N/A, 30)
+
+country SA:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 23)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country SE: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country SG:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 20)
+
+country SI: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country SK: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country SV:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country SY:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country TW:
+	(2402 - 2472 @ 40), (3, 27)
+	(5270 - 5330 @ 40), (3, 17), DFS
+	(5735 - 5815 @ 40), (3, 30)
+
+country TH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country TT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country TN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+
+country TR: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+
+country UA:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country US: DFS-FCC
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5600 @ 40), (3, 20), DFS
+	(5650 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country UY:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country UZ:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country VE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5815 @ 40), (N/A, 23)
+
+country VN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+
+country YE:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country ZA:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country ZW:
+	(2402 - 2482 @ 40), (N/A, 20)
+
